a windowed query operator breaks a data stream into possibly overlapping subsets of data and computes a result over each. many stream systems can evaluate window aggregate queries. however  current stream systems suffer from a lack of an explicit definition of window semantics. as a result  their implementations unnecessarily confuse window definition with physical stream properties. this confusion complicates the stream system  and even worse  can hurt performance both in terms of memory usage and execution time. to address this problem  we propose a framework for defining window semantics  which can be used to express almost all types of windows of which we are aware  and which is easily extensible to other types of windows that may occur in the future. based on this definition  we explore a one-pass query evaluation strategy  the window-id  wid  approach  for various types of window aggregate queries. wid significantly reduces both required memory space and execution time for a large class of window definitions. in addition  wid can leverage punctuations to gracefully handle disorder. our experimental study shows that wid has better execution-time performance than existing window aggregate query evaluation options that retain and reprocess tuples  and has better latencyaccuracy tradeoffs for disordered input streams compared to using a fixed delay for handling disorder. 
1. introduction 
many types of data present themselves in stream format: environmental sensor readings  network monitoring data  telephone call records  traffic sensor data and auction bids  to name a few. for applications monitoring and processing streams  window aggregates are an important query feature. a window specifies a moving view that decomposes the stream into  possibly overlapping  subsets that we call window extents  and computes a result over each.  think of a window specification as a  cookie cutter  and window extents as cookies cut with it.  for example   compute the number of vehicles on i-1 between milepost 1 and milepost 1 over the past 1 minutes; update the count every 1 minute  is a window aggregate query where successive window extents overlap by 1 minutes. 
 
evaluating window aggregate queries over streams is non-trivial. the potential for high data-arrival rates  and huge data volumes  along with near real-time requirements in many stream applications  make memory and execution-time performance of stream query evaluation critical. bursty and out-of-order data arrival raises problems with detecting the boundaries of window extents. out-of-order arrival also complicates the process of determining the content of window extents and can lead to inaccurate aggregate results or high latency in the output of the results. we have observed that accommodating out-of-order arrival can introduce significant complexity into window query evaluation.  
we see two major issues with current stream systems that process window queries. one is the lack of explicit window semantics. as a result  the exact content of each window extent tends to be confused with window operator implementation and physical stream properties. the other issue is implementation efficiency  in particular  memory usage and execution time. to evaluate slidingwindow aggregate queries where consecutive window extents overlap  i.e.  each tuple belongs to multiple window extents   most current proposals keep all active input tuples in an inmemory buffer. in addition  each tuple is reprocessed multiple times-once for each window extent to which it belongs. we will propose an approach that avoids intra-operator buffering and tuple reprocessing.  
in this paper  we present a framework for defining window semantics and a window query evaluation technique based on it. in the framework  we define window semantics explicitly- independent of any algorithm for evaluating window queries. from our definitions  it is clear that many commonly used types of windows do not depend on physical stream order. however  most existing window-query evaluation techniques assume that stream data are ordered or are ordered within some bound. our window query evaluation technique  called the window-id  wid  approach  is suggested by the semantic framework. our technique processes each input tuple on the fly as it arrives  without keeping tuples in buffers and without reprocessing tuples. our experimental study shows significantly improved execution-time 

 
permission to make digital or hard copies of all or part of this work for 

performance over existing evaluation techniques that buffer and reprocess tuples. 

personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  or republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee. 
acm sigmod 1  june 1  1  baltimore  maryland  usa. 
copyright 1 acm 1-1/1...$1. 
in contrast to other techniques  wid can process out-of-order tuples as they arrive without sorting them into the  correct  order. it does not require a specific type of assumption about the physical order of data in the stream. instead  it uses punctuation  to encode whatever kind of ordering information is available. in the later part of the paper  we examine real-life examples of 

mechanisms for handling it; section 1 presents performance results; and section 1 concludes. 
1. running example ¡¡¡¡figure 1: four detection stations in a detection task  from yonnel gardes  the transpo group  kirkland  wa  with permission  we introduce a running example that illustrates the operations used in wid. via this example  we show that with wid 1  there is no need to retain input tuples in buffers  although there may be queues to pass tuples between steps; 1  each tuple is processed only once at a given step; and 1  no assumptions about the physical order of the input are required.  
consider a radiation-detection system that can be installed along freeways  such as the one under study in the new jersey turnpike radiation detection project at lawrence livermore national lab . a radiation-detection system identifies potentially dangerous vehicles  tracks them as they progress along the freeway  and targets a vehicle confirmed to have radioactive material for interception. figure 1 shows four detection stations involved in a detection task on i-1 northbound from i-1 to the holland tunnel. while tracking vehicles  it is critical to accurately forecast travel time between detection stations  so that the system does not lose track of suspicious vehicles. one way to address this problem is to estimate the max and min travel time between stations.  
a freeway is separated into non-overlapping segments by adjacent ramps. suppose that there exists a speed sensor  such as a pair of inductive loop detectors commonly found near freeway on-ramps  per segment along the freeway  and that speed readings are streamed to a central system  where the min and max speed for each segment of the freeway over the past five minutes are computed  and updated periodically. then  min and max travel time between stations can be calculated easily and continuously updated based on the current speed bound for each segment and the length of the segment. 
assume the schema of speed sensor readings is  seg-id  speed  ts   where seg-id is the segment id and ts is the timestamp for a sensor reading. we might choose to continuously compute the min and max speed of each segment by computing the min and max over the past 1 minutes  and updating the results every minute. we call this query q1  shown below in a cql-like language . note that the time notion  e.g.  over the past 1 minutes  in q1 is defined on the ts attribute of the sensor readings.  
q1: select 	seg-id  max speed   min speed  
   from  	traffic  range 1 seconds  
                     slide 1 seconds 
                     wattr ts  
group by seg-id  
   
figure 1 shows the steps that wid uses to process q1. the details of the operators are given in later sections. the traffic-speed stream  with punctuations  arrives at the query system. briefly  a punctuation is information embedded in a data stream indicating that no more tuples having certain attribute values will be seen in the stream. for example  punctuation p1 indicates that no more tuples will arrive from segment s1 that have a timestamp attribute value less than 1:1pm. in our example  we assume that each 	        seg-id    speed     ts  	           seg-id     speed    ts        wid  stream disorder and discuss disorder-handling methods. slack  intercepted and heartbeats  are mechanisms proposed for handling disorder in input streams. different means for handling disorder can affect the flexibility  scalability and performance of windowquery evaluation approaches. we experimentally evaluated latency-accuracy tradeoffs in handling disorder using wid and sort-based slack.  
this paper is organized as follows: section 1 provides a running example that illustrates the basic concepts of wid; section 1 introduces our framework for defining window semantics; section 1 discusses implications of window semantics for query evaluation; sections 1 and 1 present the implementation of wid; section 1 analyzes disorder using network flow data and discusses 
tags with window-ids 	     t1   s1     1    1:1      t1   s1     1    1:1               t1   s1     1    1:1    p1  s1       *    1:1            t1                t1       p1¡ä¡ä  s1      *         *            1       s1    1   1:1  1  ¡ä¡ä   s1    1    1:1  1            s1    1    1:1  1  	      m1  1    s1     1     1      m1  1    s1     1     1    wid  seg-id  max  min  
	 t1   s1     1    1:1  	      t1¡ä   s1    1   1:1  1  
	p1  s1       *    1:1  	     p1¡ä  s1      *         *           1    
	           ... ...     	                     ... ...     
figure 1: operations on input tuples  using the wid approach to evaluate q1 

individual sensor provides such a punctuation every minute.  
as figure 1 shows  in the first step  each input tuple is tagged with a range of window-ids. in wid  each window extent is identified by a unique window-id. in this example  we use nonnegative integers for window-ids. suppose q1 starts at 1:1pm. each window extent is a 1-minute sub-stream  which overlaps with adjacent window extents. in our case  for example  window extent 1 is the 1:1pm - 1:1pm sub-stream; and window extent 1 is the 1:1pm - 1:1pm sub-stream. for each input tuple  we can calculate the window-ids for the window extents to which it belongs. for example  t1 belongs to window extents 1 through 1. a similar calculation is applied to punctuations. input punctuations  which punctuate on the seg-id and ts attributes  are transformed into punctuations on the seg-id and wid attributes. for example  p1 is transformed into p1¡ä  which indicates that no more tuples from the sensor at segment s1 for window extent 1 will arrive. note that we extend the input scheme of the speed tuple by adding the wid as an explicit attribute. also note that in the first step  each tuple or punctuation is processed immediately as it arrives  and is streamed out immediately after processing.  
the second step is an aggregation where tuples tagged with window-ids are grouped by the seg-id attribute  as well as the wid attribute. note that a tuple tagged with a range of window-ids represents a set of tuples  each tagged with a single window-id. an internal hash table is used to maintain the partial max and min value for each group. upon the arrival of a punctuation  the hash entry that matches the punctuation is output and purged from the hash table. for example  when punctuation p1¡ä arrives  m1 is output and its corresponding hash entry is cleared.  
overall  introducing window-ids into query execution brings benefits to both performance and system implementation. it reduces operator buffer space and execution time; and it transforms window aggregate queries into group-by aggregate queries and thus reduces the implementation complexity of the system. also observe that wid does not need to reorder tuples on ts  as long as punctuations are placed correctly. wid does require calculations for multiple window extents to be underway concurrently  but the storage overhead is trivial unless there are many more window extents than tuples. 
1. window semantics 
as can be seen from our example  the key to wid is the association of tuples with window-ids. in this section we present a semantic framework that makes this association explicit  independent of any particular operator implementation. in section 1 we return to window-aggregate evaluation based on this semantics. 
1 motivation 
in previous work  window semantics has often been described operationally. however  operational window definitions tend to lead to confusion of the window extent definition with physical data properties and implementation details. for example  some current window query operators process window extents sequentially- that is  they close the active window when a tuple past it arrives  which translates into a requirement that their input arrive in order of the windowing attribute. if the data is not in order  some sort mechanism such as aurora's bsort  must be used to reorder the data. without a mechanism to explicitly identify what extents tuples belong to  tuples cannot be processed in their arrival order  unless it corresponds to window order   which leads to retaining tuples in the implementation  latency  and inflexibility in query evaluation.  
we propose a semantic framework  and define the semantics of some existing types of windows under this framework. while our window semantics definition is independent of any implementation algorithm  having explicit window semantics leads directly to a flexible implementation that can handle a wide variety of windows and that can handle disordered data in several ways. in addition  an explicit definition makes it easier to verify the correctness of a window operator implementation. 
note that defining window semantics and implementing the defined semantics are two separate issues. a window semantics definition specifies the content of window extents  while implementation issues  such as determining when to process an extent  and whether to approximate its actual value   are handled by separate mechanisms or directives. 
1 window specification 
a window specification consists of a window type and a set of parameters that define a window to be used by a query. for example  the specification of the sliding window in q1 has parameters range  slide and wattr. in our window semantics  the content of a window extent is determined by applying a window specification to a set of input tuples. our goal in discussing window specifications is to introduce the parameters used to express different windows whose semantics will be defined later  but not to provide a universal specification for all possible windows. however  our window specification parameters are general enough to express almost all stream window aggregate queries we have seen  1  1 .  
our window specification for sliding window aggregate queries consists of three parameters  range  slide and wattr  which specify the length of the window  the step by which the window moves  and the windowing attribute-the attribute over which range and slide are specified. for ease of presentation  we assume the arrival time and the arrival position of tuples in a stream are explicit attributes arrival-ts and row-num in the input tuples. in the remainder of this section  we introduce different types of windows and their corresponding specifications. 
a time-based sliding window query  such as q1 in section 1  is expressed with range = 1 seconds  slide = 1 seconds and wattr = ts.  note that in this example  ts is the timestamp attribute provided by the sensors and not the arrival timestamp.  tuple-based sliding window queries are also common. a tuplebased query uses the row-num attribute of tuples as the wattr. for example  consider q1  which requests  count the number of vehicles for each segment over the past 1 rows  update that result every 1 rows  and is expressed as: 
q1: select 	seg-id  count *  
  from  	traffic  range 1 rows                       slide 1 rows 
                     wattr row-num  
group by seg-id 
 
potentially  wattr can be any tuple attribute with a totally ordered domain. having this option allows us to define windows over timestamps assigned by external data sources or internally by the system; to handle a stream with a schema containing multiple timestamp attributes; and to window over non-temporal attributes.  
another kind of sliding window has range and slide specified on different attributes. in such a case  sattr  slide attribute  and rattr  range attribute  are used in place of wattr. a common example of this type of window is a query with range over a timestamp attribute  ts  in our example  and slide 1 row over row-num. in such a case  each tuple arrival introduces a new window extent that has length range and ends at the newly-arrived tuple  as shown in query q1 below. we use the term slide-by-tuple for this type of windows. the window operator in cql uses slide-by-tuple windows to transform the input stream into instantaneous relations. 
q1: select 	seg-id  count *  
   from  	traffic  range 1 seconds  
                        rattr ts 
                        slide 1 row 
 	  	         sattr row-num  
 
a partitioned window-aggregate query uses an additional partitioning attribute  pattr  to split the input stream into substreams before applying the other parameters in the window specification to each. q1  shown below  is identical to q1 except that seg-id is now a partitioning attribute instead of a group-by attribute.  
q1: select 	seg-id  count *  
   from  	traffic  range 1 rows                       slide 1 rows 
                     wattr row-num 
                     pattr seg-id  
 
this change in the window specification leads to significant changes in the window semantics. q1  a non-partitioned query  takes a sequence of 1 tuples from input stream as a window extent  then divides those 1 tuples into groups by segment id and counts the vehicles in each group. in short  q1 first computes the window extent and then divides the extent into groups. in contrast  q1 first divides a stream into  partitions   sub-streams  by the partitioning attribute  and then divides each partition into window extents independently  based on the other three parameters. note that for time-based window queries  the pattr parameter does not bring more expressive power-the effect of a pattr attribute is the same as using it as a group-by attribute 
. 
discussion: our window specifications are similar to the window construct in cql  continuous query language    a sql-based language for expressing continuous queries over data streams. our window specification differs from cql in the use of explicit user-specified wattr and slide parameters  whereas the published version of cql  assumes a  slide-by-tuple  window semantics and uses a pre-defined timestamp or tuple sequence number as the windowing attribute.  
sql-1 defines a window clause for use on stored data. sql-1 limits windows to sliding by each tuple  i.e.  each tuple defines a window extent   thus tying each output tuple to an input tuple. we call such windows data-driven. in comparison  stream queries often use domain-driven window semantics  where users specify how far the consecutive window extents are spaced from each other in terms of domain values . we believe domain-driven windows are more suitable for applications with bursty or highvolume data. consider a network monitoring application-one might want network statistics updated at regular intervals  independent of surges or lulls in traffic.  
a variation of our window specifications is to use functions in parameters. for example  the following query q1 is a variation of q1.  
q1: select 	seg-id  count *  
   from  	traffic  range 1 seconds  
                        rattr ts 
                        slide 1 rows 
 	  	         sattr rank ts   
 
the function rank  ts  maps each tuple t in the input stream to its rank in order of the ts attribute values. so instead of advancing a window based on tuple-arrival order  we advance it based on the logical order implied by ts. so  the window in q1 is of the length 1 seconds over the ts attribute  and slides by 1 rows over the logical order defined by ts. conceptually  this window suggests sorting before windowing  similar to the window clause with the order by construct defined in sql-1. in this paper  we only consider rank rattr  in sattr-the attribute defining the slide order needs to agree with the range attribute. 
1 window-ids and window extents 
our framework defines window semantics using mappings between window-ids and tuples in both directions. the framework consists of three functions: windows  extent  and wids.     
in this sub-section  we describe windows and extent over a set of tuples  t  for each type of window we just discussed. for a given window type  windows defines the window-ids to use for that type of window-values from different domains are used as windowids for different types of window. the extent function specifies which tuples belong to the window extent denoted by a given window-id-the mapping from window-ids to tuples. more precisely  given a window specification s and the set of tuples t that compose a stream  windows t  s  is the set of window-ids that identify window extents to which tuples in t may belong. given a window-id w ¡Ê windows t  s   extent w  t  s  is the set of tuples in t belonging to the window extent identified by w. we require that extent w  t  s  be finite. note that t is an unordered  possibly infinite  logical entity-we do not expect an implementation to actually materialize it.  
for ease of presentation  we assume that range  slide and wattr  or  sattr and rattr  are all in the same units. for example in q1  range and slide are both in seconds.  
for window queries in which range and slide are specified on the wattr attribute  such as q1 or q1  the window and extent functions are as below. here  we use the non-negative integers for window-ids  which depend on neither t nor s.   windows t  s range  slide  wattr   = {1  1  1  ...}.   extent w  t  s range  slide  wattr   =  
     {t¡Êt | max     minminwattrwattr      tt +  w+1 *slide   range    
                ¡Ü t.wattr   minwattr t  +  w+1 *slide}. 
the extent function is defined using only the wattr values of tuples  independent of physical arrival order. in the extent function  the value minwattr t  represents the minimum value that wattr takes over all tuples in t. this exact value may be difficult to measure  but in practice any approximation that is less than minwattr t  is acceptable  and does not affect the window extent definition. assuming wattr values are non-negative numbers  one can always think of minwattr t  as 1. the 'max' in the extent function deals with the boundary cases where the window  straddles  minwattr t   by permitting  partial  window extents. for example  in q1  window extents 1 through 1 are partial  and they are of length 1  1  1  1 minutes respectively. 
the windows and extent functions above also apply to tumbling windows  and naturally extend to landmark windows. tumbling windows are a special case of sliding windows  where range equals slide and thus window extents do not overlap. landmark windows are similar to sliding windows except that each window extent starts at the  beginning  of the stream.  
for slide-by-tuple window queries  such as q1  the number of window extents is data-dependent and we do not use a simple integer sequence for window-ids. instead  we use values of t.rattr-the projection of input tuples on rattr-for window-ids. the windows and extent functions for slide-by-tuple windows are given below.  windows t  s range  rattr  1  row-num   =  
                                         {w | t ¡Ê t  w = t.rattr}. extent w  t  s  range   rattr  1  row-num   =  
                                         {u ¡Ê t | w - range   u.rattr ¡Ü w}. 
assuming unique rattr values  each rattr attribute value identifies a window extent that ends at that tuple.  
a variation on slide-by-tuple windows is a window for which the slide is n tuples. here  every nth tuple defines a window extent. thus  we use the rattr-value of every nth tuple in t as windowids. the extent function is the same as that of slide-by-tuple windows. the windows function is given by: windows t  s range  rattr  slide  row-num   =  
          {w | t ¡Ê t  mod t.row-num  slide  = 1   w = t.rattr}. 
for windows in which the slide is n tuples over the logical order of the stream given by rank rattr   as shown in q1  the extent function is also the same as for slide-by-tuple windows. the windows definition uses a rank t  attr  t  function  which  given a tuple t and attribute attr  returns t's rank in t in the order of attr. 
windows t  s range  rattr  slide  rank rattr    =                 {w | t ¡Ê t  mod  rank t  rattr  t    slide  = 1                           w = t.wattr}. 
for partitioned tuple-based window queries  such as q1  windowids are compound values consisting of a non-negative integer representing a window extent in a partition and a partitioning attribute value.  
windows t  s range  slide  wattr  pattr   =  
               { i  p  | i¡Ê{1  1  1  ...}  p¡Êt.pattr}. 
the extent function in this case determines the content of the window extent based both on its integer index and partitioning attribute value. in the extent function definition  we use the function rank t  attr  p  t   which given a tuple t  an attribute attr  a partitioning attribute p  and a set of tuples t   returns t's rank in the p partition of t  in the order of attr. for example  rank t  rownum  pattr  t  in the following extent function returns tuple t's arrival position in the partition to which it belongs  i.e.  t.pattr. extent   i  p   t  s range  slide  row-num  pattr   = 
 {t¡Êt | t.pattr = p           max     minminwattrwattr      tt + + i 1 *slide   range    ¡Ü         rank t.row-num  pattr  t    min wattr t  +  i+1 *slide}. 
1 mapping tuples to window-ids 
the extent function defines window semantics in a windowcentric way from the perspective of understanding the content of each window extent. in this section  we define the function wids  which is an inverse to the extent function  and maps each input tuple to a set of window-ids  representing window extents . the wids function provides the same window semantics information  in tuple-centric manner. intuitively  this tuple-centric version of the window semantics definition corresponds to operations on each input tuple in the implementation. for a given window type  let w = windows  t  s . then  for a tuple t  wids  t  t  s  is the set of window-ids in w that identify window extents to which tuple t belongs: wids  t  t  s  = {w¡Êw | t ¡Ê extent w }. 
the wids function for non-partitioned windows whose range and slide are both specified on the wattr attribute  such as q1 and q1  is defined as follows:  wids  t  t  s range  slide  wattr   =  
        {w¡Êw |  t.wattr - minwattr t   / slide - 1   w                     ¡Ü  t.wattr + range - minwattr t   / slide -1}. 
note that in this wids function  a tuple t is mapped to a set of window-ids  without reference to other tuples nor to t's arrival position in t. 
for slide-by-tuple windows such as q1  and its two variations  the wids function is given by: 
wids  t  t  s range  rattr  1  row-num   = 
        {w¡Êw | t.rattr ¡Ü w   t.rattr + range}. 
here  the window-ids of window extents to which tuple t belongs fall between t.rattr and t.rattr+range.  
for partitioned tuple-based windows  the wids function is given below  where r = rank  t  row-num  pattr  t : wids  t  t  s range  row-num  pattr   =  
       { i  p ¡Êw | t.pattr = p   r - minrow-num t   / slide - 1                             w ¡Ü  r + range - minrow-num t   / slide -1}. 
the correctness of each wids definition can be verified relative to the corresponding extent definition. we have proved that the discussed extent and wids pairs are inverses. the proof consists of two cases  based on whether minwattr t  is greater than minwattr t + w+1 *slide - range or not. 
discussion: our window specification is quite expressive and the semantic framework suggests a general way to define window semantics. we have discussed several types of windows that we are familiar with. however  not all windows well-defined in our specification are guaranteed to be meaningful; further  the wids functions might not always be effectively computable. in future work  we plan to characterize the functions used in the framework in order to guarantee a feasible implementation of wids functions.  
1. beyond semantics: towards window query evaluation 
to map a tuple to a set of window-ids  the wids functions for different types of windows require different information. in this section  we categorize different types of information that may be required  and classify windows based on this requirement. that categorization in turn helps dictate the appropriate implementation techniques for given types of windows. we define two types of  context  information that may be involved in the implementation of a wids function: backwardcontext and forward-context. given a tuple t  its backward-context is information about tuples that have arrived before t.  forwardcontext is information about tuples that will arrive after t. if a wids function requires backward-context  it implies that the implementation will need to maintain information about previously arrived tuples. for example  the implementation of a partitioned tuple-based window must maintain a count of tuples that have arrived for each partition. typically  having to maintain backward-context is not a significant restriction  and does not prevent one from determining window-ids immediately upon tuple arrival. in contrast  if a wids function requires forwardcontext  then information from tuples arriving after a tuple t is required to calculate the window-ids for t. this requirement implies that the exact window-ids for tuple t cannot all be determined until those later tuples arrive. thus a wids function requiring forward-context implies that tuples may need to be buffered and delayed. for example  slide-by-tuple windows require forward-context. the rank function in the wids definition for partitioned windows  e.g.  q1  reflects a backward-context requirement  because rank uses row-num as the attribute on which to define order. using the rattr-values of later tuples  i.e.  t.rattr ¡Ü w   t.rattr + range  in the wids definition for slide-by-tuple windows  e.g.  q1  reflects a forward-context requirement. 
we categorize windows as fcf  forward-context free   or fca  forward-context aware   based on their forward-context requirements. a window is fcf if the wids implementation does not require forward-context. time-based windows  tuple-based sliding windows  and partitioned tuple-based windows are fcf. a window is fca if the wids implementation requires forwardcontext. slide-by-tuple windows and its two variations  slide by n tuples over row-num and rank rattr   respectively  are fca. under the fcf category  a window is cf  context free  if the implementation of its wids function requires neither forward- nor backward-context. tuple-based and time-based sliding windows are cf. the wids function of a cf window maps each input tuple to a set of window-ids based only on the window specification and the tuple itself; correspondingly  in the implementation  window-ids for each tuple can be determined as the tuple arrives and no state needs to be maintained. we proceed to discuss the implementation details for different categories of windows. 
1. fcf windows: the wid approach 
we present our evaluation technique  wid  for window aggregate queries for fcf windows in this section  and for fca windows in the next section. wid is a direct application of our window semantics definition  of the wids function in particular. by using window-ids in the implementation  wid encapsulates window semantics in the operation that tags tuples with window-ids and explicitly transforms the window semantics of queries into data semantics via a wid attribute.  
wid provides one-pass query evaluation for sliding window aggregate queries  eliminating the need to retain input tuples in intra-operator buffers  and greatly reduces memory usage during query evaluation. wid is very flexible and scalable. the implementation does not put constraints on physical properties of the input streams. for example  other window aggregate algorithms require the data be sorted before being aggregated. in contrast  wid does not have such constraints. in addition  the aggregation step is window-agnostic  since wid is treated as any other attribute. we proceed to describe the system in which we implemented wid  and then discuss wid in detail for fcf windows. 
1 system overview and punctuation  
our implementation of wid is based on an extended version of the niagara query engine  for processing data streams. niagara was initially developed at the university of wisconsinmadison as a system for querying xml data on the internet. it is written in java and has a push-based  pipelined  query-processing model. the extended version of niagara supports data streams through the use of niagara operators enhanced to support punctuation . 
wid leverages punctuations for query execution and disorder handling. a punctuation is a message embedded in a data stream indicating that a certain subset of data is complete; a punctuation indicates that no more tuples having certain attribute values will be seen in the stream. punctuations are used in stream query processing to adapt blocking and stateful operators to data streams. tucker et al. have defined punctuation behavior for query operators . some operators  such as select  simply pass punctuations through to the next operator in the query plan. group-by operators use punctuations to recognize when groups are complete so they can output results for those groups  and purge associated state. wid uses punctuations to signal the end of window extents.  
the generation and source of punctuations is an interesting research problem in itself. punctuations may come from many sources. in the running example  punctuations come from the external data source; another common source of punctuations is operators in the query system. for example  if traffic sensors in the running example do not provide punctuations  punctuations can be generated based on the assumption that each traffic sensor produces sorted data. when the first tuple with a timestamp greater than 1 from segment s1 is received by an operator  that operator can assume that all data from segment s1 with timestamp before 1 have been received and can promptly generate a punctuation:  s1  *  1:1   the same as p1 in figure 1. we can also generate punctuations based on a slack bound on the maximal disorder in a data stream .  
1 query evaluation for fcf windows 
wid tags tuples with ranges of window-ids  keeps aggregate operators window-agnostic  and uses punctuation to indicate when to output results. 
1.1 bucket operator 
the first step in wid is to map each tuple explicitly to a set of window-ids. we introduce a new operator  bucket  that tags each tuple with its associated window-ids by using the appropriate wids function. a range of window-ids is appended to each tuple as a data attribute  wid.  alternatively  a wid value can also be an explicit set  or tuples can be duplicated with different ids  if necessary.  figure 1 shows the query plan for q1  a cf query  using wid. as shown  the bucket operator takes a window specification as a parameter. 
the implementation of bucket varies for different types of windows. a key aspect is the amount of state that bucket must maintain. for cf windows  such as q1 and q1  bucket need not maintain any state and can append a range of window-ids to each input tuple immediately when the tuple arrives  since the wids function for an fcf window does not require forward-context. bucket also applies a similar calculation to transform punctuations on wattr into punctuations on the wid attribute.
1.1 aggregation 
bucket tags tuples with window-ids; the aggregate operator processes these tuples to produce an aggregate value for each window extent. using the wid attribute as an additional grouping attribute is the key to this aggregation step. given a tuple t tagged with a range of window-ids w1-wn  t.wid = w1-wn   the aggregate operator uses t to update n aggregate values whose wid-values fall between w1 and wn inclusive. note that the window specification  and thus the window semantics  is not exposed to the aggregate operator. however  we have extended the aggregate operator to understand range values. 
the aggregate operator must detect when each window extent is complete and then output the result for that extent. detecting the ends of window extents is particularly challenging when the input stream is disordered  or when the data arrival rate is bursty or slow   because disordered input streams may lead to incomplete window extents  and bursty or slow streams may result in a high delay in outputting results. in wid  we use punctuations to indicate the ends of extents. when the aggregate operator receives a punctuation  it outputs the results for the matching window extents and purges the corresponding state. 
using punctuations to convey end-of-extent messages transforms the complexity of detecting the end of window extents into the generation of punctuations. in contrast to hardwiring arrival order information or assumptions into the implementation  using punctuation to signal the ends of window extents is more flexible. the correctness of punctuations affects the accuracy of results  and the regular arrival of punctuations can reduce the delay in outputting results. delays in punctuation arrival delay results  and increase the state that the aggregate operator must keep  but do not affect the correctness of results. 
discussion: compared to existing techniques that retain and reprocess input tuples  wid reduces both buffer space and execution time  as our experimental results in section 1 attest. the main space savings come from never explicitly materializing window extents  but instead maintaining partial aggregates for multiple extents simultaneously-almost always a beneficial tradeoff. for example  if range is 1 minutes  and slide is 1 minutes  current window query evaluation algorithms would buffer one hour's worth of tuples; in contrast  wid needs to 
     seg-id  speed     ts        wid  t    s1        1     1:1  1    p   s1         *           *             1      
     seg-id   speed   ts  t    s1        1     1:1    p   s1         *      1:1    
figure 1: query plan for q1 
buffer only 1  = 1  aggregate values-one for each active window extent. secondary space savings come from avoiding any buffer space devoted to sorting out-of-order tuples. the tuples can be tagged and processed as they arrive. the only offsetting expense is sometimes retaining a few more aggregate values for incomplete window extents. the main time saving comes from handling each tuple once  and recording its contribution to all its window extents at that time  rather than revisiting it multiple times. 
one optimization possible with wid that we investigated is to pre-aggregate tuples on panes  sub-windows   and then use those pane aggregates to get full window aggregates . using panes with wid leads to further execution-time savings  due to computation sharing among consecutive windows. in addition  using panes to evaluate holistic aggregates  can reduce execution-time  which plain wid does not.  
1. fca windows: the wid approach 
recall that a fca window has a wids function that requires forward-context. in many implementations  the requirement of forward-context leads to buffering and delay of tuples. we propose an algorithm that uses window-id ranges to process several types of fca windows  including slide-by-tuple windows  in one pass. ours is the only algorithm we know of that can process fca windows  as well as fcf windows  without buffering and reprocessing tuples. 
we observe that we can further differentiate fca windows into fcb  forward-context bounded  and fcu  forward-context unbounded  windows based on whether we can bound the range of forward-context that the wids function requires. loosely  for fcb windows  when a tuple t arrives  we can determine the range of window-ids for the extents in which t participates  but not all the specific window-ids. for fcu windows  it is not possible to determine the range of window-ids for each input tuple as it arrives. 
we first present wid for slide-by-tuple windows  as they are the most commonly discussed fca windows. then we discuss wid for the two variations of slide-by-tuple windows  which slide by n tuples over row-num attribute and rank rattr   respectively. the latter is fcu.  

figure 1: example of insertion  initialization  and update of bins as new tuples arrive. 
1 slide-by-tuple windows 
in wid for fcf windows  the bucket operator tags each tuple with a range of window-ids and a window-agnostic aggregate operator computes the results. in wid for fca windows  the bucket operator also tags tuples with a window-id range; however this range has a different meaning and in fact the binding of window-ids to input tuples is deferred to the aggregate operator. with this design  we process each tuple only once and handle outof-order tuples the same as in-order tuples.  
the aggregate operator for slide-by-tuple windows requires a more sophisticated design as will be described below. we avoid retaining and re-processing tuples by maintaining partial aggregates for extents and by using these partial aggregates to initialize partial aggregates for new extents.  
1.1 example 
for fca windows  we know we cannot calculate a set of window-ids for a tuple t immediately upon t's arrival. recall that for slide-by-tuple windows and variations  we use rattr values as window-ids. careful examination of the wids function for such windows reveals that we can determine the range into which these window-ids will fall. for example  given the range of a slide-bytuple window  range  and a tuple t with t.rattr = s  the set of windows-ids to which t is mapped fall into the interval  t.rattr  t.rattr + range   and thus bucket can tag t with this range.  
we proceed to consider how the aggregate operator works. for each input tuple t with t.rattr = s  the first window extent that t belongs to is s: {u ¡Ê t | s - range   u.rattr ¡Ü s}  which ends with the arrival of t. we define an auxiliary extent for t  s + range: {u ¡Ê t | s   u.rattr ¡Ü s + range}  which is the earliest subsequent extent to which t does not contribute.  note that an auxiliary extent need not correspond to an actual tuple in 
t.  for ease of presentation  we denote the window extent s and the auxiliary extent s + range of tuple t as ss and es respectively  and refer to them as bins collectively. one can think of ss and es as the  start bin  and  end bin   respectively. we use b to refer to the wid for bin b  i.e.  ss = s and es = s + range. 
figure 1 shows the processing of a slide-by-tuple query where the aggregate is count  rattr is a  and range is i. we depict the bins as laid out in order of the a attribute  with a bin b associated with the position of its b. we mark the region to the right of the end of the bin  up to the end of the next bin with the partial aggregate value for the bin. for example  in figure 1 d   the partial aggregate for es1 is 1 and for ss1 is 1. the reason we label regions in this way is to indicate that any extent whose wid is in the region would have that contribution to its partial aggregate from tuples contributed to that bin. thus  an extent for wid s  where es1 ¡Ü s   ss1  would have a contribution of 1 to its count from tuples in figure 1 d . we consider the arrival of tuples t1 - t1  where si = ti.a. we start with an initial bin  init  with count = 1. the arrival of t1 adds bins ss1 and es1  figure 1 a    with initial values 1 and 1  respectively. tuple t1 with s1   s1 starts bins ss1 and es1  with ss1 set initially to the value of ss1 plus 1  and es1 initialized to es1  figure 1 b  . es1 is incremented by 1  to reflect the contribution of t1. figure 1 c  show the effect of t1  where s1   s1: ss1 and es1 are created and initialized  and es1 and es1 are incremented. figure 1 d  shows the need for e-bins: ss1 is initialized from es1  reflecting the contribution of t1 and t1  but with t1 out of the extent for ss1. finally  figure 1 e  shows the arrival of an out-of-order tuple t1  with s1   s1   s1. ss1 is initialized from ss1 and es1 from es1  with bins ss1  ss1 and es1 incremented. if at this point  punctuation arrives indicating future wattr-values are greater than s1  the operator can emit the aggregate values for ss1  ss1 and ss1  and discard ss1 and ss1 . 
figure 1 shows the general case for the arrival of tuple tn  when  ssn  esn  spans bins b1  b1  ...  bm. bins b1 and bm are  split  and used to initialize ssn and esn; every bin bi  1   i ¡Ü m is also updated. 
before
vivi+1bi tn.a+i
after
	b1	ssn	bi	bm	esn 
figure 1: bin updates for arrival of tuple tn. 
1.1 algorithm 
in this section  we present the algorithms used by the bucket and the aggregate operator in wid for slide-by-tuple window queries. 
the implementation of bucket is straightforward. for each tuple t  where t.rattr = s  it adds an attribute t.wid =  ss  es  giving the maximal range of window-ids for extents to which it belongs. it also transforms punctuations on rattr to punctuations on wid. 
figure 1 contains pseudo-code for the aggregate operator. the aggregate operator needs to store partial aggregates for bins that are not expired. initialize sets up the special  init  bin  labeled with -¡Þ. processtuple sets up new start and end bins for each arriving tuple  then updates appropriate bins. processpunctuation outputs results and purges appropriate bins.  
our wid implementation for slide-by-tuple windows does not retain and reprocess tuples; and it accommodates out-of-order tuples. for slide-by-tuple windows  we avoid reprocessing tuples at the cost of maintaining auxiliary extents  end bins . on the other hand  our approach does not need space to retain input tuples. therefore  our approach still compares favorably to the existing buffering approaches with regards to buffer space and execution-time performance. in addition  as wid maintains partial aggregates for active window extents incrementally  the latency of outputting results is kept low. 
1.1 variations  
this approach can be extended to variations of slide-by-tuple windows  again with no tuple needing to be retained and reprocessed  but at the cost of maintaining partial aggregates for additional extents. the bucket operator for these two variations is the same as the bucket for slide-by-tuple windows. we first discuss the variation that slides over the row-num attribute  which is a fcb window.  
for each tuple t with t.rattr = s  the processtuple function in the aggregate operator still maintains partial aggregates for two bins  ss and es; but it stores the t.row-num with the two partial aggregates 	for 	it  	e.g.  	 ss  	t.row-num  	pa . 	the processpunctuation function then only outputs the aggregates for the appropriate window extents. 
for the variation that slides over the tuple count of the logically ordered input stream over rattr  the processtuple function stores the current tuple count of t with the partial aggregates  e.g.  
state 
we maintain two collections  s and e  each storing pairs of the form  wid  pa  where pa is the partial aggregate for bin with window-id wid. s stores start bins and e stores end bins. 
initialize     
      /* aggr-init depends on the aggregate function; for example  aggr-init = 1 for count */ 
/* we use -¡Þ as the wid value of the init bin*/ 
    1.  add  -¡Þ  aggr-init  to e processtuple  t   
let t.wid =  ss  es   
1. add  ss  pa  to s  where  w  pa  ¡Ê s ¡È e has the  largest bin id w   ss
1. add  es  pa  to s  where  w  pa  ¡Ê s ¡È e has the  largest bin id w   es
/* the update operation depends on the aggregatefunction; for example  if aggregate-function = count  the update operation is +1 */ 
1. for each  w  pa  in s ¡È e where ss ¡Ü w   es update pa using t 
processpunctuation  p  
1. output each  w  pa  in s with w   p.wid and remove it from s 
1. remove each  w  pa  in e with w   p.wid and w ¡Ù -¡Þ figure 1: the aggregate operator implementation for slide-by-tuple window 

 ss  tup-cnt  pa . the stored tuple count is updated as each new tuple arrives. the processpunctuation function is the same as the function for windows that slide over tuple's row-num attribute. 
in summary  just as for slide-by-tuple windows  wid for these two variations processes each tuple only once  and handles disordered input; but it needs to maintain extra partial aggregates. in particular  for the second variation  since its wids function definition uses rank over rattr attribute  it potentially requires global information over the entire stream. using punctuations can unblock this  sort  requirement in an implementation. therefore  comparing the space and time performance of wid with the buffering approach  there is a tradeoff on internal space usage versus execution-time and output latency. for example  when a stream is slow and the slide is large  the buffering approach might outperform wid in terms of internal space usage. however  execution-time is normally a more critical requirement for stream applications. 
1. disorder 
out-of-order tuples can cause both accuracy and latency problems in window query evaluation. in this section  we first discuss sources of disorder; then we examine information that can be used to handle disorder and compare different ways of incorporating the information into an implementation. because of non-uniform disorder patterns and the different types of information needed to handle disorder  it is important that a disorder-handling mechanism be flexible  while retaining efficiency. 
1 source and nature of disorder 
there are various causes of disorder in data streams. two simple causes are merging unsynchronized streams and network delays. in addition  query processing-join processing in particular-may introduce disorder . further  stream data may appear disordered when a window is defined on an attribute other than the natural ordering attribute. for example  network flow records typically have a start time and an end time; records typically arrive in endtime order  but some network flow queries define windows on start time . finally  data prioritization can create significant disorder. for example raman et al.  and urhan and franklin  present methods for reordering data on the fly to give certain sets of tuples processing priority.  
to further understand the nature of disorder  we obtained network flow data from the abilene observatory  a consortium using a high-performance  internet1  network to study advanced internet applications . in networking terminology  a network flow is a connection between a source ip address and port and a destination ip address and port. a flow comprises one or more packets  which each have a timestamp and size  among other information . each flow has a start and end time  which are the min and max timestamps of packets in the flow.  
figure 1 shows a scatter plot of a sample of a stream of netflow records emitted by a router in the abilene network. each netflow record is associated with a network flow. the x-axis is the position of the packet in the stream  and the y-axis is networkflow start time. the graph shows an ascending set of disjoint blocks  with data points scattered apparently at random in each block. the reason for the surprising shape of this graph is that each minute the router outputs all its netflow records. at this point  it purges its cache of netflow records and starts over. thus a block represents the records emitted during a cache purge; the order within a block may be related to the structure of the router hash table. note that a flow that spans a block boundary is represented in two separate blocks as two separate netflow records.  
many stream systems handle disorder by assuming there is a fixed bound on disorder. however  from the disorder pattern shown in figure 1  it is clear that a fixed bound on disorder is not a good match to this pattern. setting the bound to less than a minute will drop many tuples; setting the bound to a minute will accommodate the disorder but unduly delay result output. what makes more sense is for the router to output a message-a punctuation perhaps-to indicate it has completed a cache purge. 
1 disorder handling: punctuation 
we leverage punctuation for flexibility in handling of disorder. order is important in detecting when all tuples participating in a window extent have arrived  and the result for that extent can be released. for example  if one assumes that data arrives in order  detecting the end of window extents can be done by inspecting tuple timestamps; one can assume that a window extent from 1-1 is complete when a tuple with a timestamp greater than 1 arrives. however  if only tuples from the same sensor are guaranteed to be in order  the situation is more complex. we need to see a tuple with timestamp greater than 1 from every sensor to know the extent is complete. another option  called slack  allows disorder within a specified bound. for example  the bsort operator of aurora  assumes that tuples will be out of order by no more than n positions and maintains a buffer of size n to reorder the input stream. bsort produces an ordered stream; any tuples that are more than n positions out of order are dropped.  
rather than develop different implementation techniques to handle different disorder patterns and policies  we localize the processing related to disorder into a single operator generating punctuation  and then use punctuation-aware  but disorderunaware  operators  elsewhere. the punctuating operator can incorporate the techniques we mentioned for dealing with order and disorder. it can use knowledge of stream order or sub-stream order as described in the example above to generate punctuation. the information that no tuple will be more than n tuples or s seconds out of order can be exploited to generate punctuation. a policy that no tuple more than s seconds late can be used by the punctuating operator to generate punctuation and filter tardy tuples. notifications from stream sources  such as the router from figure 1  can be converted into punctuation. the further advantage to dealing with disorder through punctuation is that we 

¡¡¡¡¡¡flow sequence number figure 1: block-sorted disorder 
can process tuples in arrival order  thus avoiding latency and space costs associated with approaches that buffer and reorder input. 
heartbeats are an alternative approach for handling disorder  proposed by srivastava and widom . heartbeats are in effect punctuations on timestamp. their paper proposes several methods for generating heartbeats; these methods could be incorporated into a punctuationg operator and are complementary to our work. 
1. performance study 
we tested the effectiveness and efficiency of wid by conducting two sets of experiments: 1  the first experiment compares the execution time performance for sliding windows using wid  and the buffering approach-the existing technique that materializes each window extent and computes the aggregate over it. 1  the second and third experiments compare the latency and accuracy of evaluating queries over streams with different disorder-patterns using wid with punctuations arising from the data source  i.e.  external punctuation   and slack implemented using punctuation. our experiments were conducted on an intel r  pentium r  1.1 mhz machine  running linux 1  with 1mb main memory. the data size for the experiments was approximately 1 mb. 
1 experimental data generation 
we implemented a data generator to produce tuples with increasing timestamps loosely based on the xmark data generator . the schema of the data is easily mapped to traffic-speed readings. the first experiment uses the data in generated order. the second set of experiments uses bounded-disorder and blocksorted-disorder data sets. to simulate the bounded-disorder distribution  we first took ten data sequences  each of them with bounded-disorder  resulting from applying a network analysis tool  over tcp header traces. to get a large data sequence  we concatenated randomly chosen copies of the ten data sequences. to simulate punctuations from the data source  we pre-processed the disordered data and inserted punctuations into the data. to simulate the block-sorted-disorder distribution  we divided the tuples into segments of equal length on the timestamp attribute  and then randomized the positions of tuples in each segment.   

figure 1  a : execution time: wid versus 
buffering - overview 
1 results 
we present the results of the three different experiments. the experiments used variations of q1  and varied the parameters according to table 1. in table 1  agg fcn stands for aggregate function  r for range and s for slide. 
table 1: experimental parameters 
exp
# agg fcn disorder slack size slack approach r s 1 max none 1  1 rows varies 1 avg bound varies consistent generous 1 s 1 s 1 cnt block-
sorted varies consistent 1 s 1 s  
execution time comparison of wid versus buffering: for 
experiment 1  we used the ordered data set and measured the execution time cost of using wid and the buffering approach. the measured time is in ms. for the window specification  we used wattr = row-num  range = 1 rows  and varied slide from 1 to 1 rows.  
experiment 1  figure 1 a  and  b   shows that wid in general has better time performance than the buffering approach  and the comparison favors wid as the ratio of range and slide increases. figure 1 b  is a zoomed-in version of figure 1  a ; scan cost is the measured time of scanning the whole data set.  
latency-accuracy tradeoffs for bounded-disorder: for 
experiment 1  we used the bounded-disorder data set and measured the latency-accuracy tradeoff of using punctuation and two types of slack : consistent and generous. the two types are similar  except that consistent slack requires that if a tuple is late and must be dropped from one window  it will be dropped from all windows it participates in  regardless if it is late for the other windows or not. generous slack makes no such restriction. average error percentage is the accuracy metric. for consistent and generous slack  we vary the amount of slack from 1 seconds through 1 seconds and we use range = 1 seconds  and slide = 1 seconds. 

figure 1  b : execution time: wid versus 
buffering - zoom-in 
our results  figure 1  show that as slack increases  error decreases and latency increases  as expected. it also shows that external punctuation has better latency and accuracy than either slack mechanism. in addition  generous slack has significantly better accuracy at comparable latency when compared to consistent slack. 
latency-accuracy 	tradeoffs 	for 	block-sorted-disorder: 
experiment 1 is similar to experiment 1  except that we used block-sorted disorder  shown in figure 1   with block duration 1 seconds. we varied the amount of slack from 1 to 1 seconds and used range = 1 seconds and slide = 1 seconds. the percentage of incorrect answers is the accuracy metric for figure 1. in contrast to experiment 1  where error decreases and accuracy increases as slack increases  for blocksorted disorder there is no linear relationship between slack and latency. for the block-sorted-disorder data set there is one slack value that has the best latency  at the optimal accuracy  as shown in figure 1  which is determined by the relationship between block size and window size. in our experiment  the optimal slack is 1 seconds. when slack is less than optimal  latency is 

figure 1: latency vs. accuracy band-disorder 
 average error percentage  

figure 1: latency vs. accuracy block-sorteddisorder  percentage of incorrect answer  
essentially independent of slack. as slack increases above the optimal  latency jumps dramatically. in this case  it would be difficult to use slack to tune the latency and accuracy of the query  as one might hope to do. it also shows that external punctuation has better latency and accuracy for block-sorted disorder than any slack amount used. 
1. conclusion and discussion 
we believe that the work here makes three important contributions to the field of data-stream processing: 1  a framework for defining window semantics independent of any particular operator implementation algorithm; 1  a one-pass query evaluation technique for many types of sliding-window aggregates  which generally reduces memory space usage and is very flexible in handling disorder; 1  an initial investigation on the source and nature of naturally occurring disorder in data streams  and its effects on stream system performance with different disorder-handling strategies.  
we believe that both our framework for window semantics and query-evaluation approach are scalable and flexible enough to be extended beyond window aggregates. in the future  we plan to apply them on window join and multi-query window aggregates. 
1. acknowledgements 
we thank ted johnson for information on sources of disorder  abilene for giving us access to their data  and our reviewers for insightful comments. this work was supported by nsf grant iis 1. 
