between two schemas. in general  the well-known 1 rule ap- motivated by the observations above  we have built muse  a data plies for mapping generation tools. they can automate 1% of the example driven mapping design tool currently implemented on top work  covering common cases and creating a mapping that is close of clio . muse can differentiate between alternative mapping to correct. however  ensuring complete correctness can still require specifications and infer the desired mapping semantics based on intricate manual work to perfect portions of the mapping. the designer's actions on a short sequence of simple data examples.
　previous research on mapping understanding and refinement and summary of demonstration features. we demonstrate muse-g  anecdotal evidence from mapping designers suggest that the map- the component of muse which helps a designer derive the desired ping design process can be perfected by using data examples to grouping semantics for a mapping specification using examples. explain the mapping and alternative mappings. we demonstrate for instance  through examples  muse-g can infer whether the demuse  a data example driven mapping design tool currently imple- signer intends to group projects by a company's name and location mented on top of the clio schema mapping system. muse leverages or only by a company's name. grouping or combining related data data examples that are familiar to a designer to illustrate nuances of together is an essential functionality of many integration systems. how a small change to a mapping specification changes its seman- however  tools such as  1  1  1  define a default grouping function tics. we demonstrate how muse can differentiate between alterna- for every target nested set in a mapping  which can only be manutive mapping specifications and infer the desired mapping seman- ally modified. this can prove to be a difficult task  if the schemas or tics based on the designer's actions on a short sequence of simple the number of possible arguments for a grouping function are large. data examples. indeed  if there aren n possible attributes to group by  then there are
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　1 choices of grouping functions. furthermore  it may not be obcategories and subject descriptors: vious to a designer  what the n possible grouping attributes are  1  h.1  logical design : schema and subschema  d.1  design 1 . to illustrate this point  our demo will take users through extools and techniques   h.1  heterogeneous databases  ample mapping scenarios  and give them an opportunity to deduce general terms: design  algorithms  languages the possible grouping attributes themselves. we will demonstrate
keywords: schema mappings  data exchange  data translation  data that this is not always an easy cognitive task. we demonstrate how examples  design  refinement muse-g infers the desired grouping semantics through the actions taken by the designer on a short sequence of simple data exam1. introduction ples. we also demonstrate how muse-g exploits source schemaconstraints  keys and functional dependencies in general   when
　schema mappings  or mappings in short  are logical assertions available  to reduce the number of examples presented to a dethat specify the relationships between a source and a target schema signer. the interactive nature of the demonstration will allow us in a declarative way. the specification of such mappings is a fun- to show how the examples illustrate design alternatives in a much damental problem in information integration. existing mapping more natural way than having the designer deduce the proper sesystems such as clio   heptox   and ibm's rational data mantics and edit the mapping specification directly. in addition  architect   can  semi- automatically generate mappings from a we demonstrate how muse-g supports the incremental design of a visual specification between two schemas. in general  the well- grouping function without restarting the process from scratch. known 1 rule applies for mapping generation tools. they can we also demonstrate muse-d  the component of muse which automate 1% of the work  covering common cases and creating a helps a designer choose among alternative interpretations of an ammapping that is close to correct. however  ensuring complete cor- biguous mapping. intuitively  a mapping is ambiguous if it specirectness can still require intricate manual work to perfect portions fies  in more than one way  how an atomic target schema element is of the mapping. to be obtained. for example  a schema mapping could be ambiguous because it asserts that a project supervisor is a project man-
copyright is held by the author/owner s .	ager or a project tech-lead at the same time. we demonstrate how sigmod'1  june 1  1  vancouver  bc  canada.	muse-d can help a mapping designer understand and differentiate
acm 1-1-1/1.
　
compdb: rcd
companies: set of
company: rcdorgdb: rcd
orgs: set of
org: rcdm: 
for c in compdb.companies exists o in orgdb.orgs	oname	where c.cname=o.oname  
projects: set of	o.projects=skproj c.cid  c.cname  c.location   project: rcd	for p in compdb.projects   
supervisor satisfying p.cid=c.cid  e.eid=p.manager contact exists p1 in o.projects where p.pname=p1.pname  
e.ename=p1.supervisor  
e.email =p1.contact
figure 1: an example relational-to-xml schema mapping.
among all interpretations of an ambiguous mapping through a single small data example of the source. the designer is presented with a partial target instance derived from the source data example and asked to select among a small set of data choices. we show how the designer's actions on these choices translate into a unique interpretation of the ambiguous mapping.
　finally  we demonstrate how muse leverages the designer's familiarity with the actual source instance by attempting to extract  real  examples from the source instance first. sometimes  the actual source instance is insufficient to illustrate all design alternatives. when this happens  muse  falls back  to its own synthetically constructed example. moreover  we show how the visual interface of muse is able to highlight  related  source and target tuples in a data example  thus facilitating the designer's understanding of the mapping even further through these relationships.
　after testing our system on several real life scenarios  we have found that it scales well with the complexity of the mappings. on the average  muse takes less than a second to obtain the example instances that are presented to the mapping designer at each step. for a thorough experimental evaluation of muse  we refer the interested reader to .
technical contribution. our main technical contribution is an implementation of a mapping designer with the above mentioned features. to the best of our knowledge  muse is the first data example driven mapping design tool that implements these functionalities. while our work is largely inspired by yan et al.   we go significantly beyond the techniques and space of alternative mappings supported by . our work is complementary to the work of  which allows a designer to understand and debug schema mappings by showing the relationships  called routes  between source or target data. in their system  the mapping designer is not guided with examples in creating or refining a schema mapping  but instead must manually change the mapping  once a problem has been identified by analyzing the routes. we refer the interested reader to  for complete discussion of related work.
　although we have built muse on top of clio  our techniques are independent of clio and can be deployed with any mapping system based on a similar mapping formalism. furthermore  muse works for any combination of relational and xml source and target schemas.
1. demonstration overview
　we illustrate the main features of muse through an example mapping kept simple  for ease of exposition. we emphasize that in general  real life mappings are much more complex than our illustrative example  and thus harder to perfect. we will use a more complex schema mapping in our actual system demonstration.
our schema mapping example. we use the nested relational model and nested mapping language of  for describing our mapping  see figure 1 . nested mappings generalize the mapping language of  which is equivalent to source-to-target  s-t  tuple generating dependencies or global-local-as-view  glav assertions and widely used in research on data exchange and integration between relational schemas.
　figure 1 shows a mapping scenario between a relational source schema compdb and a nested target schema orgdb.  ignore the dashed referential constraint f1 for now.  such a mapping scenario is interpreted by a mapping-generation tool such as clio  1  1  into a set of s-t constraints that declaratively specify the relationship between the two schemas. the mapping m in figure 1 is an example of one of the constraints generated. the outer part of m asserts that for every company tuple c  refer to the first for clause of m  there must exist an org tuple o in the target  the first exists clause of m  with the value for oname extracted from c.cname  first where clause of m . furthermore  the value of o.projects is the setid  also called grouping function or skolem function  skproj c.cid  c.cname  c.location . the inner part of m asserts that for every project tuple p and employee tuple e that together with the company tuple c satisfy the referential constraints f1 and f1  there must exist a project tuple p1 within the set o.projects with the corresponding values for pname  supervisor and contact.
　according to   the default setid or grouping function for projects in m is skproj c.cid  c.cname  c.location  or skproj cid  cname  location   when c is understood from the context. in other words  project records are grouped according to the values of all attributes of the company record. to illustrate  consider the following source and target instances satisfying the specification given by m.
source instance:
companies:
　1 ibm   almaden
　1 ibm   watsonprojects:
dbsearch 1   e1   e1
　websearch 1  e1   e1 employees:target instance: orgs:
ibm 
projects: skproj 1  ibm  almaden 
	dbsearch	anna   anna ibm
ibm 
projects: skproj 1  ibm  watson 
	websearch	anna   anna ibme1   anna    anna ibm
　the two project records in the target appear in distinct groups identified by setids skproj 1  ibm  almaden  and skproj 1  ibm  watson   respectively. if skproj cname  is the grouping function instead  then project records are grouped according to cname of company records. hence  the two project records would appear together under the same projects record identified by skproj ibm .
1 muse-g: designing grouping functions
　we demonstrate the muse-g wizard which infers a grouping function that has the same grouping semantics as the actual grouping function that the designer has in mind  through a sequence of  questions  posed to the designer. here  we only demonstrate how muse-g designs the grouping function skproj of projects. the algorithm behind muse-g is described in detail in . intuitively  muse-g examines every attribute in the set {cid cname location} of all possible arguments for skproj. with each attribute  a small example source instance ie is constructed  from which two differentiating target instances are obtained: one is the result of including the attribute as part of skproj in m  and the other omits it.
　for example  suppose cid is examined first. muse-g will construct an example source instance ie shown on top of figure 1 and show two different target instances  scenarios 1 and 1 in figure 1  that are obtained by executing mappings m1 and respectively  m1 on ie. here  m1 and m1 are identical to m except that m1 groups projects by cid  i.e.  skproj cid   and m1 groups all projects together  regardless of cid cname  and location values  i.e.  skproj   . next  muse-g asks the designer whether scenario 1 or 1 looks correct. assuming that the designer has the grouping function skproj cid  in mind  she would select scenario 1 in figure 1.

figure 1: screenshot of muse-g  where x  {ibm  almaden}.
then  muse-g repeats a similar process with the next attributes cname and location to determine whether cname and location are part of the grouping function skproj.
　now we examine in more detail what happens when muse-g examines each attribute in the set {cid cname location}. at each step  the goal is to carefully construct a small example source instance ie  from which two differentiating target instances are obtained: one is the result of including the probed attribute under examination as part of skprojs in m  and the other omits it.
　suppose we examine cid first. muse-g first constructs its own example synthetic instance isynth  as shown below.
isynth:{company c1 n1 l1   project p1 c1 e1 t1  
employee e1 en1 cn1  
company c1 n1 l1   project p1 c1 e1 t1  
employee e1 en1 cn1 }
　observe that each relation in isynth has two tuples. furthermore  every attribute value of every tuple is distinct  except for cname and location values of company tuples. the reason for this is so that the target instances generated by m with skproj cid y   where y   {cname location}  versus m with skproj y  will be non-isomorphic. indeed  the former target instance will contain two distinct project sets  while the latter consists of only one project set. next  muse-g executes the following query against the actual source instance i in order to retrieve real tuples for the example instance ie.
qie: company c1 n1 l1  … company c1 n1 l1 …
project p1 c1 e1 t1  … project p1 c1 e1 t1 … employee e1 en1 cn1  … employee
　all variables of qie are universally-quantified. the two company tuples must disagree on cid  the probed attribute  and agree on cname and location as explained earlier.
　if qie i  returns an empty result  muse-g will present the designer with the synthetic instance isynth  shown earlier. alterna-

figure 1: screenshot of muse-d.
tively  a  semi-real  ie may also be constructed by putting together various real values drawn from i. however  this may lead to combinations that are misleading to the designer. if qie i  returns a non-empty result  muse-g constructs a real example based on the returned values. a possible real example constructed in this way is shown at the top of figure 1  where each tuple in companies  projects and employees exists in i.
　next  muse-g obtains two differentiating target instances shown in scenarios 1 and 1 in figure 1  starting from ie with mappings m1 and respectively  m1. here  m1 and m1 are identical to m except they have skprojs cid  and respectively  skprojs   as grouping functions for projects. now  muse-g asks the designer  which target instance looks correct  
　note that the instance ie has been carefully crafted so that the result of applying m1 on ie is isomorphic to the result of applying
  where is a mapping obtained from m by replacing skprojs with skprojs {cid}“y    where y  {cname location}. since cname and location values are identical for the two company tuples in ie  the mapping m1 has the same effect as. similarly  m1 has the same effect as  where is obtained from m1 by replacing skprojs with skprojs y  . hence  based on the designer's choice of scenario 1 or 1  muse-g correctly determines whether cid is part of the designer's desired grouping function. so with one question  we either eliminate all mappings using cid  not only skprojs cid   but skprojs cid cname   skprojs cid location   and skprojs cid cname location    or we eliminate all mappings that do not use cid in the skolem function for projects.
exploiting source schema constraints. we also demonstrate how muse-g exploits source constraints such as keys  or functional dependencies in general  to reduce the number of examples shown to the designer. for example  if cid is the key for companies  then for all source instances that satisfy the key  we know that a potentially rewarding sequence of attributes to examine would be cid first  followed by either cname or location. if the designer chooses scenario 1  then muse-g can immediately conclude skproj cid  without examining the rest of the attributes. as we show in   grouping with skproj cid  is the same as grouping with skproj cid y   where y {cname location}. consequently  there is no need to examine the attributes cname and location  thereby reducing the number of examples shown to the designer by two.
incremental design. we also demonstrate how grouping functions can be designed incrementally. this feature is useful for allowing a designer to return to refine her design at a later time. we show how an existing grouping function  e.g.  skproj  may be refined without restarting muse-g from scratch  by choosing to  group more   i.e.  merge multiple groups into a bigger group  or  group less   i.e.  split a group into multiple smaller groups  on skproj.
1 muse-d: disambiguating mappings
　we demonstrate how muse-d can be used to select among multiple interpretations of an ambiguous mapping through examples. consider the additional referential constraint f1 in figure 1. note that there are now two referential constraints from project to employee. this new mapping scenario can be interpreted in several ways  four of which are condensed into the mapping ma shown below.
ma:  for c in compdb.companies
exists o in orgdb.orgs
where c.cname=o.oname  o.projects=skproj c.cid  c.cname  c.location   
for p in compdb.projects   
e1 in compdb.employees   e1 in compdb.employees
satisfying p.cid=c.cid  e1.eid=p.manager   e1.eid=p.techlead
exists p1 in o.projects where p.pname=p1.pname  
 e1.ename=p1.supervisor or e1.ename=p1.supervisor  
 e1.email =p1.contact or e1.email =p1.contact 
　the mapping ma is ambiguous: it contains or predicates to illustrate alternative interpretations. the non-bold parts are common to all four interpretations and each of the bold conjuncts represents two alternative ways of associating a supervisor  and email  respectively  with a project.pname. for example  the first set of or conditions specifies that one can extract either the manager's name or the tech-lead's name as the supervisor of a project.
　to disambiguate the four interpretations of ma  muse-d constructs a single small example source instance ie shown in figure 1 with the property that four pairwise distinct target instances can be generated  one from each interpretation of ma. the designer's selection of one of these target instances is thus a selection of one of the interpretations of ma. in our system  muse-d does not display all four distinct target instances. instead  it compactly represents them in one  instance  by factoring common parts and displaying the alternatives for each ambiguous schema element according to ma  see the target instance in figure 1 . if the designer picks the values anna for supervisor and jon ibm for contact  it means that the desired mapping is one that uses  e1.ename = p1.supervisor  and  e1.email = p1.contact  in the where clause of ma.
　next  we briefly illustrate the way muse-d constructs a differentiating example source instance. muse-d first constructs a synthetic example isynth which consists of a company tuple  c1 cn1 l1   a project tuple  p1 c1 e1 e1  and two employee tuples  e1 en1 cn1  and  e1 en1 cn1   corresponding to the manager and respectively  the technical leader of the project p1. the query below is executed to replace isynth with ie  which consists of real tuples from an existing source instance i:
qie :company c1 cn1 l1  … project p1 c1 e1 e1 …
employee	employee e1 en1 cn1 … en1 = en1 … cn1 = cn1
　all variables of qie are universally quantified. since supervisor and contact are ambiguous elements according to ma  we add the inequalities  and to ensure that one can disambiguate mappings according to the designer's selection on these values. a possible real example constructed from qie i  is shown in figure 1. if qie i  returns an empty result  then the synthetic instance isynth shown above would be presented to the designer instead.
　finally  muse-d applies ma on ie to generate the target instance with  choices  shown also in figure 1. intuitively  the non-choice part of the target instance is generated by applying the non-ambiguous part of ma on ie. the choices for an atomic target element are obtained by taking the union of values extracted from each alternative. after this  the designer  fills-in-the-choices  in the target instance. the completed target instance translates into an underlying mapping that ma encodes.
1 constructing and visualizing examples
　we demonstrate how muse extracts  whenever possible  example instances from a real source instance provided by the designer  falling back to  artificial  examples only if a real example is not found. the example instances are obtained by executing appropriate sql/xquery queries on the real source instance. furthermore  the time that the designer has to wait for a real example from muse is minimized as much as possible: muse exploits the  think  time of the designer on the current example  to precompute other examples ahead of time in the background.
　we also demonstrate how the visual interface facilitates the designer's understanding of nuances in the mappings even further  by automatically highlighting how source and target data values are related via mappings in an example. consider the example shown in figure 1. when the designer selects the project tuple under skproj 1 x  in scenario 1  i.e.  the dbsearch tuple   the source tuples that are related to the dbsearch tuple by the underlying mapping are highlighted. in addition  the dbsearch tuple is also highlighted in scenario 1  under skproj x   because the same source tuples contribute to it. however  the dbsearch tuple is not in the same group as the websearch tuple in scenario 1  but they are in the same group in scenario 1. the highlighting thus illustrates the difference in the semantics of m with grouping functions skproj cid y  and respectively  skproj y . similarly  in figure 1 the values currently picked by the designer in the target instance are automatically highlighted by muse in the example source instance  indicating where the values are extracted from.
1. system architecture
　muse is implemented in java 1 on top of the clio system. clio presents the designer with a list of ambiguous mappings  if any  and muse-d is used in disambiguating them. once a mapping is disambiguated  muse-g is employed in designing its grouping functions.
1. conclusion
　we have described the functionalities we demonstrate for muse  a mapping design wizard that uses data examples to help designers understand  design  and refine schema mappings. muse permits a designer to work with data rather than with complex specifications to understand a mapping's semantics. muse works on two important components of a mapping specification  corresponding to the design of desired grouping semantics for mappings  muse-g  and the desired interpretation of ambiguous mappings  muse-d .
acknowledgements. alexe  chiticariu  pepper  and tan are supported by nsf career award iis-1 and nsf grant iis-1. work partially done while tan was visiting the ibm almaden research center.
