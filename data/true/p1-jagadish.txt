peer-to-peer systems have recently become a popular means to share resources. effective search is a critical requirement in such systems  and a number of distributed search structures have been proposed in the literature. most of these structures provide  log time search  capability  where the logarithm is taken base 1. that is  in a system with n nodes  the cost of the search is o log1n .
in database systems  the importance of large fanout index structures has been well recognized. in p1p search too  the cost could be reduced considerably if this logarithm were taken to a larger base. in this paper  we propose a multiway tree search structure  which reduces the cost of search to o logmn   where m is the fanout. the penalty paid is a larger update cost  but we show how to keep this penalty to be no worse than linear in m. we experimentally explore this tradeoff between search and update cost as a function of m  and suggest how to find a good trade-off point. the multi-way tree structure we propose  baton*  is derived from the baton structure that has recently been suggested. in addition to multi-way fanout  baton* also adds support for multi-attribute queries to baton.
1. introduction
　peer-to-peer  p1p  systems have become very popular of late  and are widely used for sharing resources  such as music files. search is a crucial operation in p1p systems  and there has been considerable recent work in devising effective

 supported in part by the us national science foundation grant iis-1
 supported in part by ida ccc grant as part of best-
peer project
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1  june 1  1  chicago  illinois  usa.
copyright 1 acm 1-1/1 ...$1.
distributed search techniques. the proposed structures include a ring as in chord   a multiple dimensional grid as in can   a multiple list as in skipgraph   or a tree as in baton . most search structures  including all the ones just mentioned  bound the cost of the search to a logarithm of the search space: for a system with n nodes  the search cost is bounded at o logn . however  upon closer examination we see that this logarithm is to base 1. if we could take the logarithm to a larger base  we could have a substantially smaller cost.
　the importance of having a large base for the logarithm has been well-recognized in centralized database systems. when tree structures are constructed for indexing  the fanout is made as large as possible  within the limits of the page size. we always use b-trees in database systems  and not binary trees! an equivalent transformation  from the low fanout structures currently proposed in the literature  to practical high fanout distributed search structures  is the topic of this paper.
　at first glance  one may think that it is not too hard to increase the fanout in any distributed search structure. for instance  consider chord. rather than doubling successive ranges  we can increase them by a factor of m; correspondingly  in the finger table we would have m 1 entries at each level  instead of just one entry. with this simple change  the search cost  in number of hops required  has gone down by a factor of log1m. the storage requirement  for the finger tables  has increased by a factor of m/log1m  but the amount of storage for finger tables is usually not large enough that this matters. so we appear to have won. the difficulty is that the update cost has gone up by a factor of  m/log1m 1. this quadratic dependence on m makes it difficult to increase m very much. we seek a better solution  preferably one in which the cost for updates increases no worse than linearly with m.
　the only existing distributed index that is notable in permitting high fanout is the p-tree . in this proposal  each p1p node maintains a leaf node in the b+-tree and a path of virtual index nodes from the root to that leaf node. search is very effective  but updates are expensive  possibly requiring substantial synchronization effort. in other words  this technique too has the same weak spot as multi-way chord discussed above.
　in this paper  we propose a new multi-way distributed tree structure. we call it baton*  since it is an extension of baton  just as r*-trees are an extension of r-trees. baton* extends baton to permit a fanout of m   1. with this  the cost of search becomes o logmn   as expected. moreover  the cost of updating routing tables is just o m ， logmn   as compared to o log1n  in baton - a degradation that is better than linear in m  and therefore a cost one may be willing to pay. furthermore  baton* has better fault tolerance properties than baton  and is capable of quicker load balancing. in fact  the system's fault tolerance  measured as the number of nodes that must fail before the network is partitioned  increases linearly with m. similarly  the expected cost of load balancing decreases linearly with m. we analyze the impact of m on both search and maintenance cost  and derive an estimation model for m that reduces the total cost given some composition of queries and updates. likewise  we analyze the impact of m on fault tolerance of baton*.
　baton* can also support queries over multiple attributes in an effective way. in addition to permitting the use of multiple attributes in a single index  baton* further introduces the notion of attribute classification  based on importance of the attribute for querying  and the notion of attribute groups. another variation of baton  has been proposed for supporting multi-dimensional queries. however  as analyzed in section 1  it cannot support multiattribute queries efficiently. realizing that most of the time users only query over a small number of attributes while others are rarely queried  we propose a flexible method of indexing attributes in which only attributes  which are frequently queried  should be indexed separately; other attributes can be divided into small groups  and these groups are indexed as in multi-dimensional space.
　to sum up  in this paper  we have the following major contributions:
  in section 1  we introduce baton*  a significant extension of baton to multi-way tree structure. therefore  we can reduce the cost for search from o log1n  to o logmn .
  we analyze baton*'s resilience towards node failure and network partitioning and its capability of load balancing.
  using baton*  we present a flexible method to support multi-attribute queries efficiently in section 1.   in section 1  we show the experimental results of our proposed system over planetlab   a testbed for largescale distributed systems.
　in addition to the main sections mentioned above  this paper includes necessary background information about baton in section 1; in section 1  there is a description of how chord can be extended to have a fanout of m; we present related work in section 1 and conclude in section 1.
1. background
　since our proposed multi-way structure is adapted from baton  balanced tree overlay network    we present here a brief review of the relevant features of baton.
　baton is an overlay structure based on the binary balanced tree in which each peer in the network maintains a

figure 1: baton structure
node of the tree. a node may connect to other nodes by up to four different kinds of links: parent links pointing to parent nodes  children links pointing to child nodes  adjacent links pointing to adjacent  in linear order  nodes that maintain adjacent ranges of values  and neighbor links pointing to selected neighbor nodes at the same level and have a distance equal to a power of two from the node. in baton  each node in the tree  both leaf and internal  is assigned a range of values in which the range of values directly managed by a node is required to be greater than the range of values managed by its left adjacent node while smaller than the range of values managed by its right adjacent node. in other words  if we travel from the left to the right of the tree following adjacent links  data is in increasing order. an example of baton is shown in figure 1.
　in baton  a tree is considered balanced if and only if at any node in the tree  the height of its two subtrees differ by at most one. there are two important results in baton. the first result shows that a tree is balanced if every node in the tree that has a child also has both its left and right routing tables full  i.e.  none of the valid links in the routing table is null. the second result shows that if a node x contains a link to another node y in its left or right routing tables  the parent node of x must also contain a link to the parent node of y unless the same node is parent of both x and y. this result gives an efficient way to forward requests among nodes in the network.
　based on these two key results  baton keeps the tree structure balanced by forcing every node in the tree that has a child to have both its left and right routing tables full. therefore  when a node receives a join request from a new node  it can only accept the new node as its child if its routing tables are full and it does not have two children. otherwise  the join request is forwarded to either  a  its parent if at least one of its routing tables is not full or  b  one of its adjacent nodes if it has both routing tables and children full. in case of node departure  if the departure of a node does not affect the tree balance  the node can safely leave the network. this is the case where the departing node is a leaf node and all of its neighbor nodes have no children. otherwise  the departing node has to find a replacement node  which is a node satisfying the previous case  to take its place. the replacement node is found by sending a findreplacement request downward the tree. here  the cost of finding a position for a new node and the cost of finding a replacement node in case of node departure are all o logn  while the costs of updating routing tables to reflect changes are 1，logn and 1，logn for node join and node departure respectively.
　in baton  when a node receives a query request  if the searched value does not fall into its own range of values  the request is always forwarded to a node in its left routing table whose upper bound is still greater than the searched value or a node in its right routing table whose lower bound is still lower than the searched value if such a node exists. otherwise  the query request is forwarded to either its left child/right child or its left adjacent/right adjacent node. note that a query request can only be forwarded to a higher level node in two cases:  1  the higher level node contains the searched value  and hence it is necessary   1  the processing node is a lower level leaf node without children and there are insufficient neighbor nodes inside its routing tables  in this case it is far from the root . as a result  baton can avoid a bottleneck at the root and nodes near it.
　two load balancing schemes are used in baton. in the first scheme  an overloaded/underloaded node performs load balancing with its adjacent nodes. in the second scheme  an overloaded/underloaded leaf node performs load balancing with a far away leaf node  a lightly loaded node may forcibly leave its current position and force-join as a child of the overloaded node to share the workload . the tree structure may become unbalanced in this case  and network restructuring becomes necessary. in baton  network restructuring operations are akin to rotations in an avl tree. load balancing is performed by shifting nodes via adjacent links towards the place causing imbalance.
1. baton*: a multi-way tree structure

figure 1: average additional messages required for doing load balancing
　baton creates a binary search tree structure. as we attempt to increase the fanout  we find some challenges that must be overcome:
  in baton  all nodes  whether leaf or internal  are responsible for a range of data values. there is an  inorder  traversal linearization of these value ranges. if a node has more than two children  this sort of in-order linearization is no longer possible. this implies that we no longer have a clean definition of adjacency of value range for internal nodes  and it is not clear what adjacent links should be kept. even if we choose to be generous and maintain multiple adjacencies  one has to be chosen when needed for search traversal and for load balancing. this choice is not clear when there are multiple adjacent nodes.
for example  if an internal node is overloaded by just one range of values  it also can only do load balancing with two of its adjacent nodes  not with all 1 ，  m   1  adjacent nodes . all the above things bring back the problem of propagating load balancing operations when a node is overloaded  which is avoided in baton. figure 1 shows a comparison between our proposal and this method in doing load balancing. the result shows that this naive method is very bad in solving load balancing problem.
  it appears straightforward to expand the neighbor routing tables to capture neighbors at distances that are powers of m distant rather than powers of 1 distant. this turns out to be the wrong answer since it leaves the search network under-connected.
1 the baton* structure
　in this section  we propose a new structure called baton*  which addresses the challenges listed above in extending baton to a multi-way structure. the new structure is shown in figure 1. there are three significant differences between the multi-way baton* and the binary baton.
  each peer node in baton* can have up to m children instead of two as in the original structure. in addition to maintaining links to children  the parent node also has to keep track of the ranges of values managed by their children.
  neighbor routing tables at a node maintain links to selected neighbor nodes at the same level which have a distance equal to d ， mi  where d = 1..m   1 and i − 1  from the node itself. as shown in figure 1  left routing table of node o maintains links to nodes n  m  l  k  g  which have a distance from node o respectively 1 ， 1 ， 1 ， 1 ， 1  and 1 ， 1. similarly  the right routing table of node o maintains links to nodes p  q  r  s. as a result  the maximum number of links in routing tables of a node at level l is bounded at  m   1  ， logm number of nodes at that level =  m 1 ，l. note that if we increase the fanout of a node to reduce the cost of search  we have to increase the size of routing tables  and hence increase the cost of update tables. consequently  depending on application requirements  an appropriate value of fanout factor m should be chosen. we will show later how to select such an m.
  for a system of order m  a range of values managed by a node is greater than ranges of values managed by the first children nodes while less than ranges of values managed by the last children nodes. for example  in figure 1  range of values managed by o is greater than those of y  x  n  but smaller than those of z  d  p  q.

figure 1: baton* structure　note that in baton*  a node manages only a range of values and m links instead of  m-1  ranges of values and m links as in the original multi-way tree structure. it also does not look like a b-tree  where every internal node must have a number of children between m/1 and m. rather  in baton*  all internal nodes  except immediate parents of leaf nodes  are required to have full m children. immediate parents of leaf nodes may have fewer children  and this is where growth takes place.
1 definition and theorems
　for an m-fanout tree  with m   1  the definition of a binary balanced tree is extended naturally to the form:
　definition 1: a tree is balanced if and only if at any node in the tree  the height of any two subtrees of its children differ by at most one.	
　the two crucial results underpinning baton continue to apply to baton*  with suitable extension in wording from 1 to m  in spite of all the changes described above. we establish these extended results next.
　theorem 1: a tree is a balanced tree if every node in the tree that has a child also has both its left and right routing tables full.
　proof: assume that there exists a subtree rooted at node x  which is imbalanced. as a result  there must exist two subtrees rooted at y and z  children of x  whose heights differ by more than 1. let ny and nz be numbers of y and z  hy and hz be heights of their corresponding subtrees. without loss of generality suppose that z is a right sibling of y  and hy   1   hz. also let w be the farthest leaf node of the subtree rooted at y  v be its parent  and nv be number of v. since z is a right sibling of y  we have nz = ny + t  where  1 ＋ t   m   1 . by the way nodes are numbered  we have  ny   1  ， mhy 1 + 1 ＋ nv ＋ ny ， mhy 1  1 .
since v has a child w  by the system requirement  it has to have a full right routing table in which there must be a node u with number nu = nv + d ， mi  where 1 ＋ d ＋ m
 1  we have nu = v	 1 . from  1  and  1  
we have  
   ny+t 1 ，mhy 1 ＋ nu ＋  ny+t ，mhy 1  1 . from  1  and  1   we have  nz 1 ，mhy 1 ＋ nu ＋ nz，mhy 1.
as a result  nu has to belong to a descendant node at height hy   1 of the subtree rooted at z. it means that the height of the subtree rooted at z is at least hy   1. since this contradicts the assumption  there does not exist a subtree that is unbalanced. the proof is illustrated in figure 1.  theorem 1: if a node x contains a link to another node y in its left or right routing tables  the parent node of x must also contain a link to the parent node of y unless the same node is parent of both x and y.
　proof: let y be a neighbor node of x  w be the parent of x  v be the parent of y  and nx  ny  nw  nv be the number of x  y  w  v respectively. by the way nodes are numbered  we have nw = nx div m and nv = ny div m. by the way neighbor links are established  we have ny = nx＼d，mi. let

figure 1: proof of theorem 1
us consider two cases. case 1: if i = 1  then ny = nx ＼ d. as a result  n n ＼ d div m d m 1 
nw  1 ＋ nv	 	，	，	.
consequently  v has to be a neighbor of w or be w itself. case 1: if i − 1  nv =  nx ＼ d ， mi  div m = nw ＼ d ， mj  where j = i   1. as a result  v has to be a neighbor of w.
　in addition to the above theorems  we establish two new theorems as below.
　theorem 1: the total number of nodes at level l is  m - 1  times greater than the total number of nodes at all previous levels  1 through l   1.
　proof: let x be the total number of nodes at level l  and y be the total number of nodes at all previous levels  then x = ml  and y = 1+m1+m1+...+ml 1 =  ml 1 / m 1 .
as a result  y ，  m   1  = ml   1   x.	
　this theorem implies that the vast majority of nodes in the system have a high level number  and are possibly leaf nodes. this dominance of leaf nodes will turn out to be crucial for lowering the cost of load balancing as we shall see shortly.
　theorem 1:the maximum size of a routing table of a node at level l is m ， l.
　proof: this theorem follows from the way we construct routing tables. since there are total ml nodes at level l  and a node maintains neighbor nodes at distance d ， mi  where d = 1..m   1  the maximum size of a routing table is d ， logmml = d ， l.	
　corollary 1:the maximum size of a routing table of a node in the network is m ， logmn.
　proof: it is trivial since the maximum height of the tree is logmn.	
　this corollary provides us with the tools necessary for efficient update. if we can restrict the cost of an update to be that of the construction of a single neighbor routing table  then we have the necessary sub-quadratic dependence. algorithms for various operations are adapted from baton to baton* as described next.
1 node join and node departure

algorithm 1 : join  node n  node newnode 

if  full leftroutingtable n   and
full rightroutingtable n   and not full children n   
n.acceptchild newnode  if  adjacent newnode  = n  splitdata n  newnode 
else
splitdata adjacentsibling newnode   newnode 
else
if   not full leftroutingtable n    or
  not full rightroutingtable n     join parent n   newnode 
else m=somenodesnothavingenoughchildrenin
 leftroutingtable n   rightroutingtable n  
if  there exists such an m 
join m  newnode 
else a = one of its adjacent nodes join a  newnode 

　a node can only accept a new joining node as a child if it has full neighbor routing tables but does not have m children. otherwise  it has to forward the join request to either its parent  its lower level adjacent node or a neighbor node that does not have enough children. a node can only leave its current position if it does not cause the tree to become unbalanced. otherwise  it has to find a replacement node by sending a request to its lower level adjacent node.
　in baton  the range of values managed by a newly inserted node is always obtained as a split from the range managed by its parent. in baton*  limiting the range assigned to the new node thus would force newly inserted nodes to be adjacent to their parent. instead  we allow newly inserted nodes to appear anywhere in the adjacency order  we can actually choose this to maximize local load equalization . the range of values managed by the new node is obtained from one of its adjacent nodes  either the parent or a sibling. in baton*  the cost of finding a place for a new joining node or finding a replacement node is o logmn  since the height of the tree is o logmn . the cost of updating routing table is o m ， logmn  for the neighbor routing tables since the maximum number of neighbor nodes a node can have is o m ， logmn   and each of these has to add a new entry  or remove an entry from its routing tables. also  a newly inserted node has to construct its own routing tables  with up to o m ， logmn  entries  each of which can be obtained in constant time through its parent. in addition  there is a parent link and two adjacency links to create/delete. there can be no children links for a node being newly inserted or deleted. adding these up  the total cost of insertion or deletion is o m ， logmn .
1 queryprocessing datainsertionanddata deletion
　the algorithms for query processing as well as data insertion and data deletion are also a little different in baton* than in baton. the basic operation in all of these is the basic equality search. a node u receiving a search request checks to see if there is a neighbor node it knows about who is more appropriate to handle the search. if the searched value is greater than the u's own upper bound while there is no right hand side neighbor node of u whose lower bound is less than the searched value  the search has to be forwarded to a suitable child. in baton  this would simply be the right child. in baton*  the available information regarding the bounds of the ranges maintained by the various children are considered to find the rightmost child whose lower bound is less than the searched value  and the search request is forwarded to it. similarly  if the searched value is less than the node's lower bound while there is no left hand side neighbor node whose upper bound is greater than the searched value  the node has to try to find the leftmost child whose upper bound is greater than the searched value  to forward the search request. the algorithm is described as in algorithm 1.

algorithm 1 : search-exact  node n  query q 

if   n.lowerbound =q.value  and
  q.value =n.upperbound   localsearch n  q 
else
if  n.upperbound q.value  m=thefarthestnodesatisfyingcondition  m.lowerbound =q.value 
if  there exists such an m  search-exact m  q 
else l=thefarthestchildsatisfyingcondition  l.lowerbound =q.value 
if  there exists such an l  search-exact l  q 
else
search-exact rightadjacentnode n   q 
else // n.lowerbound q.value 
//a similar process is followed towards the left

　algorithms for range query  data insertion and data deletion are modified from those in baton in corresponding ways.
1 node failure  fault tolerance  network restructuring and load balancing
　algorithms for node failure  network restructuring and load balancing are all the same in baton* as in baton. node failure is recovered via the node's parent. load balancing is done between two adjacent nodes or between a lightly loaded leaf node and a heavily loaded leaf node. as needed to achieve load balance  network restructuring is done by shifting nodes via adjacency links. details of these algorithms are omitted here  since they can be looked up in  and used with the obvious changes from 1 to m. instead  we focus here on fault tolerance  which has been greatly improved due to higher fanout  and the load balancing that has been made easier by the new design.
1.1 fault tolerance
　first  let us consider a case where a node is isolated from the network. if a node has full routing tables  it is easy to realize that the lower the level of a non-leaf node  the more the number of links the node has because low level nodes always have more neighbor links than high level nodes do while the number of parent links  adjacent links  and children links are approximately equal among nodes . as a result  high level nodes  closer to the root  are easier separated from the network than low level nodes are. as in baton  there are two special cases. in the first case  the root is a node  which is easily isolated because it has no neighbor link. in this case  if all of its m children and 1 adjacency links of the root are broken  it is isolated from the remaining system. in the second case  if a node's routing tables are not full  it is also easily isolated from the network. however  that node is likely to be a newly joined node which can rejoin the network at low cost. note that in baton*  the longer the time a node in the system is  the higher the level it is in the tree because new nodes always join as children of existing nodes.
　now  let us consider a case where a group of connected nodes is separated from the network. these nodes are isolated if all of their links to nodes outside the isolated group are broken. in other words  the minimum number of links that has to be broken for a group of nodes to be separated from the network is s = links of all nodes in group intra-group links among nodes within group. since high level nodes always contain fewer links than low level nodes do  we will analyze only the case where the network is separated by low level nodes and high level nodes  in other cases  s always has higher values . in other words  the network is separated between the head of the tree and the base of the tree as in figure 1. since the number of low level nodes  with a large level number  dominates the system  the number of high level nodes  which can be separated from the network  is not considerable. note that removal of nodes high in the tree causes no more disruption than removal of nodes near the leaf - they are no more important for purposes of search and update. in particular  the root of the tree can be removed and not cause the tree to fall apart into a disjoint forest.

figure 1: network partition
　for further analysis  let us try to make s as small as possible. s has the minimum value when all nodes in the first part are arranged so that all levels belonged to the group since all neighbor links  which contribute the largest number among all kinds of links  are inter-connected links. in this case  the remaining links  which have to be broken  are adjacency links of nodes to leaf nodes and children links of nodes in the last level to their children. let k be the number of nodes in the first part  and k be the total number of nodes in the last level of the first part  then.
following theorem 1  we have   or
. as a result s   1，k+m，k， m 1 /m = 1 ， k +  m   1  ， k  1 . in the worst case  if the last level of the first part is just one level above the last level of the tree  adjacency links may point to the same node  and hence 1，k nodes may be double counted in the previous formula. as a result  s is only less than  m   1  ， k  1 .
　 1  and  1    s     m 1 ，k  m+1 ，k . in other words  let f be the number of failed nodes in the system  then the maximum number of nodes  which may be separated from the network as a result of the failure is from f/ m + 1  to f/ m   1 . we can easily realize that when m is large enough  this rate is very small. in conclusion  our system is highly fault tolerant.
1.1 load balancing
　local load balancing  with adjacent nodes  is easy to do  and is the cheapest form of load balancing where it works. however  such local balancing will not suffice where there are global imbalances. for example  when data distribution is skewed  using only local load balancing may lead to ripple data migration  which is costly. a solution for this problem is that we have to remove nodes from underloaded regions and add them to overloaded regions. since our system employs the tree structure  internal nodes are not easily to be removed  this solution is only possible for leaf nodes. in special  a workload can be adjusted between a heavily loaded leaf node and a lightly loaded leaf node. as fanout increases leads to an increasing number of leaf nodes  when the fanout m is large  finding a leaf node satisfying condition to do load balancing is easy.
　in general  if a node is overloaded  it tries to do load balancing with its adjacent nodes first. if there is no lightly loaded adjacent nodes  it then tries to find a lightly loaded leaf node to do load balancing. once such a node is found  that node has to perform a forced leave at its current position and a forced join at the new position to share the workload of the overloaded leaf node by leaving the current position and joining in the new position. the tree structure may become imbalance after that. thus  network restructuring is triggered if necessary. the cost of network restructuring is comparable irrespective of fanout  and depends solely on the number of nodes intervening between the old and new positions of a moved node.
1 tuning the fanout m
　the cost for search is decreased logarithmically as the fanout is increased. the cost for a node insertion and deletion goes up. since  search is much more frequent than node insertion and deletion in most systems  this is a good tradeoff to have. exactly how large a fanout to choose is determined by the precise ratio of queries to node updates. in this section  we provide a simple cost model for calculating the optimum value of m.
　since search operations and update operations are dominant operations in our system1  we just build a simple cost model  c  based on them. let α be the percentage of search operations  and 1   α be the percentage of update operations in the system. then c = α ， s +  1   α  ， u  1 ＋ α ＋ 1  where s and u denote the search and update cost respectively. since the approximate costs of a search op-

1
 insertions and deletions can be considered as search operations while node join operations and node departure operations can be considered as update operations since they will trigger update operations.
eration and an update operation are respectively o logmn  and o m ， logmn   in term of routing messages   we have c m  = α，logmn + 1 α ，m，logmn. here  α can be considered as the tuning knob. if all operations in the network involve search operations  α should be big  and vice versa.
differentiating c
m.
since	 	，
function. thus  f m  = 1 has a unique solution m1. it leads to the result   = 1 when when m   m1  and 1 when m   m1. as a result 
c m  is minimum at m1.
　even though we cannot easily find a closed form solution for f m  = 1  it is not hard to find a numerical solution by numerical methods such as newton's method . upon finding m1  we calculate  and c m1   m1 =
  and select the value corresponding to the smallest cost. the result is a good value for fanout. for example  in a system with 1 nodes  α = 1  using newton's method with initial value 1  iteration = 1  we have m1 = 1. by checking c m1 = 1  and c m1 = 1   we get a fanout value of 1 because c 1  = 1   c 1  = 1.
1. anoteonmulti-waystructures
　it is straightforward to extend many well-known distributed search structures to have a fanout of m rather than 1 at each step  using techniques similar to those used in baton*. however  the cost of update will typically be quadratic in fanout  unlike in baton*. here  we present a sketch of the algorithm and the analysis for chord. arguments for other distributed search structures are similar.
　let us call the extended structure of chord for a higher fanout chord*. similar to baton*  we have to modify the way to organize routing tables  or finger tables . instead of keeping links to nodes at distance 1i  a routing table now keeps links to nodes at distance d ， mi  where d = 1..m   1. in particular  the way to calculate finger k .start is modified as below: finger k .start =  n + d ， mk 1  mod n. figure 1 shows two different routing tables corresponding to different fanouts: m = 1  and m = 1. except for changes in routing tables  all chord's algorithms are unchanged in chord*.
　the problem with extending chord is the cost of updating routing tables. in the modified chord*  the size of routing table is  m   1  ， logmn. as a result  the cost of updating routing table for a new joining node or a departure node grows up to o   m   1  ， logmn 1  now. compared to the previous cost of chord o  log1n 1   the increasing factor is
 . this is expensive com-
pared to baton* since baton* only requires an increasing factor of m，logmn/log1n = m/log1m  a linear cost with m . further  an overlay structure such as chord that relies on hashing cannot support range queries efficiently .
1. a flexible method for supporting multi-attribute queries
　in applications that involve multiple attributes  it is not uncommon for queries to involve only a small number of attributes  instead of all the attributes . as a result  if we consider multi-attribute queries as multi-dimensional queries and use systems such as can  or  to support them  it is not efficient because most of the time the queries will involve a large search region. an alternative method pro-

figure 1: a chord ring

figure 1: data indexing
posed by maan  and mercury  is to index each attribute value separately. therefore  multi-attribute queries are solved by choosing one attribute for indexed search while other attributes in the queries are used as post-filters. even though this method overcomes the problem of the previous one  it is still not efficient when the number of attributes increases.
　to support multi-attribute queries over baton*  we propose a method in which we divide the whole range of baton* attributes into several sections: each section is used to index an attribute  if it frequently appears in queries  or a group of attributes  if these attributes rarely appear in queries . since baton* can only support queries over one dimensional data  if we index a group of attributes  we have to convert their values into one dimensional values: in our system we choose hilbert space filling curve. for example  if we have a system with 1 attributes: a1  a1 ... a1 in which only 1 attributes from a1 to a1 are frequently queried  i.e. 1% of all queries   we will build 1 separate indexes for them. the remaining attributes are divided equally into two groups to index  three attributes in each group. in this way  we can significantly reduce the number of replications from
1 down to 1. the index structure is described as figure 1.
1 multi-attribute query processing
　generally  a multi-attribute query q can be defined as a set of subqueries qi  in which each subquery involves an attribute. the result of the query q is an intersection of all results from all subqueries. as a result  we can find the final result of the query q by just finding results satisfying an arbitrary subquery  and using other subqueries as filters. we call the selected subquery a dominant subquery. after taking an arbitrary subquery as the dominant subquery  we have to convert it into queries  which can be executed over baton* overlay network since the domain of values of a subquery is just a section in the overlay network. to do converting we need to consider two cases. if the dominant subquery involves an attribute that is indexed separately 
　
it is transformed into a baton* query in a straightforward way - using the mapping function. however  if the dominant subquery involves an attribute that is indexed together with other attributes  multi-dimensional index   it has to be mapped first into smaller subqueries by using the hilbert space filling curve. after that  these subqueries are converted into baton* queries. finally  these converted subqueries are forwarded in parallel over baton*.
1 data insertion and deletion
　when data is inserted  it has to be indexed in each index structure. since inserted data can be considered as a multi-attribute query in which subqueries are exact match queries corresponding to the attribute values  the data insertion algorithm is similar to the query processing algorithm described above except that all sub queries have to be considered to index data in all index structures.
　to delete existing data  all of its replications have to be deleted. like the data insertion algorithm  nodes that keep index values are found by a corresponding multi-attribute query. after that  the data index is removed from those nodes.
1 heuristics to enhance performance
　in this section  we introduce several techniques that can help to achieve a better performance by reducing the number of search steps as well as the number of messages in query processing.
　first  for a multi-attribute query involving many attributes  if we can choose a query that has only a few of the satisfied results or results are stored in a small number of nodes  the query processing just needs a few steps to complete as well as to filter unwanted results. as a result  we propose some heuristics that can be applied to select the dominant subquery as follows.  1  if there is a subquery involving an attribute that is indexed separately  it is a candidate for selection because searching over a single index is always faster than searching over a group index.  1  if there is a subquery that is an exact match query  it is a candidate for selection because an exact match query always returns fewer results than a range query.  1  if there are multiple subqueries involving attributes that are indexed together  instead of selecting only one dominant subquery  we should take all these subqueries as dominant subqueries to search since we can filter the region of the search over multi-dimensional space.
　second  in some applications  there exist attributes that are always queried together. in such a case  we should group them together into a group to index no matter whether they are frequently queried or rarely queried. as discussed above  subqueries involving attributes that are indexed together can be used as dominant subqueries for searching. thus  we can always reduce the cost of search in this kind of query.
　third  from the experiments  we realize that the system can achieve better performance if we make the structure more flexible. it means that we do not need to define only two kinds of attributes and divide rarely attributes equally into groups as discussed above. depending on the frequency of attributes in queries  we can group them into groups with different number of attributes.
　fourth  for some attributes  their values can only fall in a small range of values while for others  their values can fall in a large range of values. as a result  if we divide the whole

figure 1: optimal values of fanout
range of values of baton* into equal sections  those attributes with small range of values will have a sparse index whereas those attributes with large range of values will have a dense index. this leads to the problem of skewed data distribution. even though  baton* can handle skewed data distribution well  it takes some cost to do load balancing. to avoid this problem  we propose that values of sections are divided based on needs. it means that attributes with bigger range of values have to be granted bigger index space.
　finally  as discussed in the previous section  subqueries  which are created from converting a query in multi-dimensional index  are forwarded in parallel. however  we realize that most of the time these subqueries are forwarded to only one node or a few nodes since they are all related to nearby range of values. as a result  instead of sending multiple query messages to the same node  we can combine these messages into one message. this technique can significantly reduce the number of query messages which has to be forwarded.
1. evaluation
　to evaluate the performance of our proposal  we implemented a simulation system in java and ran it over planetlab   a testbed for large-scale distributed systems. in our implementation  each peer node is identified both physically by a pair of ip address and port number and logically by its position in the tree structure. each planetlab node is used to simulate hundreds of peer nodes. there is a fake server  which creates events and sends them to peer nodes for processing  it exists for experimental purpose only . communication between nodes is via sockets.
　to evaluate the performance of our system  we tested the network with different numbers of nodes from 1 to 1 using different fanout values from 1 to 1. a number of data equal to the network size multiplies 1  which are numbers from 1 to 1 1  are inserted to the network in batches. for each test  1 exact match queries and 1 range queries are executed  and the average cost of operations are taken. searched ranges are created randomly by getting the whole range of values divided by the total number of nodes multiplies α  where α = 1..1. note that in some experiments  where it is not necessary to vary the network size or the fanout  the default value of network size is 1 nodes while the default value of fanout is 1.
1 single-attribute query

 a  cost of exact match query	 b  cost of range query	 c  cost of updating routing table
figure 1: effect of varying fanout values　we can see that with the new baton* structure the cost of exact match query and range query is reduced when the fanout is increased as in figure 1 a  and 1 b . in particular  increasing fanout brings greater benefit when the number of table 1: a comparison between an estimated and the best experimental fanout
αm1m1c m1 c m1 error1111111111111111111111111nodes in the system is big because the larger the number of nodes  the more the height of the tree structure is reduced when fanout is increased. however  a faster search process always requires a bigger storage to keep index information  and there is no exception in this case. besides reducing cost of search  increasing fanout also leads to increasing routing table size  and hence increasing cost of updating routing table as shown in figure 1 c . as a result  depending on application  we should select a suitable fanout to tradeoff between these costs as described in the cost model in section 1. figure 1 shows the experimental results of using different fanout values for different α or knob values. together with table 1  the results show that the cost of our estimated good fanout values are not much different from the cost of the real best fanout values returned from the experiment. in the table  m1 is the estimated good fanout  m1 is the best experimental fanout  c m1  is the cost of doing experiment with fanout m1  c m1  is the cost of doing experiment with fanout m1  and error is calculated by the formula: e = | c m1    c m1  /c m1 |.
1 multi-attribute query

figure 1: cost of insertion
　to evaluate the performance of multi-attribute query  we used the same schema as in our previous example. there are totally 1 attributes in which 1 attributes are frequently queried while 1 others are rarely queried. for simplicity  we just assume all attributes values are integers. we compare our baton* against two other methods. the first is a straightforward mapping based method  which considers 1 attributes as 1 dimensions and maps the data points into a single-dimensional space using hilbert curve so that the transformed values can be indexed using baton*. accordingly  during query processing  the multi-attribute query is transformed into a set of single-dimensional queries. such transformation approach has been adopted in various existing works such as . the second method is similar to those used in maan  and mercury  where the data is indexed separately for each attribute and an attribute is randomly chosen among all the attributes appearing in the query for searching. in more detail  1 overlays of baton* were used  one for each attribute.
　the queries used in this experiment is composed of 1 percent of queries involving 1 common attributes and 1 percent of queries involving rarely queried attributes. the results are shown in figure 1 and figure 1 a   1 b . we observe that the insertion cost of the mapping based method is the lowest since the data point is indexed only once. however  the search cost of the mapping based method is very high. it is much higher than the other schemes  and is clearly unacceptable. on the other hand  indexing 1 attributes as in the maan-like method incurs high insertion cost as a data item is indexed 1 times. our proposed method strikes a balance between the query cost and insertion cost  and the attribute grouping could be tuned based on the query patterns and loads. in fact  the experiment results show that our method requires much less cost of insertion than the maan-like method while doesn't require much higher search cost.
　in the experiment above  1 percent of queries involve common attributes. in this experiment  we study the effect of varying the percentage of queries involving common attributes. figure 1 c  shows the results as we vary the percentages from 1 percent to 1 percent. the result shows that the search performance decreases when the attributes  indexed separately are queried less. in the worst case  if all attributes are equally queried  the search cost is twice the cost of the method which indexes all attributes. however  it is still acceptable  if the main target of the system is to reduce the cost of data indexing. it is the case where the system consists of a huge number of attributes  and hence indexing each attribute separately is impossible due to the huge cost of data indexing.

 a  cost of exact match query	 b  cost of range query	 c  effect of varying query distribution on range query
figure 1: cost of searching multi-attribute queries1 load balancing

 a  number of times each loadbalancing scheme is invoked

 b  average additional messagesrequired for doing load balancing
figure 1: cost of load balancing
　increasing fanout not only helps to reduce the search cost but also helps to achieve better load balancing. to verify this claim  we test the network with a skewed data distribution  which is generated using a zipfian distribution with parameter 1 and evaluate the cost of load balancing as we vary fanout. for simplicity  in our system  we assume that the query distribution follows the data distribution. as a result  the workload of a node is solely determined by the amount of data stored at that node. when a node joins the network it is assigned a default upper and lower load limit by its parent. if the number of stored data at the node is greater than the upper bound boundary  it is considered as an overloaded node and vice versa. if a node is overloaded and it cannot find a lightly loaded leaf node  it is likely that all other nodes also have the same work load  so it automatically increases the boundaries of storage capability.
　as we discussed above  increasing fanout leads to increasing number of leaf nodes. as a result  nodes can often load balance by sharing the work load between a heavily loaded leaf node and a lightly loaded leaf node. when this is not possible  a more expensive  major  load balancing operation is required  involving the forced removal and forced reinsertion of a lightly loaded node elsewhere in the system. figure 1 a  shows the number of times each load balancing scheme is involved in a 1 nodes network with different fanouts. the results show that when the fanout is increased  the number of times when the local load balancing is invoked is significantly decreased while the number of times when the major load balancing is invoked is not increased much. this may appear counter-intuitive at first  however it is because many of the times when the local load balancing scheme is invoked  it is due to ripple data migration between adjacent nodes when a heavily loaded leaf node can't find a lightly loaded leaf node. with higher fanouts  a heavily loaded leaf node can find a lightly loaded leaf node easier and hence can avoid the problem of ripple data migration. this leads to the result that the higher the fanout is  the fewer the number of load balancing efforts is needed. the result is confirmed in figure 1 b   which shows the costs of load balancing in different network sizes and different fanouts.
1 fault tolerance
　to evaluate the system's fault tolerance in case of massive failure we initialized the system with 1 nodes. after that  we let nodes randomly fail step by step without recovering. at each step  we check to see if the network is partitioned or not. figure 1 a  shows the average percentage of nodes that must fail before the network is partitioned. the result confirms that our system is highly fault tolerant since it is only partitioned when approximately one fourth of nodes fails in case of fanout = 1. increasing fanout leads to increasing fault tolerance: more than half the nodes fail before network with fanout 1 is partitioned. moreover  most of time  only a small number of nodes is separated from the majority as shown in table 1.
　the problem brought by massive failure is massive destruction of links connected to failed nodes. since the search process has to bypass the failure nodes  and there is no way to know exactly which path can safely lead to the destination node without interruption of failure nodes  the search query has to be forwarded forth and back several times to find a way to the destination node. since the greater the number of failed nodes  the greater the number of links is destroyed  it is expected that the increasing number of failure nodes will increase the search cost. figure 1 b  shows such an effect. the results also further confirm that the higher fanout not only improves the fault tolerance  but also reduces the search cost for the same number of failure nodes. it is be-
　
table 1: sizes of the smaller partition in the segmented network in case of massive node failure with different fanouts  m 
number of nodes1★1★1★1 1number of
occurrences in all test casesm=111m=111m=111m=111m=111cause higher fanout provides higher number of connection paths among nodes. as a result  it is easier to find a connected path between the search node and the destination node. note that in the figure  the  break points  are points in which the network is segmented. we can notice that the  break points  of network fanouts ranging from 1 to 1 occur from left to right  confirming the resilience of trees with higher fanout.

 a  percentage of failed nodes before network is partitioned

 b  search cost in case of massivefailure
figure 1: effect of massive failure
1. related work
　extensive work has been done to support search in the area of distributed data. most of them are based on scalable and distributed data structures  sdds  such as . however  these structures cannot be used in p1p systems where there is neither global index nor centralized servers. since our paper focuses on search in p1p systems  we only discuss related work in p1p systems.
1 single-attribute query
　existing structured p1p systems can be classified into three categories: distributed hash table based systems  skip list based systems  and tree based systems.
　distributed hash table based systems use distributed hash tables to index data. as a result  they can support exact match queries well. moreover  distributed hash tables help these systems to distribute the workload among nodes equally. some of the better known p1p systems that belong to this category are chord   which utilizes a ring structure  can   which utilizes a multi-dimensional grid structure  tapestry  and pastry   which utilize the plaxton mesh. unfortunately  these systems cannot support range queries since distributed hash tables destroy the ordering of data. it means that they cannot support common queries such as  find all research papers published from 1 to 1 . to support range queries  variants of the distributed hash method are proposed. a locality sensitive hashing  which allows similar ranges to be hashed to the same peer with high probability is proposed in . however  this method can only provide approximate answers. another approach  which adds the ranges into hash functions  is proposed in . as a result  the system can always find a superset of the range query. even though this method can provide exact answers  exact query search is not efficient.  can also provide exact answers by using locality preserving hashing. however  the load may not be balanced since the workload distribution may be skewed if data is skewed.
　skip list based systems such as skip graph  and skip net  are based on skip-list structure. they can support both exact match queries and range queries by partitioning data into ranges of values. however  they cannot guarantee data locality and load balancing in the whole system.
　tree based systems also have their own problems. p-grid   which utilizes a binary prefix tree structure  cannot guarantee the bound of search steps since it cannot control the height of the tree. the scheme proposed in  also suffers from the same problem. there  an arbitrary multi-way tree structure is used  in which each node maintains links to its parent  children  sibling and neighbors. p-tree  utilizes the b+-tree structure on top of the chord overlay network. in p-tree  peer nodes are organized as a chord ring in which each of them maintains a data leaf node and a left most path from the root to that node of the b+-tree. this leads to significant overhead in building and maintaining consistency of the b+-tree. specifically  a tree structure has been built for each joining node  and periodically  peer nodes have to exchange their stored b+-tree structure for checking consistency. baton   as mentioned  utilizes a binary balanced tree structure. as a result  it can control the height of the tree  and hence avoid the problem of pgrid. nevertheless  similar to other p1p systems  baton's search cost is bounded at o log1n .
1 multi-attribute query
　maan   which extends chord   supports multiattribute queries by mapping each attribute value to a value in the chord identifier space via uniform locality preserving hashing. queries are processed by using single attributedominated query resolution approach. it means that only one dominated attribute is used to search while other attributes are carried along the query for filter purpose. as a result  it takes o logn + n ， sk  routing hops to resolve the query  where sk is the selectivity of of the query on the dominated attribute ak.
　unlike maan  which uses the same identifier space for all attributes  mercury  uses separate identifier spaces  called routing hubs  for separate attributes. each routing hub is a collection of nodes connected with each other to form an overlay structure. similar to maan  inserted data are indexed on all attributes and queries are processed by a dominated attribute. consequently  queries are passed to a hub corresponding to the dominated attribute while inserted data are replicated to all routing hubs.
　dim  supports multi-attribute queries in sensor networks by considering them as multi-dimensional range queries. it employs a locality preserving geographic hash  which looks like k-d tree  to map multi-dimensional space to two-dimensional space. in fact  dim is similar to can in many ways. the〔 problem of dim is that the routing cost is bounded at o  n   which is quite expensive. moreover  dim is also not efficient if the query only involves a small number of attributes since the projected volume from higher dimensions to two dimensions is rather large. it also suffers from load imbalance when data is skewed.
1. conclusion
　in this paper  we proposed a balanced multi-way tree structure  baton*  which allows us to reduce the cost of routing message to o logmn . additionally  by increasing the fanout of the tree  we increase the number of links among nodes  and hence increase the system's fault tolerance. moreover  increasing the fanout leads to an increase in the number of leaf nodes  which facilitates better load balancing. over this structure  we proposed a method to support multi-attribute queries efficiently. our method relies on the construction of multiple independent indices for groups of one or more attributes. we suggest techniques for partitioning attributes into such groups. a careful experimental analysis  on the planetlab  infrastructure  confirms efficiency of our proposed system.
　we have incorporated baton* into bestpeer and as a future work  we shall evaluate baton* as part of bestpeer on data sharing applications.
