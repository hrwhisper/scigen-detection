large web search engines have to answer thousands of queries per second with interactive response times. due to the sizes of the data sets involved  often in the range of multiple terabytes  a single query may require the processing of hundreds of megabytes or more of index data. to keep up with this immense workload  large search engines employ clusters of hundreds or thousands of machines  and a number of techniques such as caching  index compression  and index and query pruning are used to improve scalability. in particular  two-level caching techniques cache results of repeated identical queries at the frontend  while index data for frequently used query terms are cached in each node at a lower level.
모we propose and evaluate a three-level caching scheme that adds an intermediate level of caching for additional performance gains. this intermediate level attempts to exploit frequently occurring pairs of terms by caching intersections or projections of the corresponding inverted lists. we propose and study several offline and online algorithms for the resulting weighted caching problem  which turns out to be surprisingly rich in structure. our experimental evaluation based on a large web crawl and real search engine query log shows significant performance gains for the best schemes  both in isolation and in combination with the other caching levels. we also observe that a careful selection of cache admission and eviction policies is crucial for best overall performance.
categories and subject descriptors: h.1.m  information systems : miscellaneous; h.1  information systems : information storage and retrieval; d.1  software engineering : metrics general terms: algorithms  performance  experimentation keywords: web search  inverted index  caching.
1.	introduction
모due to the rapid growth of the web from a few thousand pages in 1 to its current size of several billion pages  users increasingly depend on web search engines for locating relevant information. one of the main challenges for search engines is to provide a good ranking function that can identify the most useful results from among the many relevant pages  and a lot of research has focused on how to improve ranking  e.g.  through clever term-based

 work supported by nsf career award nsf ccr-1 and the new york state center for advanced technology in telecommunications  catt  at polytechnic university.
copyright is held by the international world wide web conference committee  iw1 . distribution of these papers is limited to classroom use  and personal use by others.
www1  may 1  1  chiba  japan.
acm 1-1/1.
scoring  link analysis  or evaluation of user traces.
모once a good ranking function has been engineered  query throughput often becomes a critical issue. large search engines need to answer thousands of queries per second on collections of several billion pages. even with the construction of optimized index structures  each user query requires a significant amount of data processing on average. to deal with this workload  search engines are typically implemented on large clusters of hundreds or thousands of servers  and techniques such as index compression  caching  and result presorting and query pruning are used to increase throughput and decrease overall cost.
모to better understand the performance issue  we need to look at the basic structure of current search engines. these engines  like many other information retrieval tools  are based on an inverted index  which is an index structure that allows efficient retrieval of documents containing a particular word  or term . an inverted index consists of many inverted lists  where each inverted list iw contains the ids of all documents in the collection that contain a particular word w  sorted by document id or some other measure  plus additional information such as the number of occurrences in each document  the exact positions of the occurrences  and their context  e.g.  in the title  in anchor text .
모given  e.g.  a query containing the search terms apple  orange  and pear  a typical search engine returns the 1 or 1 documents that score highest with respect to these terms. to do so  the engine traverses the inverted list of each query term  and uses the information embedded in the inverted lists  about the number of occurrences of the terms in a document  their positions  and context  to compute a score for each document containing the search terms. in addition  scores based on link analysis or user feedback are often added into the total score of a document; in most cases this does not affect the overall structure of the computation if these contributions can be precomputed offline  e.g.  using pagerank .
모clearly  each inverted list is much smaller than the overall document collection  and thus scanning the inverted lists for the search terms is much preferable to scanning the entire collection. however  the lengths of the inverted lists grow linearly with the size of the collection  and for terabyte collections with billions of pages  the lists for many commonly used search terms are in the range of tens to hundreds of megabytes or even more. thus  query evaluation is expensive  and large numbers of machines are needed to support the query loads of hundreds or thousands of queries per second typical of major engines. this motivates the search for new techniques that can increase the number of queries per second that can be sustained on a given set of machines  and in addition to index compression and query pruning  caching techniques have been widely studied and deployed.
모caching in search engines has been studied on two levels . the first level of caching  result caching  takes place at the frontend  and deals with the case where identical queries are issued repeatedly by the same or different users. thus  by keeping a cache of a few ten thousand to a few million results that have recently been returned by the engine  we can filter repeated queries from the workload and increase overall throughput. result caching has been studied in  1  1  1  1  1 . it gives a measurable benefit at a low cost  each result could simply be stored as a complete html page in a few kb   though the benefit is limited by the degree of repetition in the input stream. at a lower level  list caching is used to keep inverted lists corresponding to frequently used search terms in main memory  resulting in additional benefits for engines with disk-based index structures. the benefits of a two-level caching approach in an actual search engine were studied in .
모in this paper  we propose and evaluate a three-level architecture with an additional intermediate level of caching. this level  called intersection caching or projection caching  depending on the implementation   caches inverted list data for pairs of terms that commonly occur together in queries with more than two search terms. the basic idea is very simple and relies on the fact that all of the major search engines by default only return documents that contain all of the search terms. this is in contrast to a lot of work in the ir community where every document containing at least one of the terms participates in the ranking; we will discuss this issue again later. thus  search engines need to score only those documents that occur in the intersection of the inverted lists. unfortunately  in most cases the most efficient way to find the intersection still involves a complete scan over the lists  and this dominates the cost of query processing. by caching pairwise intersections between lists  which are typically much smaller than each of the two lists  we hope to significantly reduce this cost in subsequent queries. we note that the basic idea of caching intersections was also recently proposed in the context of p1p-based search in   but the scenario and objectives are rather different as discussed later.
모while the idea of caching intersections is very simple  the resulting weighted caching problem turns out to be quite challenging. in the main technical part of the paper  we discuss and evaluate several online and offline caching algorithms. even very restricted classes of the problem are np-complete  but we show that there are practical approaches that perform much better than the basic landlord algorithm  1  1  for weighted caching on typical query traces. we also perform an evaluation of the performance of all three caching levels together. the conclusion is that caching gives a significant overall boost in query throughput  and that each level contributes measurably.
모the next section gives some technical background  and section 1 discusses related work. the three-level caching approach is described and discussed in detail in section 1. section 1 studies the resulting intersection caching problem and presents two basic approaches. section 1 refines these approaches and performs a detailed experimental evaluation across all three caching levels. finally  section 1 provides some concluding remarks.
1.	searchenginequeryprocessing
모in this section  we provide some background on query execution in search engines. we assume that we have a document collection d = {d1 d1 ...dn 1} of n web pages that have already been crawled and are available on disk. let w = {w1 w1 ... wm 1} be all the different words that occur anywhere in the collection. typically  almost any text string that appears between separating symbols such as spaces  commas  etc.  is treated as a valid word  or term  for indexing purposes in current engines.
indexes: an inverted index i for the collection consists of a set
of inverted lists iw1 iw1 ... iwm 1 where list iw contains a post 
ing for each occurrence of word w. each posting contains the id of the document where the word occurs  the  byte or approximate  position within the document  and possibly information about the context  in a title  in large or bold font  in an anchor text  in which the word occurs. the postings in each inverted list are often sorted by document ids  which enables compression of the list. thus  boolean queries can be implemented as unions and intersections of these lists  while phrase searches  e.g.  new york  can be answered by looking at the positions of the two words. we refer to  for more details.
모queries: a query q = {t1 t1 ... td 1} is a set of terms  words . for simplicity  we ignore search options such as phrase searches or queries restricted to certain domains at this point. in our caching problems we are presented with a long sequence of queries q = q1 q1 ... ql 1  where.
모term-based ranking: the most common way to perform ranking in ir systems is based on comparing the words  terms  contained in the document and in the query. more precisely  documents are modeled as unordered bags of words  and a ranking function assigns a score to each document with respect to the current query  based on the frequency of each query word in the page and in the overall collection  the length of the document  and maybe the context of the occurrence  e.g.  higher score if term in title or bold face . formally  a ranking function is a function f that  given a query q = {t1 t1 ...td 1}  assigns to each document d a score f d q . the system then returns the k documents with the highest score. one popular class of ranking functions is the cosine measure   for example
 
where w q t  = ln 1 + n/ft   w d t  = 1 + lnfd t  and fd t and ft are the frequency of term t in document d and in the entire collection  respectively. many other ranking functions have been proposed  and the techniques in this paper are not limited to any particular class.
모and vs. or: many ranking function studied in the ir community  including the above cosine measure  do not require a document to contain all query terms in order to be returned in the results.  e.g.  a document containing two out of three query terms multiple times or in the title may score higher than a document containing all three terms.  however  most search engines enforce and semantics for queries and only consider documents containing all query terms. this is done for various reasons involving user expectations  collection size  and the preponderance of short queries  thus  for most queries  there will be many documents containing all query terms . our approach fundamentally depends on and semantics  which are the default in essentially all major engines  e.g.  google  altavista  alltheweb  inktomi  lycos  teoma  and wisenut .
모query execution: given an inverted index  a query is executed by computing the scores of all documents in the intersection of the inverted lists for the query terms. this is most efficiently done in a document-at-a-time approach where we simultaneously scan the inverted lists  which are usually sorted by document id  and compute the scores of any document that is encountered in all lists.  it is shown in  that this approach is more efficient than the termat-a-time approach where we process the inverted lists one after the other.  thus  scores are computed en passant while materializing the intersection of the lists  and top-k scores are maintained in a heap structure. in the case of and semantics  the cost of performing the arithmetic operations for computing scores is dominated by the cost of traversing the lists to find the documents in the intersection  since this intersection is usually much smaller than the complete lists.
모search engines use a number of additional factors not present in standard cosine-type ranking functions  such as context  e.g.  term occurs in title  url  or bold face   term distance within documents  whether two terms occur close to each other or far apart in the text   and link analysis and user feedback. the first two factors can be easily included while computing scores as outlined above. the most commonly used way to integrate the other factors is to precompute a global importance score for each document  as done in pagerank   or a few importance scores for different topic groups   and to simply add these scores to the term-based scores during query execution  1  1  1 . our approach does not depend on the ranking function as long as the total cost is dominated by the inverted list traversal.
모search engine architecture: major search engines are based on large clusters of servers connected by high-speed lans  and each query is typically executed in parallel on a number of machines. in particular  current engines usually employ a local index organization where each machine is assigned a subset of the documents and builds its own inverted index on its subset. user queries are received at a frontend machine called query integrator  which broadcasts the query to all participating machines. each machine then returns its local top-1 results to the query integrator to determine the overall top-1 documents .
모each subset of the collection is also replicated and indexed on several nodes  and multiple independent query integrators can be used. we note that there are alternative partitioning approaches such as the global index organization and various hybrids that are not commonly used in large engines though they may have advantages in certain scenarios; see  1  1  1  1  for discussion.
모query processing optimizations: given simple mechanisms for load balancing and enough concurrency on each machine  the local index organization results in highly efficient parallel processing. thus  the problem of optimizing overall throughput reduces again to the single-node case  i.e.  how to maximize the number of queries per second that can be processed locally on each machine with a reasonable response time. one commonly used technique is to compress each inverted list using various coding techniques   thus reducing overall i/o for disk-based index structures but increasing cpu work. because of this tradeoff  fairly simple and fast techniques tend to outperform schemes geared towards optimal compression . our experiments use compression but do not depend on it.
모other optimizations attempt to determine the top-k results without a complete scan of the intersection or union of the inverted lists  by presorting the lists according to their contributions to the score and terminating the traversal early  or by removing low-scoring postings from the index altogether  . there has been a significant amount of work in the ir and database communities on this issue under various scenarios; see  1  1  1  1  1  1  1  1  for recent work. various schemes are apparently in use in current engines but details are closely guarded. note that these techniques are designed for certain types of ranking functions and  e.g.  do not easily support use of term distance within documents. our experiments use a full traversal of the list intersections  but our approach could be adapted to pruned schemes as well though this is beyond the scope of this paper. a third common optimization are caching schemes  discussed in detail in the next section.
1.	discussion of related work
모for more background on indexing and query execution in ir and search engines  see  1  1  1 . for basics of search engine architecture we refer to  1  1  1  1 . in the following  we focus on previous work on caching and on other issues directly relevant to our work.
모result caching: as indicated  result caching filters out repetitions in the query stream by caching the complete results of previous queries for a limited amount of time. it was studied in  1  1  1  1  1  and is probably in use in most major engines. result caching can be easily implemented at the query integrator  and  also proposes caching results in the internet closer to the user. work in  1  1  also connects result caching to the problem of efficiently returning additional result pages for a query  which is most efficiently done by computing and storing more than just 1 results for each query. result caching only works on completely identical queries and is thus limited in its benefits by the query stream. however  it is easy to implement and does give significant benefits even under very simple caching policies. a side effect of result caching is that the average number of search terms increases for those queries that are actually executed  since single-term and two-term queries are more likely to be already cached.
모list caching: at the lower level inside each machine  frequently accessed inverted lists are cached in main memory to save on i/o. this is sometimes done transparently by the file system or when using a database system such as berkeley db to store the index   though for typical ir and web search workloads better results may be achievable with specialized caching policies . of course  list caching only applies to disk-resident index structures  and some engines attempt to keep all or most of the index in main memory for optimum performance.
모two-level caching: in   saraiva et al. evaluate a two-level caching architecture using result and list caching on the search engine todobr  and show that each level contributes significantly to the overall benefit. for list caching  a simple lru approach is used. we note that it is possible that techniques similar to ours are already in use in one of the major engines  but this type of information is usually kept highly confidential and we are not aware of it.
모caching in p1p search: the basic idea of caching results of intersections that we use in our three-level caching approach was recently also proposed in the context of peer-to-peer search in . we note that the approach in  is quite different from ours. their main goal is to avoid repeated transmissions of inverted list data in a peer-to-peer system with global index organization  while we are interested in improving query throughput in each node by decreasing disk traffic and cpu load. the main emphasis in  is on distributed data structures for keeping track of intersections that are cached somewhere in the system  while in our case this problem is easily solved by a standard local data structure. our emphasis is on the use of intersection caching in a three-level cluster-based architecture  with different algorithms and cost trade-offs than in a peer-to-peer environment  and its performance on a large query load from a real engine. as pointed out in   there is also some similarity to views and join indexes in database systems.
모set intersections: we note that in some scenarios  there are of course more efficient ways to intersect two lists than a scan  in particular when lists are of very different lengths. however  for diskresident inverted indexes  this is only true if the ratio between the list lengths is quite large  on the order of thousands or tens of thousands depending on whether decoding cost is taking into account . recent adaptive set intersection techniques  also do not work well for disk-resident structures  although some limited benefits are possible in main-memory and peer-to-peer environments .
모optimizations for phrases: caching of intersections is related to the problem of building optimized index structures for phrase queries   i.e.   new york  . in particular  intersections can be used to evaluate phrase queries  while on the other hand some of the most profitable pairs of lists in intersection caching turn out to be common phrases. note that exhaustive index structures for two-word phrases have only a small constant factor overhead over a standard index  since each occurrence of a word is directly followed by only one other word. caching all intersections between terms  on the other hand  is impossible and thus appropriate caching policies are needed.
모weighted caching: in many caching problems  the benefit of caching an object is proportional to its size  e.g.  when caching to avoid disk or network traffic . weighted caching problems deal with the case where each object has a size and a benefit that may be completely independent of its size. weighted caching problems are  e.g.  studied in  1  1   which propose and analyze a simple algorithm called landlord that basically assigns leases to objects based on their size and benefit and evicts the object with the earliest expiring lease. both  1  1  perform a competitive analysis of the landlord algorithm  and some experimental results for a web caching scenario unrelated to search are given in . in our case  we are dealing with a weighted caching problem where the size of the cached object is the size of an intersection or projection  and the benefit is the difference between this size and the sizes of the complete lists. moreover  there is also a cost in inserting an object into the cache  which requires us to employ appropriate cache admission policies.
1.	athree-levelcachingapproach
모we now describe and discuss the proposed three-level caching architecture in detail. the architecture is motivated by a few simple observations on available search engine logs. in particular  result caching works very well on single-term and two-term queries but does not perform as well on queries with more terms  which are less likely to be exactly repeated. however  an analysis of large query logs indicates that queries with three or more terms are likely to contain at least one pair of terms that has previously appeared together. thus  a three-term query {a b c} could be processed by scanning the inverted list ia for term a and a cached list for the intersection of ib and ic. if the three lists ia  ib  ic are of approximately the same length  and the intersection of ib and ic is much smaller than either of the two lists  then we would save almost a factor of 1 even with only one pair having occurred previously. if two pairs have previously occurred  then by scanning the two intersections we could save most of the cost of the query.

figure 1: three-level caching architecture withresult caching at the query integrator  list caching in the main memory of each node  and intersection caching on disk.
모we will discuss the exact format and treatment of the cached intersections later. by combining result  intersection  and listcaching  we get a three-level caching architecture shown in figure 1 and summarized as follows:
  result caching: the query integrator maintains a cache of the results of recent queries  either in memory or on disk. cache size and eviction policy are typically not critical as large numbers of results can be cached cheaply. for our query log of about a million queries  results can be cached essentially over the entire log. queries not covered by result caching are broadcast to query processing nodes.
  intersection caching: at each node  a certain amount of extra space  say 1% or 1% of the disk space used by the index  is reserved for caching of intersections. these intersections reside on disk and are basically treated as part of the inverted index or as a separate inverted index. for each query  we check if any pairwise intersections are already cached  and use these to process the query. in addition  during processing we create en passant additional intersections for some or all of the pairs of terms in the query and add them to the cache. we will show that this can indeed be done efficiently.
  list caching: at the lowest level  a limited amount of main memory  typically several hundred mb in nodes with at least 1gb of memory  is used to cache frequently accessed inverted lists as well as intersections.
thus  intersection caching complements result caching as it focuses on queries with three and more terms  and is orthogonal to list caching. intersection caching is relevant to both disk-based and memory-based index structures  though the performance ramifications are somewhat different as we will see.
1	intersection vs. projection caching
모we now discuss the precise format of the cached intersections. recall that an inverted list is a sequence of postings sorted by document id  with each posting containing the document id and additional information about each occurrence of the term in the document. in order to use an intersection instead of the original list during query execution  this data has to be preserved for postings whose document ids appear in both lists. thus  a posting in the intersection list would consist of a document id and information about all occurrences of both words in the document.
모however  in our implementation we decided to follow a slightly different approach which we call projection caching. instead of creating an intersection of lists ia and ib  we create two projections ia뫸b and ib뫸a  where ia뫸b contains all postings in ia whose document id also appears in ib  and ib뫸a vice versa. there are several advantages of this approach:  1  projected inverted lists have exactly the same format as other inverted lists and thus no changes in the query processor are required. also  creation of projections from complete lists is very simple.  1  ia뫸b and ib뫸a are treated independently by the list and intersection caching mechanisms and can be evicted separately  which is desirable in some cases.  1  some additional minor optimizations are possible during query execution; e.g.  a query {a b c} could be executed by using ia뫸b  ib뫸c  and ic뫸a instead of using pairs. a disadvantage of using projections is that the two projections are slightly larger than a single intersection as the document id is stored twice. we decided to use projections in our query processor as the advantages outweigh the slight space penalty. we note that our results can be stated either in terms of intersection or projection caching  and the performance of both schemes is comparable.
1	caching overheads
모one common assumption is that caching an object does not result in any cost apart from some limited administrative overhead  data structures  and the space used for caching. in our context  creation of projections for caching is piggybacked onto query execution  and thus only involves inverted lists that are being retrieved from disk by the query processor anyway. however  in reality there are some costs associated with creating projections and inserting them into the cache that need to be taken into account in order to get good performance. in addition to a very small overhead in making caching and query execution decisions  we have the following more significant costs:
 1  write cost: since our projection cache is disk-based  a newly inserted projection has to be written out to disk.
 1  encoding cost: before writing out the projection  it is encoded using the same index compression scheme that is used in the inverted index.
 1  projection creation: even though projections are created en passant during execution of a query  without additional disk accesses  there is a certain cpu overhead due to necessary changes in the query processor.
we report the first cost in our experiments in terms of the number of blocks written out  and show that it can be kept at a fairly low level compared to the savings in read costs. the second cost is typically fairly small  provided that a fast compression scheme is used for the index. in our case  we use a variable-byte compression scheme evaluated in   which achieves good compression at a low cost. a more subtle issue is the cpu overhead in creating the projections. as we show later  even in online schemes all of these costs can actually be kept at a very low level by adopting a suitable cache admission policy that prevents the creation of too many projections that are likely to be evicted from cache before being used.
모in the first part of our experimental evaluation  we report results in terms of  logical  disk block accesses  including disk reads in query processing and disk writes for adding projections to the cache  but ignoring the caching of lists in main memory. this gives us a rough view of the relative performance of various schemes. in subsection 1  we then discuss in detail the cpu savings and overhead due to projection creation  while subsection 1 evaluates the effect of adding list caching. we note here that the optimal choice of caching policies depends on the relative speeds of disk and cpu  the choice of compression scheme  and whether the index is primarily disk-based or memory-based  and we are unable to evaluate all cases in the limited space. however  we will show that significant performance gains are possible both for primarily diskbased and memory-based index structures  and that the overhead of our schemes is very low.
1.	basic policies for intersection caching
모in this section  we study cache maintenance policies for intersection caching. we first define the problem and discuss complexity issues  then present a greedy algorithm for the offline version of the problem  and then describe the landlord algorithm  1  1  for weighted caching.
1	problem definition and complexity
모recall that we are given a sequence of queries q = q1 q1 ...  ql 1  where. for any query q = {t1 t1  ... td 1} that is executed  we can generate and cache any projections it뫸t1 with t t1 뫍 q  subject to the maximum cache size c.
fortheeachsize tof뫍itq뫸  teither1 is |iti뫸t tor1|.anyqueryit뫸qt1canwithbetexecuted1 뫍 q thatbyisscanning currently
in the cache. the cost of executing the query is equal to the sum of the lengths of the lists that are scanned  and our goal is to minimize total query execution cost.
모we note that the results in this section can be stated either in terms of intersections or projections. in the offline version of the problem  we assume that the sequence of queries is known ahead of time and that the set of projections in the cache is selected and created before the start of execution. in the online version  queries are presented one at a time and projections can be created and cached during execution of queries as described above and evicted at any point in time. for simplicity  we do not charge for the cost of creating the projections in the above definition  though our later experiments will also consider this issue.
모for the offline version  it is not difficult to see that the problem is np-complete through a reduction from subset sum   as are many other caching problems that allow arbitrary object sizes. however  this observation does not really seem to capture the full complexity of our problem. we can strengthen the result as follows.
모theorem 1. the offline problem is np-complete even in the case where all projections are of the same size and queries are limited to at most 1 terms.
proof sketch: by reduction from vertex cover. given a graph g =  v e  and an integer k  we construct an instance of our caching problem as follows. we have one term tu for each node in u 뫍 v   and in addition we have a special term t1. for each edge  u v  뫍 e  we create a query {tu tv t1}. we assume that all projections between two terms are of the same size  this can be achieved by making all lists disjoint except for a small set of document ids that appear in all lists   and select a cache size that fits exactly k projections. we also assume that list it1 is significantly larger than all of the itu  say |it1|   1 몫 |e| 몫 |itu|. then there exists a vertex cover of g of size k iff there exists a selection of cached projections that allows the query trace to be executed with total cost less than |it1|. 
모we note that if all projections are of the same size and queries are limited to 1 terms  then the problem can be solved in polynomial time. on the other hand  the offline problem with 1 terms remains np-complete if we allow creation and eviction of projections during query execution  and if we charge a cost for the creation of projections. we discuss the online problem further below.
1	a simple greedy algorithm
모while in reality we do not have prior knowledge of the query sequence  the offline problem is nonetheless of practical interest since it can be used to make cache space assignments for the future based on analysis of recently issued queries. for this reason  we now describe a simple greedy algorithm for the offline problem  which in each step adds the projection to the cache that maximizes the ratio of additional savings in query processing and projection size. it can be implemented as follows:
1. for each query qi in the sequence q and each projection it뫸t1 with t t1 뫍 qi  create an entry  t t1 i |it뫸t1| |it|   |it뫸t1| . note that the last two fields are the size of the projection and the benefit when using it instead of the full list.
1. combine all entries with identical t  t1 into a single one  but with an additional field at the end  called the total benefit  that contains the sum of the benefits in the combined entries  and with the sequence of all query numbers i in the combined entries attached to the new entry.
1. load the entries into a heap that allows extraction of the element with maximum ratio of total benefit to projection size.
1. repeatedly extract an element and add it to the cache. if it does not fit  discard the element and choose another one until the heap is empty. after each extraction of an entry
  decrease the total benefit of all projections  t t1          for which t t1 t1 appear in a common query.
the size  and thus benefit  of a projection can be efficiently estimated using simple sampling techniques  and hence a scan of the inverted lists is not really required. ignoring these estimation costs  the above algorithm runs in time o 뷁lg 뷁   in the worst case  where  i.e.  the sum of the squares of the query sizes. in practice  this is a moderate constant times the number of queries since most queries are short.
1	the landlord algorithm
모we now consider the online problem. the projection caching problem is an instance of a weighted caching problem  where objects have arbitrary sizes and caching of an object results in savings that are independent of  or at least not linear in  their sizes. such problems have been studied  e.g.  in  1  1   where a class of algorithms called landlord is proposed and analyzed using competitive analysis. we note  however  that our problem comes with an additional twist reminiscent of view selection problems in databases  in that we could use either ia뫸b or ia뫸c in executing a query {a b c} but there is little benefit in using both. thus  a projection for a frequently occurring pair may actually not have much benefit since there may be even better projections available in the cache for most queries where it is applicable. landlord works as follows:
1. whenever an object is inserted into the cache  it is assigned a deadline given by the ratio between its benefit and its size.
1. if another object needs to be evicted to make room for a new one  we evict the element with smallest deadline dmin  and deduct dmin from the deadlines of all elements currently in the cache.
1. whenever an element in the cache is used  its deadline is reset to some appropriate value discussed later.
a note about step 1: instead of deducting dmin from all entries  the algorithm is best implemented by summing up all values of dmin that should have been deducted thus far  and taking this sum properly into account. thus  the algorithm is highly efficient. if in step 1 deadlines are reset to their original value  ratio between benefit and size   then the algorithm can be seen as a generalization of lru for weighted caching problems. in  1  1   the algorithm is shown to be competitive with an optimum solution  but the analysis does not carry over to our problem due to the above  twist . in the following  we will also experiment with several variations of the landlord approach that perform much better on our workload.
1.	experimental evaluation
모we now present our experimental setup and give some baseline results for the basic versions of the greedy and landlord algorithms. in subsection 1 we present and evaluate modified policies with improved performance  and subsection 1 discusses the cpu overhead of projection creation. finally  subsection 1 presents an evaluation over all three levels of caching.
모data sets and experimental setup: for our experiments we used a subset of 1 million pages selected at random from a crawl of about 1 million web pages crawled by the polybot web crawler  in october of 1. this subset size corresponds to a scenario where the pages are evenly distributed over a 1-node search engine  which is the typical setup in our lab. in this case  since projection caching occurs at each individual node  only one machine in the cluster was used. the uncompressed size of the pages was over 1 gb  and after duplicate elimination and indexing we obtained an inverted index structure of size about 1 gb. though current commercial engines index several billion pages  these are partitioned and replicated over thousands of machines. we believe that our setup of 1 million pages per node is a realistic scenario.
모queries were taken from a large log of queries issued to the excite search engine from 1 to 1 pst on december 1  1. for the experiments  we removed queries with stopwords and with words that do not appear in our data collection. the number of remaining queries is 1 with a total of 1 different words  and the average number of words per query is 1. we assume a result cache with infinite size on this query log; in general  we expect that result cache size and eviction policy are unlikely to be critical in terms of overall system design and resources.
모we created two different experimental setups to evaluate query processing costs. using one setup  we measured the disk access costs of the various policies in terms of the total number of 1 kb disk block accesses. we have found that this provides a reasonable estimate of the cost of our actual query processor  when using one or two disks and a fast cpu. we used another setup where we preloaded inverted lists into main memory to measure the cpu costs of the methods  which is important on systems with more i/o bandwidth. all experiments were run on a dell optiplex 1gx machine with a 1 ghz p1  1 gb of memory  and two 1 gb disks running linux.
모query characteristics: we first look at the distribution of the ratios and total costs for queries with various numbers of terms  by issuing these queries to our query processor with caching completely turned off. in figure 1  we see that even without result caching  nearly half of the total block access cost was spent on queries with five or more terms  although these queries represent only about 1% of all queries.

figure 1: distribution of frequencies and total costs for queries with different numbers of terms.
모next  we look at how this distribution changes as we filter out repeated queries using result caching. figure 1 shows the number of queries before and after result caching for different numbers of terms in the query. we see that the number of queries with few words is reduced significantly  while fewer queries with four or more terms are filtered out. thus  after result caching  an even higher percentage of the total block accesses will be spent on long queries  and the average cost per remaining query increases from about 1 to almost 1 blocks. we also ran some preliminary measurements on projection caching with infinite cache size  to estimate the maximum potential benefit from adding this feature. our results  omitted due to space constraints  showed that while only a small number of queries were completely covered by projections  meaning  for each term there was a projection that could be used instead of the complete list   many queries had at least one or two projections that can be used. this was particularly the case for longer queries  and thus we would expect projection caching to work well in combination with result caching.

figure 1: number of queries before and after result caching.
모results for the greedy algorithm: we now present results for the basic versions of the greedy and landlord algorithms. in all our experiments  we make sure to  warm up  all levels of caches by running over most of the query log and only measuring the performance of the last 1 queries  or some other number in some cases . the costs are stated as the average number of blocks scanned for each query that is not filtered out by result caching  without list caching which will further improve performance. thus  the baseline without projection caching is about 1 block accesses per query. the overall performance across all three caching levels is evaluated in subsection 1.
모in our first experiment  we used the greedy algorithm from the previous section on a window of 1 queries  the training window  directly preceding 1 queries that were measured  the evaluation window . thus  recent queries are analyzed by the greedy algorithm to allocate space in the cache for projections likely to be encountered in the future  and only these projections are allowed into the cache. there are two different ways in which this approach could be used:  1  after analyzing the queries in the training window  we could preload the projection cache with the projection selected by the greedy algorithm. this could be done say once a day during the night in a large bulk operation in order to improve performance during peak hours.  1  the second approach is to create the selected projections only when we encounter the corresponding pair in the evaluation window.
모from figure 1  we see that the performance of these two approaches is very similar across a range of cache sizes. the online method only benefits from projection caching the second time a pair is encountered in the evaluation window  since the projection

figure 1: block accesses per query for greedy projection caching with various cache sizes. zero cache size means no projection caching. shown are two curves  one for the case of precomputed projections and one where they are created online.
cache size1111111blocks / query1111111table 1: cost of online projection creation in 1kb block writes per query  for various amounts of cache space in gb.
is created during the first time. the other method benefits even on the first occurrence  but uses almost half the cache space for precomputed projections that are never used in the evaluation window. note that the cache size plotted in figure 1 is not the maximum cache size assumed by the greedy algorithm  but the amount of cache that is actually filled with projections  which is much lower than the size assumed by the greedy algorithm in the online case .
모we observe that even with only 1 gb cache size  less than 1% of index size   we already get a significant improvement to about 1 blocks per query. in the online case  we did not include the overhead due to creation of intersections in figure 1  but as shown in table 1 the number of blocks written out per query is fairly small. for the other case  we ignore the cost of preloading the projections. the results indicate that there is probably not too much gained from precomputing projections  and that an online approach is preferable. in fact  it is not difficult to improve the results for the online case by using a sliding window approach that avoids starting out with an empty cache at the start of each new window. however  as we show later  online policies based on tuning the landlord approach perform even better  and thus we omit discussion of further optimizations of the greedy approach.
모performance of basic landlord: in figure 1  we show results for the basic landlord algorithm where we reset deadlines to their original values whenever a cached projection is used again. we observe improved performance in terms of the number of blocks scanned per query compared to the greedy algorithm  although this is partly due to the warm cache at the start of the measurement period. however  the amount of block writes in landlord  shown in the second graph on top of the read costs  is quite high since a large number of projections are created and then quickly evicted from the cache without ever being used. once we take this overhead into account  the basic landlord approach does not provide any benefit for most cache sizes compared to not using projection caching.
optimized landlord policies
모we now consider how to engineer the basic landlord policy to improve performance. we present and evaluate two main ideas:모in the next subsection  we present several refinements of the basic landlord approach that dramatically reduce the overheads of the approach while also further improving block read costs. the main idea is that we need an appropriate cache admission policy  cache that are being renewed  and  1  limiting the number of projections that are generated by not inserting every possible projection on the first encounter. due to space constraints  we can only give a sample of representative experimental results.
모landlord with 붸 parameters: in the basic landlord approach a projection has its deadline reset to the original value whenever it is used again. in order to give a boost to projections that have already proved useful  versus newly encountered pairs of terms  we decide to give a longer deadline to projections that are being reset.  thus  a tenant that renews gets a longer lease than a tenant that just moves in.  in particular  a renewed projection gets its original deadline plus a fraction 붸 of its remaining deadline. in addition  we experimented with keeping a different fraction 붸1 of the remaining deadline on the second and subsequent renewals. we experimented with a number of values for 붸 and 붸1 and found very good performance for 붸 = 1 and 붸1 = 1  though many other values between 1 and 1 achieve similar results.
모cache admission policies: we experimented with several techniques for limiting the number of projections that are created and inserted into the cache. a simple approach is to never insert a projection for a pair of terms that has not been previously encountered  say  in the last few hours . a more refined rule would also take into account the cost of projection creation and the amount of benefit that results if the projection is used instead of the full lists.
모after some experimenting we arrived at the following policy. we choose a window of the previous t queries  for which we maintain statistics about the encountered queries. a projection ia뫸b is only inserted into the cache if the corresponding pair of terms has occurred more than

figure 1: comparison of no projection caching  leftmost bar   1 gb cache size  next 1 bars   and 1 gb cache size  rightmost 1 bars   for various refinements of landlord. for each cache size  we show the read cost  solid portion of bar  and write cost  outlined for four policies from left to right:  a  basic landlord   b  with 붸 = 1 and 붸1 = 1   c  same with insertion only on second encounter of a pair  and  d  with alphas and the cache admission policy described above. for the last case  we choose b = 1  resulting in negligible  in fact  invisible in this chart  write cost.
모the results of these optimizations are shown in figure 1  which indicate that fine-tuning of the policies is extremely important for our problem. the best approach based on the above rule performs slightly more block reads on query processing  but is extremely conservative about inserting projections and thus minimizes write costs into the cache. in the next subsection  we show that this also results in small cpu overhead for piggybacked projection creation during query processing.
모a hybrid method: we also experimented with a hybrid between landlord and the greedy method that shows promising results and should perform even better though we have not completely engineered out all bottlenecks. in the hybrid  we use a sliding window approach where periodically  e.g.  every 1 queries  we use the greedy algorithm to analyze a certain window of recent queries  say  1 queries . any projection chosen by the greedy algorithm is marked as protected: once it is cached it cannot be evicted until it is unprotected in another run of the greedy algorithm. we also simultaneously run landlord with optimizations to utilize any cache space not claimed by the greedy algorithm. we experimented with various ratios of cache size used by the greedy method versus total cache; details are omitted due to space constraints.
1	cpu overhead of creating projections
모we now address the cpu overhead of creating projections in our query processor. to do so  we need to understand how the query processor generates intersections of inverted lists during normal query execution. this is done in a document-at-a-time manner by simultaneously scanning all lists. more precisely  we first scan an element from the shortest list  and then search forward for a matching element in the second-shortest list. if such an element is found  we search forward in the next list  otherwise we return to the shortest list. for queries with more than two or three keywords  it is quite common that many of the forward searches into the longest list can skip several blocks at a time  given an appropriate indexing scheme. however  it is rare for skips to be long enough to improve disk performance on modern hard disks  since each inverted list is laid out sequentially on disk for optimized scanning. however  skipping blocks does result in savings in list decoding since we can avoid decoding the entire list  assuming a blocked coding scheme .
모however  when generating a projection  say between the longest and the shortest list  we often have to decode almost all the blocks  resulting in higher cpu cost than normal query processing. the additional cpu cost is related to the size of the created projection  and thus policies that decrease the number of block writes for created projections also tend to do well in terms of cpu performance.

figure 1: cost per query for optimized landlord  relative to a query processor without projection caching  1% . we show the number of tuples encoded and decoded  cpu time  and the number of disk blocks accessed. we also plot the cpu cost under the assumption that projection generation is free; for small values of the target overhead this is very close to the total cpu cost  indicating that projection generation can indeed be done en passant and essentially for free during query execution.
모in figure 1  we show the cost of query processing with optimized projection caching versus a query processor without projection caching  measured by executing queries on memory-resident inverted lists. we see that policies with low b  i.e.  that are very conservative about generating projections  perform well in terms of cpu cost  and that cpu cost closely correlates with the total number of tuples encoded and decoded. projection caching performs additional decoding of tuples during creation of projections  but saves decoding later when the projections are used in other queries. overall  we observe a 1% decrease in cpu cost  implying a 1% increase in query throughput in a cpu-limited system  while the benefit for disk-bound systems is even higher. we experimented with several block sizes for the blocked compression scheme  and observed similar relative behavior from a few hundred bytes to several kb.  in absolute terms  the smaller block sizes result in lower cpu cost for query processing as they decode fewer postings overall  but the relative benefit of projection caching is about the same. 
1	evaluation of multi-level caching
모we now evaluate query processing performance over all three levels of caching. as suggested in  we use lru for list caching. inverted lists corresponding to projections are treated by the list caching mechanism just as any other inverted list  this turns out to perform best . for projection caching we use the optimized version of landlord from the previous subsection  with negligible overhead for generating projections online. note that in the following  we report the average number of block reads over all queries  including those filtered out by result caching. this allows a comparison over all three levels of caching.

figure 1: number of block reads per query  for the following seven schemes  from left to right : no caching  result caching  result plus projection caching  result plus list caching and all three levels of caching with a 1 mb list cache  and result plus list caching and all three levels of caching with a 1 gb list cache.
모without any caching  about 1 blocks are read for each query; this is reduced to less than 1 blocks using just result caching  with each surviving query actually having a cost of 1 blocks as shown in figure 1 . this is brought down to less than 1 blocks per query by adding projection caching. using result caching and list caching with a 1 mb list cache  we get a performance of about 1 blocks  which is reduced to about 1 blocks by adding projection caching. note that a cache of 1 mb is about 1% of the total index size of over 1 gb  and thus an example of a mainly disk-bound setup. on the other hand  when we have a list cache that can hold almost 1% of the total index  shown in the two rightmost bars   then disk access decreases to a very low level  which means that cpu becomes the primary bottleneck. in this case  projection caching increases disk accesses but reduces cpu work significantly as shown in the previous subsection  which is a desirable outcome for this case.  essentially  if disk is not the bottleneck  it is better to fetch a small projection from disk than to use a much larger inverted list that is already in memory. 
1.	concluding remarks
모in this paper  we have proposed a new three-level caching architecture for web search engines that can improve query throughput. the architecture introduces a new intermediate caching level for search engines with and query semantics  including essentially all current major engines  that can exploit redundancies in the query stream that are not captured by result and list caching in two-level architectures. our experimental evaluation on a large query log from the excite search engine showed significant improvements in performance due to the extra level of caching. however  actual performance is highly dependent on a good selection of caching policies and the system bottlenecks in the particular architecture.
모there are several open questions that arise from this work. in particular  it would be interesting to perform a more formal study of the offline and online intersection caching problems defined in this paper. for example  one could study approximation results for the greedy heuristic  or competitive ratios for the landlord approach in our scenario  or look at the case where we include the cost of generating projections into the corresponding weighted caching problem. another interesting theoretical question concerns the performance of caching schemes on certain classes of input sequences  e.g.  sequences that follow zipf distributions on term frequencies.
모it appears that the simple lru scheme previously also used in  is actually not the best possible policy for list caching. in fact  we have recently seen interesting improvements based on adaptations of the landlord algorithm with 붸 and 붸1 parameters to list caching. we note that this approach is also related to recent work by megiddo and modha  and others on caching policies that outperform lru in a variety of applications. we are currently studying list caching policies in more detail.
모on the more practical side  we expect that additional tuning of the caching policies and the availability of larger traces would show some additional gains  and we also plan to fully integrate intersection caching into our existing high-performance query processor. another open question concerns the relationship between intersection caching and specialized index structures for common phrases.
모finally  it would be very interesting to evaluate combinations of caching and pruning techniques in future work. we believe that integrating projection caching into pruning techniques such as  should not be difficult for two reasons: first  as discussed a projection can be treated just as any other inverted list in the index. second  we observed that under a good choice of policies and parameters  the overhead of generating projections is tiny  and would still be small even when aggressive pruning brings down the baseline cost. we note that many search engines appear to use the distance between the query terms in a page as an important factor in ranking. to our knowledge there is no published work on how to apply pruning to such types of ranking functions  which are not based on a simple combination of the scores for different terms.
