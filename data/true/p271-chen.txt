over the last decades  improvements in cpu speed have outpaced improvements in main memory and disk access rates by orders of magnitude  enabling the use of data compression techniques to improve the performance of database systems. previous work describes the benefits of compression for numerical attributes  where data is stored in compressed format on disk. despite the abundance of stringvalued attributes in relational schemas there is little work on compression for string attributes in a database context. moreover  none of the previous work suitably addresses the role of the query optimizer: during query execution  data is either eagerly decompressed when it is read into main memory  or data lazily stays compressed in main memory and is decompressed on demand only.
　in this paper  we present an effective approach for database compression based on lightweight  attribute-level compression techniques. we propose a hierarchical dictionary encoding strategy that intelligently selects the most effective compression method for string-valued attributes. we show that eager and lazy decompression strategies produce suboptimal plans for queries involving compressed string attributes. we then formalize the problem of compressionaware query optimization and propose one provably optimal and two fast heuristic algorithms for selecting a query plan for relational schemas with compressed attributes; our algorithms can easily be integrated into existing cost-based query optimizers. experiments using tpc-h data demonstrate the impact of our string compression methods and show the importance of compression-aware query optimization. our approach results in up to an order speed up over existing approaches.
1. introduction
　over the last decades  improvements in cpu speed have outpaced improvements in main memory and disk access

 supported in part by nsf grant iis-1  nsf grant eia-1  and a gift from at&t corporation.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
acm sigmod1 may 1  santa barbara  california  usa copyright 1 acm 1-1/1...$1.
speeds by orders of magnitude . this technology trend has enabled the use of data compression techniques to improve performance by trading reduced storage space and i/o against additional cpu overhead for compression and decompression of data. compression has been utilized in a wide range of applications from file storage to video processing; the development of new compression methods is an active area of research.
　in a compressed database system  data is stored in compressed format on disk and is either decompressed immediately when read from disk or during query processing. compression has traditionally not been used in commercial database systems because many compression methods are effective only on large chunks of data and are thus incompatible with random accesses to small parts of the data. in addition  compression puts extra burden on the cpu  the bottleneck resource for many relational queries such as joins . nonetheless  recent work on attribute-level compression methods has shown that compression can improve the performance of database systems in read-intensive environments such as data warehouses  1  1 .
　the main emphasis of previous work has been on the compression of numerical attributes  where coding techniques have been employed to reduce the length of integers  floating point numbers  and dates  1  1 . however  string attributes  i.e.  attributes declared in sql of type char n  or varchar n   often comprise a large portion of the length of a record and thus have significant impact on query performance. for example  the tpc-h benchmark schema contains 1 attributes  out of which 1 are string-valued  constituting 1% of the total database size. surprisingly  there has not been much work in the database literature on compressing string attributes. classic compression methods such as huffman coding   arithmetic coding   lempel-ziv  1  1   the basis for gzip   and order-preserving methods  all have considerable cpu overhead that offsets the performance gains of reduced i/o  making their use in databases infeasible . hence  existing work in the database literature employs simple  lightweight techniques such as null suppression and dictionary encoding  1  1 . this paper contributes such an effective and practical database compression method for string-valued attributes. our method achieves achieves better compression ratios than existing methods while avoiding high cpu costs during decompression.
　an important issue in compressed database systems is when to decompress the data during query execution. traditional solutions to this problem consisted of simple strateselect sname  s comment  lshipinstruct  l comment
from	supplier  lineitem
where ssuppkey = l suppkey and
s comment    l shipinstruct
orderby sname  l comment
figure 1: example query
gies  while we view this problem in the larger framework of compression-aware query optimization. in the following we survey well-known and new strategies for decompression in query plans. then we show for an example query how efficient query plans can only be generated by fully integrating query optimization with the decision of when and how to decompress.
　early work in the database literature proposed eager decompression whereby data is decompressed when it is brought into main memory . eager decompression has the advantage of limiting the code changes caused by compression to the storage manager. however  as graefe et al. point out  eager decompression generates suboptimal plans because it does not take advantage of the fact that many operations such as projection and equi-joins can be executed directly on compressed data .
　another strategy is lazy decompression whereby data stays compressed during query execution as long as possible and is  explicitly  decompressed when necessary  1  1 . however  this decompression can increase the size of intermediate results  and thus increase the i/o of later operations in the query plan such as sort and hashing. westmann et al. suggest explicitly compressing intermediate results   but as pointed out by witten et al.   compression is usually quite expensive and can wipe out achievable benefits. we assume in the remainder that compression never occurs during query execution and that an attribute once uncompressed will stay uncompressed in the remainder of a query. we contribute a new decompression strategy that we call transient decompression. in transient decompression  we modify standard relational operators to temporarily decompress an attribute x  but keep x in compressed representation in the output of the operator. we refer to such modified operators that input and output compressed data as transient operators.
　note that since numerical attributes are cheap to decompress  transient decompression usually outperforms lazy and eager decompression for numerical attributes. unfortunately  for string attributes the choice between the three decompression strategies is not so easy. and query plans involving compressed string attributes must be chosen judiciously. on the one hand  transient decompression on string-valued attributes can result in very significant i/o savings because  1  string attributes are typically much longer than numerical values  and  1  string attributes are often easy to compress  e.g.  string attributes with small domains can be compressed to one or two bytes . on the other hand  decompressing string attributes is much more expensive than decompressing numerical attributes  and transient operators may need to decompress the same string value many times  e.g.  consider a nested loops join where the join attribute is a string . the following example illustrates that choosing the right query plan is an important decision.
figure 1 shows an example query from the tpc-h benchmark . the query joins the supplier and lineitem relations on a foreign key; the query includes an additional selection condition involving two string attributes. the string attributes scomment lshipinstruct l comment and s name are compressed using attribute-level dictionary compression with different dictionaries; none of the compression methods is order-preserving except the method used for sname  section 1 describes our compression methods in detail . thus  during the execution of the example query  the attributes
scommentand lshipinstructneed to be decompressed for computing the join and lcommentneeds to be decompressed for the sort.
　we ran this query on a modified version of the predator database management system  where we implemented the eager and lazy strategies  as well as variants of the transient decompression strategies  a detailed description of our experimental setup can be found in section 1 .
　table 1 reports the execution time of different query execution plans. plans 1 to 1 use a block-nested-loops join followed by a sort.1 plans 1 uses eager decompression and plan 1 uses lazy decompression; the running times were 1 and 1 seconds  respectively. plan 1 explicitly decompresses attributes for the join operator and uses transient decompression for the sort operator  which improves the running time by about a factor of two to 1 seconds. the reason for this improvement is that the size of the intermediate results  the input to the sort operator  in plan 1 is significantly smaller than the intermediate results in plan 1 and 1. in plan 1  the long string attribute lcomment stayed compressed  whereas the attribute is already decompressed in plans 1 and 1. since the performance of the sort operator is very sensitive to the size of the input relation  keeping lcomment compressed leads to better overall performance  the sort took 1 seconds in plan 1 versus 1 seconds in plan 1 .
　if we choose transient decompression for both the join and the sort operators  the execution time jumps to 1 seconds  as shown in plan 1 in table 1. plan 1 keeps the join attributes scomment and lshipinstruct compressed in the intermediate results  leading to better performance for the sort operator  the sort time drops from 1 seconds to 1 seconds . however  the nested-loops join needs to test the join condition for pairs of  scomment lshipinstruct  values. thus  transient decompression is invoked a quadratic number of times in the sizes of the input relations  leading to a prohibitive cpu overhead  the join time increases from 1 seconds to 1 seconds . this is an extreme case of the classic  cpu versus i/o  trade-off  demonstrating that transient operators should not be deployed arbitrarily.
　whereas plans 1 use block-nested-loops join  plan 1 uses a sort-merge join  which is less efficient in the view of a traditional optimizer  but plan 1 also uses transient decompression for both the join and the sort operator. surprisingly  its execution time drops to 1 seconds  more than a factor of two improvement over the previously best plan  plan 1 . although plan 1 takes more time for processing the join

1
 predator contains block-nested-loops and sort-merge joins. a traditional optimizer enhanced with a cost model takes into account both i/o benefits of compression and cpu overhead of decompression chose a block-nested-loops join because the supplier relation fits into the buffer pool  but the lineitem table does not  thus block-nested-loops join has lower overall cost.
table 1: execution times  in seconds  for the query in figure 1  different decompression strategies 
plansstrategytotal timejoin timesort timeplan 1eager with bnl-join11plan 1lazy with bnl-join11plan 1bnl-join: explicit; sort: transient11plan 1bnl-join: transient; sort: transient11plan 1sm-join: transient; sort: transient11 1 seconds versus 1 seconds for plan 1   it keeps the intermediate results compressed. this lowers the cost for the sort operator  1 seconds versus 1 seconds for plan 1   since the intermediate results of plan 1 fit into the buffer pool. plan 1 illustrates a central point: query optimization in compressed database systems needs to combine the search for optimal plans with the decision of how and when to decompress.
　in this paper  we study the problem of compression-aware query optimization in a compressed database system. we make the following contributions:
  we propose a hierarchical dictionary encoding strategy that intelligently selects the most effective compression methods for string-valued attributes.  section 1 
  we formalize the problem of compression-aware query optimization  and propose three query optimization algorithms: a provably optimal and two fast heuristic algorithms. our algorithms can easily be integrated into existing cost-based optimizers.  section 1    we present an extensive experimental evaluation using a real database system on tpc-h data to show the importance of compression-aware query optimization. the presence of string attributes makes query processing particularly sensitive to the choice of plan. our methods result in up to an order of magnitude speedup over existing strategies.  section 1 
we discuss related work in section 1 and conclude in section 1.
1. database compression
　the nature of query processing in databases imposes several constraints in choosing a suitable database compression method. first  the decompression speed must be extremely fast. since we intend to apply transient operators  the query processor may need to decompress the data many times during query execution. second  only fine-grained decompression units  e.g.  at the level of a tuple or a attribute  are permissible in order to allow random access to small parts of the data without incurring the unnecessary overhead of decompressing a large chunk of data.
　common compression methods include lempel-ziv  1  1   huffman coding   arithmetic encoding   and predicative coding . unfortunately  the decompression speeds of these methods are not fast enough; for example  the performance difference between lz and simple methods  like offset encoding  encoding a numerical value as the offset from a base value  is an order of magnitude . hence  we limit our consideration to lightweight methods. dictionarybased encoding involves replacing each string s by a key value k that uniquely identifies s; a separate table called the dictionary stores the necessary  associations. adaptive compression methods  such as lz  build the dictionary on-the-fly during compression. however  as pointed out by chen et al.  and goldstein et al.   adaptive compression methods require large chunks of data as inputs to achieve good compression ratios. even when adaptive methods are applied on a page-level they are insufficient for our needs because access to a single tuple requires decompressing the entire page. to allow fine-grained decompression  only methods that are static  i.e.  the dictionary is fixed in advance  or semi-static  i.e.  the dictionary is built during preprocessing and fixed thereafter  are acceptable.
　since the attributes of a relational database typically consist of heterogeneous attribute types  the most suitable compression method for each attribute may be different  and should be chosen separately. following kossman et al.   we compress numerical attributes by applying offset encoding to integers and by converting 1-byte double-precision floats to 1-byte single-precision floats if there is no loss in precision. for string-valued attributes  we propose a simple hierarchical semi-static dictionary-based encoding  which we describe next.
　existing work has applied simple dictionary-based encoding to the set of strings in an attribute  i.e.  one dictionary entry for each distinct string . but repetition in string attributes often exists at different levels of granularity  and applying dictionary encoding at the appropriate level can greatly improve the compression ratio. we thus consider dictionary encoding at the whole-string level  the  word  level  e.g.  english text   the prefix/suffix level  e.g.  urls and e-mail addresses   and adjacent-character-pair level  e.g.  phone numbers .
　given this hierarchy of dictionary encodings  we can determine the level most suitable for each attribute separately as follows. each level of granularity  has an associated substring unit u  e.g.  whole-string  word  etc. . let  be the set of distinct unit u substrings of a given attribute  e.g.  the set of words  and let n be the cardinality of w  e.g.  the number of distinct words . let n be the total number of  non-distinct  substrings  e.g.  the number of word occurrences including duplicates . we choose the level  that minimizes where

 denotes the length of the  unit u  substring  and is the length of the key value  in bytes . this is the size of the encoded attribute plus the size of the dictionary. as we demonstrate in section 1  hde is very effective for string-valued data  achieving higher compression than existing compression methods.
1. compression-aware query optimization
　section 1 illustrated that the difference between the use of simple heuristics for choosing query plans suing decompression and the use of compression-aware optimization is significant. this section starts with a formal introduction of the query optimization problem for compressed databases  section 1 . we then briefly discuss the relationship of compression-aware query optimization with the problem of query optimization with expensive predicates  section 1 . we then propose new query optimization algorithms in sections 1 and 1.
1 problem definition
　we adopt the notion of properties  also called tags  to describe which attributes are compressed in intermediate results of a plan. the property concept extends the idea of an interesting order from selinger et al. . we associate with each relation r a so-called tag  denoted tag r   which contains the set of attributes in r that are compressed. the tag of a plan p  tag p  is the tag of the output relation of p.
　let us extend the physical algebra with a decompression operator dx that decompresses a set of attributes x. the decompression operator takes as input a relation r whose tag is a set of attributes x that is a superset of x: x   x. its output is the same relation but with a tag that is reduced by the decompressed attributes: x   x.
　we also extend the physical algebra with transient versions of the traditional operators. a traditional physical algebra operator takes as input relations r1 ...  rk  each with an empty tag  and produces an output relation r  also with an empty tag. the transient version ot of operator o takes as input relations r1 ...  rk with possibly non-empty tags and produces an output relation r with a possibly non-empty tag x  which is the union of the tags of r1 ...  rk minus the set of attributes that were dropped by o. if an attribute x appears in the output relation r of operator ot and x was compressed in the input  then x is also compressed in r and thus x （ tag r . vice versa  if x was not compressed in the input it will not be compressed in the output. thus operator ot decompresses attributes only transiently as necessary  while attributes compressed in the input remain compressed in the output.
　we can now characterize eager and lazy decompression. in eager decompression  every query plan contains decompression operators directly after each base relation scan. thus all the tags of the intermediate relations are empty because we decompress all attributes directly when the base relations are read into memory. in lazy decompression  we insert a decompression operator dx directly before a physical algebra operator o if o requires access to the attributes in x  which have not been decompressed yet. thus we delay the decompression of each attribute as much as possible.
　in order to define the search space of compression-aware query plans  let us first introduce the notion of a query plan. a query plan q has two components:  1  a query plan structure  v e   consisting of nodes v and edges e   v 〜 v   and  1  a query plan tagging  which is a function tag that maps each node v （ v onto the set of attributes tag v  that are still compressed in v's result. the internal nodes of the tree are instances of operators in the physical algebra of the database system  including decompression operators and transient operators   and the leaf nodes are base rela-
plan 1
sortt1
bnlt1
d {s c  s n} d {l c l s} 
slplan 1sortt1plan 1sortt1	d {l c} 	bnlt1	bnlt1
d {s c} d {l s} 
       s plan 1l
t1       s plan 1l
t1sortsort bnlt1 smt1
d {s c} d {l s} 
	s	l	s	l
figure 1: the compression-aware query plans listed in table 1. s represents supplier table and l represents lineitem. tags t1 =    t1 = {s name}  t1 = {s name l comment}  t1 =
{s name l comment l shipinstruct s comment}.
tion scans. edges in e lead from children nodes v1 ...  vk to parent node v  indicating that the output of operators v1 ...  vk is the input of operator v. the tag of each node v （ v   tag v   represents the set of compressed attributes in the output relation of the query plan fragment rooted at node v.
　we say that a query plan is consistent if the tagging of its nodes matches the actual changes of tags imposed by the operators in the tree. let v be a node in the tree with associated output relation r. then the tags of v satisfy the following properties:  1  tag v  is a subset of the attributes in r.  1  if v is a leaf node  a base relation scan   then tag v  equals the set of attributes that is compressed in the associated base relation.  1  tag v  =   if v is the root of the tree  the output of the query is decompressed .  1 
if attribute x is an attribute in r  but    then
  for all ancestors  in the query tree  once an attribute is decompressed  it stays decompressed in the remainder of the query plan .  1  if attribute x is in the output of node v and x is in one of the tags of v's child nodes  then x is in the tag of v unless v is a decompression operator v = dx that decompresses x  x （ x .
　thus we can  informally  define the problem of compression-aware query optimization as the search for the leastcost consistent query plan. note that the space of traditional query plans  with only empty tags  partitions the search space of compression-aware query plans into equivalence classes. we can map each compression-aware query plan to a traditional query plan by deleting all tags and all explicit decompression operators.
　as an example  consider the query plans from table 1  which were discussed for the query in example 1 from section 1. figure 1 shows these query plans. the tags of each relational operator are specified as superscripts  the tags of the root nodes of each query plan are omitted because they must be the empty set . transient operators are displayed in italic. decompression operators are placed between relational operators.
　suppose there are m attributes in the base tables and that we consider the space of consistent query plans with n internal nodes. any compression-aware plan q is fully specified by the placement of decompression operators because the tagging of transient operators is determined by the tagging of its children. for each decompression operator  there are at most n possible placements in the query plan; thus given a search space of size s for a traditional optimizer  the size of the search space of the compression-aware query optimization problem is o s，nm . for a system r-style optimizer that searches only left-deep plans  the search space size of the compression-aware query optimization problem is thus o n ， 1n 1 ， nm . in the remainder of this paper  we investigate how to make optimizers based on dynamic programming compression-aware.
1 compression and expensive predicates
　our optimization problem bears some analogy to the work on optimizing queries with expensive predicates  such as user-defined procedures  1  1 . the analogy is that a decompression operator can be thought of as an expensive predicate with 1% selectivity and a resulting increase in the tuple length. the traditional heuristic of pushing predicates down towards the leaves of the query plan does not apply when a predicate incurs a significant cost during query processing  since there is a tradeoff between the i/o savings by pushing down a predicate and the extra cpu processing of doing so. similarly  the pulling up  delaying  of a decompression operator must weigh the i/o savings of keeping data compressed against the cpu overhead of transient decompression. chaudhuri et al. propose a polynomial-time algorithm for placing expensive predicates in a query plan assuming that the cost formulas for relational operators are regular .
　for example  suppose r1 and r1 are two input relations to a block-nested-loops join. suppose  r1  and  r1  are the number of pages of r1 and r1  and b is the number of pages in the buffer pool. then the cost of the join equals:
 r1  ，  r1 /b +  r1  =  r1  ，   r1 /b + 1  + 1
that is  the cost can be expressed in the form of  r1 ，a+b  where a and b are constants irrelevant to the placement of predicates on r1  the placement of predicates will only change the input size  r1  . as an expensive predicate σ is applied on input r1  the size of input becomes  and the cost becomes
 
thus both factors a and b remain constant.
　now consider the cost of a block-nested-loops join operator in our problem of placing decompression operators  and assume that the join needs to decompress attribute x in relation r1. let us consider the two cases of  1  explicitly decompressing the attribute x before the join  and  1  executing the operator as an transient operator. in case  1   the input size of r1 has increased to  due to the decompression. hence  the cost of the join is as follows:
.
assuming that our cost formulas would be regular  we can calculate the factors a =   r1 /b + 1  and b = 1  both independent of r1. now assume that we  pull  the decompression operator on a over the join. join attribute a needs to be decompressed transiently n1 ，n1 times  if there are n1 tuples in r1 and n1 tuples in r1. assuming that the unit cost of decompression is a  usually small  constant d  the cost of the join becomes:

　note that the size of r1 has decreased to  r1c . comparing with the previous cost formula  we observe that the factor a stayed constant  but b changed from 1 to n1，n1，d. thus the cost formulas for transient operators are no longer regular  and the polynomial algorithm proposed by chaudhuri et al. cannot be not applied.
　note that if we exclude transient decompression  we can reduce our problem of placing decompression operators to the problem of expensive predicate placement. a full elaboration of this reduction is beyond the scope of this paper; in addition we showed in section 1 that transient decompression results in query plans with very attractive costs in many cases. thus we concentrate in the remainder of this section on the case where transient decompression is included.
1 finding the optimal plan
　in this section  we describe a query optimization algorithm based on dynamic programming which always finds the optimal plan within the space of all left-deep query plans. the following two observations serve as the basis of our dynamic programming algorithm:
  critical attributes. we only need to decompress two types of attributes:  1  attributes that are involved in operations that cannot process compressed data directly  and  1  attributes that are required in the output of the query. we call such attributes critical attributesl they are the attributes we need to consider during query optimization.
  pruning of suboptimal plans. assume we are given two query plans p and q that represent the same selectproject-join subexpressions of a given query and assume that p and q have the same physical properties  such as sort orders of the output relation . it is easy to see that if tag p  = tag q  and cost p    cost q   then we can prune plan q and all its extensions from the search space without compromising optimality.
　figure 1 shows the opt algorithm  our dynamic programming algorithm for finding the optimal plan. to simplify the presentation  we only consider joins; opt can be easily extended to plans including other operators  e.g.  a sort operator is just a degenerated case of join .1
　the algorithm selects the join order  access methods  and join methods exactly in the same way as the system r optimizer. the main difference is that an optimal plan needs to be stored for each distinct tag t of each intermediate join result s. note that the tagging of a plan determines the placement of decompression operators  and whether the operators in the query plan are transient operators or work on attributes that are already uncompressed. the algorithm enumerates bottom-up each possible join combination  lines 1   but at the same time also enumerates every possible tag that a query plan fragment can be labeled with  lines 1 ; the set of tagged plans is stored in optplan.

opt algorithm
input: a set of relations r1 ...  rn to be joined
output: the plan with the minimum cost
 1  initialize each r1 ...rn's tag with the subset of critical attributes compressed in ri 1 ＋ i ＋ n.
 1  for i := 1 to n do
 1  for all s   {r1 ...rn} s.t. ||s|| = i do
 1  initialize array bestplan to a dummy plan with infinite cost
 1  for all rj  sj s.t. s = {rj} “ sj and {rj} ” sj =   do
 1  for all plans p stored in optplan sj  do
 1  t = tag p  “ tag rj 
 1  for all
 1  q := genjoinplan p rj t  
 1  iffi
 1  endfor endfor endfor
 1  copy plans in bestplan to optplan s 
 1  endfor endfor
 1  finalplan := a dummy plan with infinite cost.
 1  for all plans p （ optplan {r1 ... rn}  do
 1  if  complete cost p    cost finalplan   finalplan := completed plan of p fi endfor
 1  return  finalplan figure 1: opt algorithm for finding the optimal plan.　in line 1 we loop over the set of existing query plans for the join of i   1 relations  called sj  with different tags  creating the largest possible tag for the resulting relation in line 1. lines 1   1 explore all possible ways to insert decompression operators before the join while maintaining the best possible plan for each possible output tag by calling subroutine genjoinplan  shown in figure 1. line 1 stores the currently best plans for each possible tag in optplan  our  memory  for the dynamic programming. lines 1 select the final plan with overall lowest cost. note that the tag of the final result of the query has to be the empty set  thus function completecost   potentially introduces decompression operators at the end of query plans whose tag is not the empty set.
in example 1  there are four critical attributes: lcomment 
lshipinstruct  s name  and s comment. thus 1 = 1 different output tags will be generated for the join node  and 1 differently tagged plans will be stored as inputs to the sort operator. algorithm opt returns plan 1 as the optimal plan. plan 1 will be pruned as we enumerate plans for the join node because the join fragment of the plan using transient decompression has the same tag  t1  as the join fragment of plan 1  but with higher cost  see table 1 .
　showing that algorithm opt finds the plan with the overall least cost within the space of left-deep plans is straightforward. we omit the details here due to space constraints. to study the complexity of opt  let m be the number of critical attributes and n be the number of relations in the query. the system r optimizer has space complexity o 1n  and time complexity o n ，1n 1 . in the worst-case  over m critical attributes  we may have to store as many as 1m possible tags  each with an optimal subplan. thus  the space complexity of the opt algorithm is o 1n，1m . at each step when we enumerate plans joining an existing plan p with a relation rj  if there are  attributes compressed in p and rj  then there can be at most 1 different output tags. in the worst case  the input has m critical attributes in the input  thus there are at most m cases when  attributes are compressed in the input. therefore  the total number num of plans enumerated for each relational operator is:
 
and the total time complexity of opt is o n ， 1n 1 ， 1m .
1 heuristic algorithms
　the opt algorithm can be easily integrated into an existing system r-style optimizer. however  the time and space complexity of the opt algorithm increases by a factor that is exponential in m  the number of critical attributes. in this section  we propose two heuristic algorithms with sharply reduced space and time complexity.
1.1 two-step
　our first algorithm allows for an easy integration with existing system r-style dynamic programming query optimizers. if we assume that the plan p returned by a traditional query optimizer is structurally close to the optimal plan  then we can use p to bootstrap a subsequent placement of decompression operators  thus transforming the traditional plan with empty tags into a fully tagged plan.
　the two-step algorithm first generates a traditional query plan p with empty tags  and then in a second step executes a degenerated version of algorithm opt  which enumerates all possible taggings of p while maintaining join order  join methods  and access methods from the first step. due to the orthogonality of the two steps  the space complexity of twostep is o 1n +1m  and the time complexity of two-step is o n ， 1n 1 + n ， 1m  in example 1  a traditional optimizer returns a plan with a block-nested-loops join with supplier as the outer table. two-step will then find the optimal decompression strategy for that plan  resulting in plan 1  see figure 1 .
procedure genjoinplan 
input: query fragment p  base relation rj  tag t
output: physical algebra join plan q with output tag t and suitable decompression operators  1  q = a dummy plan with maximal cost.
 1  for each possible join method j do
 1  generate a plan q that joins p and rj with j as the join method
 1  add a decompression operator	  to	between p and the join node.
 1  add a decompression operator	  to	between rj and the join node.
 1 
 1  iffi endfor
 1  return qfigure 1: algorithm genjoinplan: searches the space of physical join methods for a given plan.1.1 min-k
　the min-k algorithm is based on the opt algorithm from section 1. it uses the following two heuristics to reduce the search space:
　heuristic 1: for an intermediate query plan fragment  instead of storing plans for each possible tagging of the output relation  we only store the k plans with the least cost  change line 1 in figure 1 .
　heuristic 1: instead of considering every possible tagging of the output relation of an operator  see loop lines 1 in figure 1   we only consider the following two taggings t1 and t1: t1 = tag p  “ tag rj   and t1 =  tag p  “ tag rj     x  where x is the minimal set of attributes that needs to be decompressed for the join method to perform the join on uncompressed attributes. tagging t1 makes the join operator a transient operator without inserting any decompression operators  whereas t1 inserts decompression operators for attributes x （ x that are required in the join. the intuition for this heuristic is that transient decompression usually helps for i/o intensive join operators  whereas for cpu intensive join operators  explicitly decompressing all join attributes can avoid prohibitive decompression overhead during join processing.
　in the min-k algorithm  we store at most k possible tags  and thus different plans  for each query plan operator. thus  the space complexity of min-k is o 1n ， k . at each step we enumerate plans joining an existing plan p and a relation rj. since rj is a base table with one unique tag  the set of attributes compressed in rj   there are at most k possible tags in the inputs. hence  there are at most 1k output tags and corresponding extended plan fragments enumerated. therefore  the total time complexity is o n ， 1n 1 ， 1k .
　as an example  assume that k = 1 in example 1. for the join node  min-k will enumerate two tags  t1 and t1 in figure 1 . thus  two query plan fragments will be stored  one as the join fragment of plan 1 with tag t1  the other as the join fragment of plan 1 with tag t1. for the sort node  min-k enumerates four possible tags: t1  t1 as t1   {lcomment}  t1  and t1 {l comment}. min-k returns plan 1 as the plan with least cost.
1. experiments
　this section presents an experimental evaluation of  1  the new hde compression strategy for string attributes and  1  our new query optimization algorithms. we start with a description of our experimental setup in section 1. section 1 presents a short evaluation of hde  and section 1 describes and evaluation of our algorithms for compressionaware query optimization.
1 experimental setup
　we implemented the hierarchical dictionary encoding  hde  compression strategy proposed in section 1 in the predator database system . we modified the query execution engine to run queries on compressed data. we made the following two changes to our cost model. first  we take the effect of compression on the length of records into account by estimating the tuple size of intermediate results based on the tags associated with each operator. second  we added decompression time to the optimizer cost formulas. we experimentally tested our revised cost model and the results show that our cost model correctly preserves the relative order between different query plans as imposed by actual query execution times. as comparison to our proposed algorithms  we also implemented strategies for eager  lazy  and transient-only decompression. we refer to these three strategies as baseline strategies.
　data: we used tpc-h data scaled to 1mb both for our experiments on compression and on the optimization strategies. clustered indices were built on primary keys and unclustered indices were built on foreign key attributes. indices are not compressed. tpc-h data contains 1 tables and 1 attributes  1 of which are string-valued. the string attributes account for about 1% of the total database size. we also used a 1mb of dataset with us census data  the adult data set  for experiments on compression strategies. the adult dataset contains a single table with 1 attributes  1 of them string-valued  accounting for about 1% of the total database size.
　execution environment: all experiments were run on an intel pentium iii 1 mhz pc with 1 mb ram running microsoft windows 1. the database was stored on a 1gm scsi disk. the query execution time reported is the average of three executions. predator implements indexnested-loops  block-nested-loops  and sort-merge join. we plan to implement hash join in the future and study its impact on our techniques.
　queries: we are interested in queries  particularly joins  involving compressed string-valued attributes. although queries involving strings are quite common in practice  e.g.   find people with the same last name  or  find papers written by the same author    tpc-h queries only have foreign key joins on numerical attributes. hence  we modified the tpc-h queries by randomly adding secondary join conditions on string attributes as follows: first  we randomly pick two joinable relations that appear in a tpc-h query  then we randomly pick a string attribute from each relation  and finally  we choose a join condition from equality/prefix/suffix/substring matching of the two chosen attributes with equal probability. we also add a negation for the matching condition with 1% possibility and add the chosen string attributes to the final output with 1% probability. unlike numerical attributes  string attributes usually have different domains and decompression will be necessary for evaluating the added join conditions on those two string attributes. we formed four query workloads  based on the number of join conditions we added. workload w1  w1  w1  and w1 contain zero  one  two  and three join conditions on string attributes for each tpc-h query  respectively. since tpc-h queries each contain a different number of join tables  as opposed to join conditions   we further divide each workload into three groups  containing 1 join tables  1 join tables  and 1 or more join tables  respectively.
　metrics: following chaudhuri and shim   we use the following two metrics to evaluate our query optimization strategies.
1. relative cost  which measures the quality of plans. the relative cost equals the execution time of the plan returned by the optimization algorithm divided by the execution time of the optimal plan. a relative cost of 1 means the plan is optimal; the higher the relative cost  the worse the quality of the plan. we used opt to determine the optimal plan  see section 1 .
1. multiplicative factor  which measures the time complexity of optimization strategies. the multiplicative factor equals the number of plans enumerated by the algorithm being studied divided by the number of plans enumerated by a standard optimizer. a small factor implies a fast algorithm.
1 effectiveness of hde
　to isolate the effect of compressing string attributes  we compress all numerical attributes in the data sets using techniques proposed by westmann et al.   but vary the compression methods applied to string attributes. we compared the effectiveness of hde with the following attribute-level compression strategies on string attributes:
1. numerical-only: we only compress numerical attributes.
1. attribute-dic: dictionary compression on the wholeattribute for string attributes with low cardinality. this is the strategy used by westmann et al. .1
1. s-lzw: semi-static lzw  on every string attribute.a tuple-level version of this method was employed by iyer and wilhite .

1
 westmann et al. also used null suppression  deleting ending blanks  on other string attributes  but predator automatically stores long fixed length string attributes  char n   as variable length strings  varchar n   such that blanks are automatically deleted.
table 1: comparison of different compression strategies on tpc-h data.
strategydata sizescan-ndscan-duncompressed1%1%1%numerical-only1%1%1%attribute-dic1%1%1%s-lzw1%1%1%word-dic1%1%1%hde1%1%1%1. word-dic: word-level dictionary compression on eachstring attribute. this is the technique used for information retrieval queries by witten et al. .
　table 1 reports the results of applying various compression methods to the tpc-h database  normalized by the size of the uncompressed data. we also measured the time to scan all tables in the database without decompressing  referred to as scan-nd   and the time to scan all tables with decompressing  referred to as scan-d . we can make the following observations:
1. hde achieves the best space savings. hde beats attribute-dic and word-dic because it intelligently chooses the most appropriate level of dictionary compression rather than using a fixed level. numerical-only does not save much space because the majority of the attributes are strings that are not compressed in numerical-only. s-lzw uses more space than hde because there are many short fixed lengthed string attributes with very low cardinality  which can be compressed to one or two byte fixed length integers by dictionary compression on the whole attribute level  the method selected by hde . in contrast  s-lzw generates variable-length codes and needs to use extra bytes to store the length.
1. the i/o benefits are proportional to the space savings  although slightly lower ; hde achieves the best performance.
1. hde also achieves the best balance between i/o savings and decompression overhead because it has the shortest time for scan with decompression. numericalonly has worse performance because the i/o savings are insignificant although decompression is very fast. s-lzw and word-dic have good i/o savings but the decompression overhead is too high. only attributedic has similar performance to hde.
　table 1 reports the results for the adult data set; the observations are similar except that attribute-dic works equally well as hde because all string attributes in the adult data set have low cardinality. all compression strategies also added about 1 sec/mb compression overhead when the database was loaded  mainly due to the preprocessing pass over the data to build the dictionary. however  in a read-intensive environment  this penalty is offset by the improvement in query performance.
table 1: comparison of different compression strategies on adult data.
strategydata sizescan-ndscan-duncompressed1%1%1%numerical-only1%1%1%attribute-dic1%1%1%s-lzw1%1%1%word-dic1%1%1%hde1%1%1%1 compression-aware optimization
　this section evaluates the various optimization strategies by the quality of returned plans and the time complexity for optimization strategies. our main findings are as follows:
1. the min-k strategy with k = 1 is optimal for all the queries we tried at various buffer pool sizes  and the optimization cost is very low.
1. the two-step strategy sometimes finds near-optimalplans  especially when the buffer size is large.
1. the transient-only strategy is optimal only when queries do not contain join conditions on strings or the buffer pool size is large. otherwise  it often produces inefficient plans.
average quality of plans: we first fix the buffer pool size at 1 mb  but vary the query workload. figures 1  a    b   and  c  report the average relative cost of different groups of queries as we vary the number of join conditions on string attributes. the x-axis shows the number of join conditions we added  each number corresponds to one of the four workloads . for the min-k algorithms  we show two cases: k = 1 and k = 1. the relative costs for running the queries on uncompressed data and data where only the numerical attributes are compressed are also displayed. these costs are 1 times that of optimal plans over compressed string attributes  confirming the performance benefits from string attribute compression.
　the transient-only strategy is best only when there are no join conditions on string attributes; numerical attributes are inexpensive to decompress  and it is usually better to decompress them transiently so that intermediate results remain compressed. otherwise  the average relative cost of plans returned by the transient-only strategy is up to an order worse than opt  demonstrating that transient operators must be applied selectively to be effective.
　as the number of join conditions on string attributes increases  the performance of plans returned by all strategies except min-1 and opt deteriorates. the reason is that string attributes are expensive to decompress and the right decision of whether to keep string attributes compressed to save i/o makes more and more of a difference. the ranking of relative costs for plans returned by the different optimization strategies is as follows:
opt ゛ min-1   min-1 ゛ two-step   baseline strategies
　among the baseline strategies  lazy is significantly better than eager  up to a factor of 1  because  using lazy strategy  decompression does not occur until necessary and the intermediate results are smaller. the transient-only strategy achieves more i/o savings than lazy by always keeping string attributes compressed. however  arbitrary use of transient operators may lead to prohibitive decompression overhead when relational operators require repeated access to compressed string attributes  e.g.  in a block-nested-loops join .
　min-1 always gave optimal plans in our experiments  whereas both min-1 and two-step often gave suboptimal plans. min-k considers up to two cases for each join operator: one is to transiently decompress all string attributes during the join and leave them compressed afterwards  such that relational operators later in the plan will get extra i/o benefits. the other is to decompress all those string attributes before the join to avoid the prohibitive overhead of repeated decompressions during the join. however  since the i/o savings for future relational operations cannot be decided locally  a local decision can be suboptimal. hence  the choice of k is crucial: if k = 1  optimal plans for both cases are kept  while if k = 1  only the local minimum is kept  allowing globally suboptimal results. similarly  the two-step heuristic is less effective than min-1 because the decision of join order and join methods is made independently of the decision on the decompression strategy.
　in summary  the optimizer has to combine the search for optimal plans with the decision of how and when to decompress  as in opt and min-1 . using straightforward  simple heuristics such as eager  lazy  and transient-only  or making the optimization too local such as in min-1 can lead to significantly worse performance.
　distribution of query performance: we examined the performance distribution of individual queries in the workload w1 using a 1 mb buffer pool size  the results for other workloads are similar . we found that min-1 gave an optimal plan for all 1 queries; two-step gave an optimal plan for 1 queries  but had 1 queries with relative cost greater than 1; min-1 had 1 queries with an optimal plan but 1 queries with relative cost greater than 1; eager was the only strategy that never found the optimal plan; transient-only was very unstable  with optimal plans for 1 queries but relative cost over 1 for 1 queries.
　in practice  it is usually suffices to return a  good  plan instead of the optimal plan. we plot the number of queries with relative cost lower than 1  i.e.  with cost within twice of the optimal cost  for various strategies in figure 1  a . again  opt and min-k always return good plans. the number of good plans returned by other strategies decreases as the number of join conditions on string attributes increases. the total number of good plans over all workloads is reported in figure 1  b .
		number of join conditions on string fields
 a  queries with 1 join tables	 b  queries with 1 join tables	 c  queries with − 1 join tables
number of join conditions on string fieldsnumber of join conditions on string fieldsnumber of join conditions on string fields a  queries with 1 join tables b  queries with 1 join tables c  queries with − 1 join tablesfigure 1: relative cost of various strategies vs. number of join conditions on strings.
figure 1: multiplicative factor of various strategies vs. number of join conditions on strings.　number of plans enumerated: figures 1  a    b   and  c  report the average multiplicative factor of different groups of queries as we vary the number of join conditions on string attributes. the three baseline strategies have a multiplicative factor of 1 because no additional plan is enumerated after standard optimization. the multiplicative factor of opt increases rapidly as the number of join conditions on string attributes and the number of join tables increases  and soon leads to prohibitive optimization overhead. our proposed heuristic algorithms reduce the search space greatly. note that min-1 never enumerates more than four times as many plans as the standard optimizer  regardless of the number of join conditions added or of the number of join tables. given that the plans returned by min-1 are close to optimal  min-1 appears to be the most attractive strategy.
　effect of buffer pool size: the size of the buffer pool is an important determinant of query performance. we ran the experiments with buffer pool sizes 1  1  and 1 mb. since the trends we observed for the different workloads were similar  we report the results from workload w1 only. figures 1  a  and  b  show the average relative costs of different query groups using different strategies against varying buffer pool size  the results for the query group with 1 join tables were similar to that with 1 join tables and are omitted .
　not surprisingly  the performance benefits resulting from string compression decrease as the buffer pool becomes larger  since compression has less impact on the amount of data that can be brought into the buffer. nonetheless  the savings from compression are still substantial  ranging from 1%  even when the whole database fits into the buffer pool  1 mb   due to the cpu savings of transient decompression  e.g.  fewer memory copies . also  as reported by lehman et al.   when the whole database fits into the buffer pool  the choice of join methods becomes simpler because cpu cost becomes the only dominant factor. hence  the plan returned by a traditional optimizer becomes good enough  thus two-step often finds optimal plans. moreover  for this buffer size transient-decompression seems to be a good choice for most queries  and thus transient-only strategy is close to optimal as well.
1. related work
　data compression has been a very popular topic in the research literature  and there is a copious amount of work on this subject. well known methods include huffman coding   arithmetic coding   and lempel-ziv  1  1 .
　most existing work on database compression focused on designing new compression methods  1  1  1  1  1  1  1  1  1  1  1 . however  despite the abundance of stringvalued attributes in databases  most existing work has focused on compressing numerical attributes.

 a  number of good plans vs.  b  total number of good plans number of join conditions
figure 1: distribution of query performance.

      a  queries with 1 join tables  b  queries with − 1 join tables figure 1: rel-cost of various optimization strategies varying buffer pool size.　recently  there has been a resurgence of interest on employing compression techniques to improve performance in a database. greer uses simple compression techniques in the daytona database system  but does not consider how to exploit this in the query optimizer . goldstein et al. propose attribute-level offset encoding where the data is only decompressed lazily as needed  1  1 ; little consideration is paid to query optimization other than a modified cost model. westmann et al. propose a collection of lightweight  attribute-level compression methods and shows how to modify the query execution engine ; the authors briefly mention that the cost model should be modified and the issue of whether to compress intermediate results  but no query optimization algorithm was proposed. boncz et al.  consider some attribute-level compression techniques  dictionary-based encoding  for improving join performance in a main-memory database; the focus of this work is on the design of new join algorithms  but without any consideration of query optimization. li et al.  consider aggregation algorithms in a compressed multi-dimensional olap databases; however  they have not addressed querying more general compressed relational databases. the only work we are aware of which considers query optimization over compressed data is by amer-yahia and johnson   but they focus on bitmaps. finally  as discussed in section 1  there is some similarity between our work and that of chaudhuri and shim  and hellerstein et al.   which considers the optimization of queries over expensive predicates. however  for the reasons put forth in section 1  their algorithms do not apply in our case.
1. conclusions
　in this paper  we studied the use of compression to improve database performance. we observed that compressing string attributes is important for query performance. due to the heterogeneous nature of string attributes  a single compression method is inferior to our hierarchical dictionary encoding  a comprehensive strategy that chooses the most effective encoding level for each string attribute.
　in addition  we observed that the placement of string decompression in a query plan is crucial for query performance. a traditional optimizer enhanced with a cost model that takes both i/o benefits of compression and the cpu overhead of decompression into account  does not necessarily achieve good plans.  the two-step algorithm is an instantiation of this approach.  we proposed two new query optimization algorithm  opt and min-k  that combine the search for optimal plans with the decision of when and where to decompress. our experiments show that the combination of effective compression methods and compression-aware query optimization is crucial for query performance - usage of our compression methods and optimization algorithms achieves up to an order improvement in query performance over existing techniques. the significant gains in performance suggests that a compressed database system should have the query optimizer modified for better performance.
　there are several interesting future research directions. first  it would be interesting to study how caching of intermediate  decompressed  results can reduce the overhead of transient decompression. second  we plan to study how our compression techniques can handle updates.
　acknowledgments. we thank praveen seshadri  philippe bonnet  divesh srivastava  and tobias mayr for useful discussions.
