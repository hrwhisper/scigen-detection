we design a novel online analytical processing system for sequence data analysis  the s-olap system . the biggest distinction of solap from traditional olap is that a sequence can be characterized not only by the attributes' values of its constituting items  but also by the subsequence/substring patterns it possesses. traditional olap systems and techniques were not designed for sequence data and thus they are incapable of supporting sequence data analysis. this paper describes my ph.d research on the design and implementation of the s-olap system. the proposed system is able to support  pattern-based  grouping and aggregation  which is currently not supported by any olap system. the preliminary ideas  significant research issues as well as major challenges of this ongoing project are presented.
1. introduction
　online analytical processing  olap  is a very popular and powerful decision-support tool for the organization  presentation  summarization  and analysis of statsistical data. in traditional olap system  data records are collected in a  fact table . each record contains a number of  dimension attributes  as well as one or more  measure attributes . one functionality of an olap system is to group records into batches based on their dimension attributes' values and to report an aggregate summary  such as sum  average  count  of the measure attributes of each group. the reported summary  a.k.a. cuboid  is a tabulation of the aggregate values for all possible groups. olap is a powerful data analysis tool because it allows users to  navigate  or  explore  different levels of summarization by interactively changing the set of dimension attributes and their abstraction levels. in other words  users can navigate from one cuboid to another interactively in order to obtain the most interesting statistics through a set of pre-defined olap operations  such as roll-up  drill-down  slice  and dice .
　traditional olap systems handle records that are independent. however  many kinds of real-life data exhibit logical ordering among their data items and are thus sequential in nature. examples of sequence data include stock market data  web server access logs and various kinds of rfid logs such as those generated by a com-
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
proceedings of the second sigmod phd workshop on innovative database research  idar 1   june 1  1  vancouver  canada.
copyright 1 acm 1-1-1/1 ...$1.
 x y x count nike shoes  adidas shoes  nike shoes 1 nike shoes  adidas sportswear  nike shoes 1 nike shoes  puma shoes  nike shoes 1...... adidas shoes  nike shoes  adidas shoes 1 adidas shoes  puma shoes  adidas shoes 1...... puma shoes  nike shoes  puma shoes 1figure 1: a sequence olap query result
modity tracking system in a supply chain. similar to conventional data  there is a strong demand to warehouse and to analyze the vast amount of sequence data in a user-friendly and efficient way. unfortunately  current olap systems and technologies were not designed for sequence data and they are incapable of supporting sequence data analysis. therefore  my research will focus on the design and implemention of a  sequence olap  system  or an solap system for short.
1 applications
　an s-olap system that analyzes sequence data has many applications. one motivating application is online click stream data analysis. online stores such as amazon and yahoo shopping maintain web servers that record the web page requests of their browsers  including their members . the web server logged huge volumes of data everyday. the click events performed by a member each day can form logical sequences in many different ways. for example  a sequence can be formed by clustering a member's click events over 1-day  1-week or 1-month periods.
　with the enormous amount of sequence data available  an olap system that performs sequence summarizations would be of great value. for instance  if a marketing manager of an e-commerce web site wants to learn about the shopping behavior of its members  she may pose a query asking  the number of members that did comparison shopping and their distributions over all product web page to product web page pairs within 1 quarter 1 . figure 1 presents an artificial click events dataset from a server log. we assume that a member registers an event/transaction into the system every time she clicks on a hyperlink on the web page  the browser requests a web page from the server . therefore  the comparison shopping semantics can be captured by the pattern  x y x   which means that all members who have first browsed any product page x  e.g.  a page displaying a nike shoes product   and then browsed the product page y  a page displaying an adidas sportswear product  again and returned to product page x  a page displaying a nike shoes product  should be grouped together. furthermore  for each
timemember-idurlpage-typeproductproduct-typebrandhttp-referreramount1-1:1/product.xhtml pid=1product page1nike shoesnike/productpage.xhtml pid=1nil...........................1-1:1/product.xhtml pid=1product page1adidas sportswearadidas/productpage.xhtml pid=1nil1-1:1/product.xhtml pid=1product page1puma shoespumahttp://www.google.com q=pumanil1-1:1/product.xhtml pid=1product page1nike shoesnike/productpage.xhtml pid=1nil...........................1-1:1/product.xhtml pid=1product page1timberland bootstimberland/productpage.xhtml pid=1nil1-1:1/checkout.xhtmlcheckout pagenilnilnil/product.xhtml pid=1usd 1... ...........................figure 1: an event databasepossible combination of x and y   the aggregated number of members is counted and a tabulated view of the sequence data like the one shown in figure 1 should be returned by the s-olap system.
　the s-olap system should also allow a user to interactively change the grouping pattern and be able to answer iterative queries1 efficiently. for example  after studying the comparison shopping distribution in figure 1  the manager might observe that there is a particularly high concentration of people making comparison shopping between a page displaying a nike shoes and a page displaying an adidas sportswear. he might want to further investigate whether those members would browse one more product and if so what is the product. he can view this distribution by first performing a traditional slice olap operation on  nike shoes  adidas sportswear  nike shoes   followed by changing the grouping pattern to  x y x z   where the newly appended symbol z denotes the browsing from page x  nike shoes  to any page z.
　s-olap systems have many more applications. another application is transportation planning. today  many cities have implemented electronic transportation payment systems using rfid technology. examples include hong kong's octopus system  japan's kansai thru pass system and washington dc's smartrip system. in those cities  every passenger carries a smart card  e.g.  a card with a passive rfid chip    which can be used as a form of electronic money to pay for various kinds of transportation  e.g.  bus/subway . the electronic payment system generates huge volumes of data everyday  e.g.  hong kong's octopus system collected over 1 million transactions per day in 1  . the transactions performed by each user can form a logical sequence according to the time attribute. as an example query  a transport planning manager may want to know  the number of round-trip passengers and their distributions over all origin-destination station pairs within 1 q1 . we assume that a passenger registers a transaction into the system every time she enters or leaves a station through the turnstiles. therefore  the round-trip semantics can be captured by the pattern  x y y x   which means that all passengers who have first entered any station x  exited at any station y   and then entered station y again and returned to station x should be grouped together1. again  for each possible combination of x and y   the aggregated number of passengers is counted and a tabulated view of the sequence data should be returned by the s-olap system. furthermore  the s-olap system should provide userfriendly operations such that the manager can interactively change their queries . as an example  after studying the station pair roundtrip summary  the manager may want to view the summary in the abstraction level of district rather than station.

1
correlated olap queries are called iterative queries in tpc-ds
. 1
 in general  the round-trip sematics require more constraints on other attributes  e.g. whether the first event is the  begin  or the  end  of a trip should also be considered . we skip the details of this specification in this paper.
　from the above application examples  we can see that the biggest distinction of an s-olap system from a traditional olap system is that a sequence can be characterized not only by the attributes' values of its constituting events  but also by the subsequence/substring patterns it possesses. in other words  an s-olap system can support  pattern-based  grouping and aggregation - a very powerful concept and capability that is not supported by traditional olap systems.
1 research issues
　to the best of our knowledge  the building of an s-olap system for analyzing sequence data has not been addressed previously in the research literature or in commercial products. my research will focus on the design and implementation of an s-olap system. the significant research problems can be summarized as follows:
1. fundamental concepts. the concepts of  sequence cuboid   s-cuboid  and  sequence data cube   s-cube  are fundamental to the design of a sequence olap system. in this paper  we introduce the idea of s-cuboid through a series of s-cuboid construction steps.
1. system architecture design. we study the various components of a sequence olap system and their interactions. based on an event dataset  one can derive a number of sequence datasets. for each such sequence dataset  one can derive many different  s-cuboids   based on the patterns chosen for sequence grouping. an s-olap architecture should thus consist of the following components: an event database  a sequence query engine  an s-cuboid computation unit  an s-cuboid storage system  a user interface that allows a user to identify an s-cuboid for query processing  etc. we present the system architecture as well as the roles of various system components in trasforming an event dataset to an s-cuboid  based on user's query  in section 1.
1. s-olap-specific operations. in traditional olap systems  users  navigate  or  explore  different levels of summarization  i.e.  different cuboids  through a set of user-friendly operations  such as roll-up  drill-down  slice  and dice . in this paper we present six operations that are specific to solap  namely   1  append   1  de-tail   1  prepend 
 1  de-head   1  pattern-roll-up and  1  patterndrill-down. the six s-olap operations modify the grouping patterns and/or the abstraction level of the elements inside the grouping patterns such that users can interactively
view the summarized data from different perspectives.
1. cuboid materialization. how and when the s-cuobids are materialized  computed  stored  and retrieved are interesting research problems to be addressed. in particular  we identify two properties of s-cuboid: 1  the number of s-cuboids

figure 1: architecture of s-olap system
in an s-cube space is infinite  and 1  data in a s-cuboid is non-summarizable. we will show that the two properties introduce interesting and challenging research problems with respect to the implementation of an s-olap system.
　the rest of the paper proceeds as follows: section 1 gives an overview of work that is related to sequence olap. section 1 describes the system architecture of s-olap. section 1 presents our proposed s-olap operations  followed by a brief discussion of the propoerties of s-cube and s-cuboid in section 1. we discuss some implementation challenges of the s-olap system in section 1 and conclude the paper in secion 1.
1. related work
sequence databases. database systems used to be no formal support of sequence data until predator  1  1 . predator extended the adt approach of object-relational systems by treating the sequence type as an enhanced adt  eadt . predator treats sequence data type as first class citizen and its query language sequin includes a set of sequence operators for querying and manipulating sequences.
　since applications often involve both relational data and sequence data  the devise system  was proposed to model sequences as sorted relations. by storing sequence data using normal relations  it is much easier to query a combination of relational tables and data sequences. this approach enables more integrated optimization and evaluation. srql is an extension of sql. it is used in the devise system for supporting queries on mixtures of sequences and relations. however  devise did not address the issues of warehousing and efficient analysis of sequence data. moreover  srql itself is not expressive enough to express queries with complicated patterns such as recurring patterns. in view of this   extended srql and proposed sql-ts. with sql-ts  one can express sophisticated sequential pattern queries. however   did not address the issues of sequence data analysis as well.
olap.  first described the data-cube operator. since then  a large number of papers have been written on the subject. many of them focus on efficient algorithms for data cube construction. a few examples include: iceberg cube   bottom-up cube computation   and top-down cube computation . none of these studies  however  address sequence data.
olap on unconventional data. in   the authors addressed how to store and analyze massive rfid-enabled workflow data  which is a very special type of sequence data. their proposal made heavy use of a special property of workflow data that individual items in a supply chain tend to move together in bulky mode. based on that property   introduced the concept of rfid-cubiods  which is a way to store rfid workflow data in relational databases that supports efficient data compression and specialized workflow data analysis. stream data is another kind of sequence data. in   the

figure 1: the conceptual view of building an s-cuboid.
authors studied how to build data cubes for time-series stream data. nonetheless  none of these work address the problem of patternbased grouping and analysis. recently  wiwatwattana et al.  discuss how to perform olap operations on xml data. due to certain special properties of xml data  e.g.  an xml element may have missing or repeated sub-elements   the authors point out that xml data is non-summarizable . that is  a coarser aggregate cannot be computed solely from the corresponding finer aggregates. in   they approach the problem by proposing several aggregation relaxation models such that cube data becomes summarizable under such restricted models.
1. system architecture
　in this section we present our proposed s-olap system. figure 1 shows an architecture of our s-olap system and figure 1 shows the process of transforming an event dataset to an s-cuboid. the raw data of an s-olap system is a set of events that are deposited in an event database. each event is modeled as an individual record/tuple in a way similar to those stored in a fact table of a traditional olap system. we assume each event record consists of a number of  dimension attributes   such as time  product  as well as a few  measure attributes   such as amount  and each dimension may be associated with a concept hierarchy. in the running example  we assume that the product dimension is associated with a concept hierarchy of three abstraction levels individualproduct★product-type★brand  the member attribute is associated with a concept hierarchy individual-member★member-group  and the time attribute is associated with a concept hierarchy day★ month★year.
　given a user requirement  the job of the sequence query engine is to compose sets of event sequences out of the event database. this consists of four steps:
step 1. event selection. a logical view of the data is derived by selecting a set of relevant records and attributes. for example  an analysis on product browsing events will extract only those events whose  page-type = product page  from the raw click event dataset; other events  such as those registered from member registration pages and login pages  would not be selected into the view. step 1. event clustering. events that are elements of a sequence are clustered together. for example  an analysis on the members' daily browsing sequences will cluster events based on the attributes
1. cuboid by	substring  x  y   x  with
1. x as product at product-type 
1. y as product at product-type
1. left-maximality  x1  y1  x1 
figure 1: s-cuboid specification q1.
 member  and  time   at the abstraction levels of individual-member and day  respectively. in another words  events conducted by the same member in the same day are clustered together.
step 1. sequence formation. events in each cluster are ordered to form a sequence. in our running example  a logical ordering would be based on the occurrence time of events. the sequences generated are optionally cached in a sequence cache.
step 1. sequence grouping. sequences whose events share the same dimensions' values are further grouped together to form a sequence group. this step requires users to specify a set of  dimension attributes  and their abstraction levels. we refer the  dimension attributes  as global dimensions in our later discussions. consider our running example  after the daily product pages browsing sequences of each individual member are formed  we would like to analysis the browsing sequences with respect to different member-group. in this case  the browsing sequences within the same member group and whose events occurred in the same day should form a sequence group  see step 1 in figure 1 .
1 sequence olap engine
　similar to traditional olap systems  a user can pose their solap queries through a user interface. the user interface provides certain user-friendly components to help a user specify an s-cuboid  e.g.  offering some drag-and-drop facilities . given an scuboid query  the solap-engine consults a cuboid repository to see if such an s-cuboid has been previously computed and stored. if not  the s-olap engine either computes the s-cuboid from scratch or computes the s-cuboid with the help of certain auxiliary data structures  the reason that an s-cuboid at a higher level of abstraction cannot be computed solely from a set of s-cuboids that are at lower level of abstraction is discussed in section 1 . the computed s-cuboid is then added to the cuboid repository. if storage space is limited  the cuboid repository could be implemented as a cache with an appropriate replacement policy such as lru
 least-recently-used .
　during the computation of an s-cuboid  the s-olap system starts with the first four steps as illustrated above  i.e.  1  event selection   1  event clustering   1  sequence formation  and  1  sequence grouping. these four steps can be offloaded to an existing sequence database query engine and the constructed sequence groups can be cached in a sequence cache for efficiency. after the first four steps  the sequence groups are stored in a q-dimensional array  where q is the number of global dimensions . once the sequence groups are formed  or loaded from the sequence cache   the s-olap engine starts the pattern grouping step.
　challenge 1. given the sequence groups  how can the solap system users specify the pattern-based grouping criteria  the pattern grouping should characterize the data sequences within each of the sequence groups based on the substring/subsequence patterns  or other kind of sequence matching criteria  that the data sequences pose.
step 1. pattern grouping. as an initial approach  we have defined a cuboid by clause in order to specify the logical view of the sequence data that the user wants to see. the cuboid by clause consists of three sub-parts:  a  pattern template   b  cell restriction and  c  matching predicate. step 1 in figure 1 illustrates the
1. cuboid by	substring  x  y   x  with
1. x as product at product-type 
1. y as product at product-type
1. left-maximality  x1  y1  x1  with
1. y1.product =  nike shoes  at product-type and
1. x1.http-referrer !=  null 
           figure 1: s-cuboid specification q1. pattern grouping step and the details are explained below.
a. pattern template. a pattern template consists of a sequence of symbols  each associated with a domain of values. the domain of values is specified as the domain of an attribute at certain abstraction level. the set of distinct symbols in a pattern template form the set of pattern dimensions. the set of pattern dimensions together with the set of global dimensions define the partitioning of an s-cuboid  i.e.  the cells of an s-cuboid .
the pattern template defines the format of the substring/ subsequence patterns to be matched against the data sequences.
by substring x y x  or subsequence x y x   we mean a substring/subsequence pattern template  x y x  is specified. lines 1 in figure 1 show an example substring pattern template with two pattern dimensions x and y   each represents a product value at the product-type abstraction level.
each cell in the s-cuboid is associated with a pattern. a pattern can be instantiated from a pattern template by a set of values that are associated with the symbols. if two symbols in a pattern template are the same  then they should be instantiated with the same value. for example  the pattern  nike shoes  adidas sportswear  nike shoes  is an instantiation of pattern template  x y x  but the pattern  nike shoes  adidas sportswear  adidas sportswear  is not.
if a data sequence matches the pattern of a particular cell  and if it further satisfies the cell restriction and the matching predicate   b  and  c  below   then it is assigned to that cell. note that since a data sequence may match multiple patterns  it may be assigned to more than one cuboid cell.
　challenge 1. as an initial approach  only substring and subsequence are considered for pattern matching. as one of our major future work  the pattern template should be extended so that it can support more sophisticated regular expressions.
b. cell restriction. the cell restriction defines how to deal with the situations when a data sequence contains multiple occurrences of a cell's pattern and what content of the data sequence should be assigned to the cell  for the purpose of aggregation  to be done later . one type of cell restriction is leftmaximality-matched-go . for example  when a cell with a substring pattern  a a  is matched against a data sequence haabaai  the left-maximality-matched-go cell restriction states that only the first matched substring/subsequence  i.e.  the first  aa  in haabaai  is assigned to the cell. this cell restriction is specified by the keyword left-maximality. in general  depending on the applications  more cell restrictions can be defined. for example  one can define a left-maximality-datago cell restriction where the whole data sequence haabaai  not only the matched content haai  is assigned to the cell.
c. matching predicate. a matching predicate is further introduced for selecting data sequences of interests. in order to specify a predicate  a sequence of event placeholders are introduced after the cell restriction. line 1 in figure 1 shows an example. the three event placeholders x1  y1 and x1 in line 1 represent the matched events. the predicate specification in line 1 states that the product attribute value of the second matching event y1 must equal to  nike shoes  at the product-type abstraction level. the above example is essentially the  slice  operation on pattern dimension of s-cuboid.
in addition  the matching predicates provide flexibility to select/filter events on the attributes other than the global dimensions and pattern dimensions. as an example  line 1 in figure 1 limits the matched events to have non-null http referrers  stored in the  http-referrer  attribute   which is a common way to filter events registered by the web clawers.
step 1. aggregation. finally  an aggregation function is applied to the sequences in each cuboid cell. for example  an aggregation function count simply count the number of sequences that are assigned to each cuboid cell.
　challenge 1. the definition of aggregate function is a nontrivial task in the design of the s-olap system. for example  other aggregation functions  such as sum  can be incorporated as long as its semantics is clearly defined. as an example  consider two data sequences s1:he1 e1i and s1:he1 e1i that are assigned to a cell. we can define sum as the sum of the measures of all the events occurred in s1 and s1  i.e.  sum = 1i=1 ei.amount . alternatively  if desire  we can sum over the first occurring event in each sequence  i.e.  sum = e1.amount +e1.amount .
　after all steps  a 1d s-cuboid  the shaded area in figure 1  with two global dimensions  time:day  member:member-group  and two pattern dimensions  x y   is built.
1. sequence olap operations
　olap is a powerful analytical and decision-supporting tool because it provides a set of operations  e.g.  roll-up  drill-down  for a user to interactively modify the cuboid specification  i.e.  changing the set of dimension attributes and/or their abstraction levels  and thus enables a user to navigate from one cuboid to another to explore the big cube space with ease. an s-olap system should likewise provide a set of s-olap operations for the exploration of an s-cuboid space.
　challenge 1. what kind of operations should the s-olap system supports  in particular  the new operations should allow users to manipulate the grouping pattern  i.e. the pattern dimensions  in an s-cuboid specification  which is the key distinction between a traditional olap system and an s-olap system.
for pattern manipulation  we have proposed six s-olap operations  namely  append  prepend  de-tail  de-head  pattern-
1. cuboid by	substring  x  y   x  z  with
1. x as product at product-type 
1. y as product at product-type 
1. z as product at individual-product
1. left-maximality x1  y1  x1  z1 
figure 1: s-cuboid specification q1
a new pattern dimension . the other three operations that modify pattern length can be similarly defined: prepend - add a symbol to the front of the pattern template; de-tail - remove the last symbol from the pattern template; de-head - remove the first symbol from the pattern template.
　a p-roll-up operation moves the abstraction level of a pattern dimension one level up the concept hierarchy  while a p-drilldown operation moves a pattern dimension one level down. as an example  after viewing the browsing distribution resulted from the above query q1  the marketing manager might find that there are too many products  which makes the distribution reported by the scuboid too fragmented. he may want to roll up the product pattern dimension z from the individual-product level to the producttype level. for that  the p-roll-up changes line 1 in figure 1 to:  z as product at product-type .
1. sequence data cube
　in traditional olap  given a set of dimensions and a set of concept hierarchies associated with the dimensions  we can define a cuboid for each of the possible subsets of the given dimensions and abstraction levels. this results in a lattice of cuboids  each showing the data at a different level of summarization. the lattice of cuboids is then referred to as a data cube. likewise in s-olap  given a set of global and pattern dimensions and a set of concept hierarchies that is associated with the dimensions  we can also define an scuboid for each of the possible subsets of the given dimensions and abstraction levels. the set of s-cuboids also form a lattice and we call this lattice a sequence data cube  s-cube . similar to the concept of traditional data cubes  an s-cuboid at a coarser granularity is at a higher level in the lattice  which means it contains fewer global and/or pattern dimensions  or the dimensions are at a higher level of abstraction. formally  we can define a partial order for the s-cuboids in the lattice.
　there are two key differences between a traditional data cube and an s-cube:
a. infinite number of s-cuboids. first  there is a finite number of cuboids in a data cube while the number of s-cuboids in an s-cube is infinite. in theory  users may introduce any number of pattern dimensions into the pattern template by s-olap

roll-up  p-roll-up  and pattern-drill-down  p-drill-down . the first four operations add/remove a pattern symbol to/from a pattern template  while the last two operations modify the abstraction level of pattern dimensions. in particular  the append operation appends a pattern symbol to the end of the pattern template. for example  after learning about the distribution of the browsing pattern  x y  x   the manager might observe that there is a particularly high concentration of members browsing a nike shoes product page  and then an adidas sportswear product page  and then to a nike shoes product page  the s-cuboid cell  nike shoes  adidas sportswear  nike shoes  . he might want to further investigate whether those members would browse one more product and if so what is the product. an append operation gives the cuboid specification q1 in figure 1. q1 transforms the original 1d scuboid to a 1d s-cuboid  with global dimensions  time:day  member:member-group  and pattern dimensions  x y  z   where z is operations like append and prepend. for example  a pattern template  x y z a b c ...  is possible in which all pattern dimensions refer to the same dimension attribute  say  product. consequently  an s-cube in theory includes an infinite number of s-cuboids although users seldom pose s-olap queries with long pattern template in practice.
b. non-summarizability. second  in general  data in an s-cuboid is non-summarizable. that is  an s-cuboid at a higher level of abstraction  i.e.  coarser aggregates  cannot be computed solely from a set of s-cuboids that are at a lower level of abstraction  i.e.  finer aggregates  without accessing the base data. according to   summarizability only holds when the data is disjoint and complete during data partitioning. however  an scuboid may put a data sequence into multiple cells which violates the disjointness requirement. consider a dataset with only one data sequence s1 hnike  adidas  nike  adidas  pumai  at the brand abstraction level . if the pattern template is substring  x y z   then s1 contributes a count of one to all three cells  nike  adidas  nike:c1    adidas  nike  adidas:c1   and  nike  adidas  puma: c1  because s1 matches all three substrings  c1 c1 and c1 denote the counts of the cells . if we perform a de-tail operation  i.e.  the pattern template is changed to substring x y    then the cell  nike  adidas: c1  should have a count of one  as s1 matches the pattern only once under the left-maximality-matched-go cell restriction . however  if we compute c1 by aggregation  we get c1 = c1+c1 = 1  an incorrect answer. this observation  which serves as a counter-example  demonstrates that in general  data in an s-cuboid is non-summarizable.
1. implementation challenges
　in order to implement an s-olap system  we have the following technical challenges:
challenge 1. how to efficiently compute an s-cuboid 
　as we have mentioned  part of the job of the s-olap engine is to compute an s-cuboid in response to a use s-olap query. each cell in an s-cuboid is associated with an instantiation of the s-cuboid pattern  and an instantiation of the global dimension attributes' values. to compute the value of a cell we need to find all relevant sequences  in particular  those sequences that contain the cell's pattern and at the same time match the cell's global dimensions' values. a straightforward approach would create a multidimensional array of counters  where each counter is associated with one cell of the s-cuboid. data sequences are then scanned  and for each one we perform pattern matching to determine which cells the sequence is relevant to. those cells' aggregate values are then appropriately updated. one inherit problem we will address in this project is how to efficiently determine the set of relevant cells given a set of data sequences. for example  will an index built on the cells' patterns help 
　another approach is to do the matching in the reverse direction. that is to say  given a cell  a pattern instantiation   we determine the set of data sequences that are relevant to the cell. here  we can again consider pattern index structures to index sequences  in a way similar to inverted indices used in information retrieval systems. we are conducting a performance evaluation study comparing the efficiency of various s-cuboid computation strategies.
　challenge 1. how to support the proposed s-olap operations such that a sequence of s-olap queries can be efficiently evaluated 
　in traditional olap  cube materialization  is a popular approach in which some cuboids are computed in advance such that they can be used to answer various olap queries efficiently. the approach of full materialization refers to the precomputation of all cuboids  i.e.  the full cube  and the approach of partial materialization refers to the precomputation of a subset of cuboids  i.e.  the subcube . since summarizability generally holds in traditional data cube  partial materialization is useful because  i  if a query result  a cuboid  has already been materialized  the answers can be returned right away  and  ii  even if a query result has not been materialized  a coarser aggregate can still be computed solely from the corresponding finer aggregates by exploiting appropriate materialized cuboids without accessing the base data. consequently  iterative queries can be answered efficiently.
　in s-olap  full materialization is not practical because the number of pattern dimensions is unbounded. meanwhile  the non-summarizability of s-cubes invalidates the power of partial materialization because an s-cuboid cannot be computed from other s-cuboids via simple aggregations. as a result  instead of precomputating scuboids  a possible direction is to precompute some other auxiliary data structures so that queries can be computed online using the pre-built data structures.
1. conclusions
　this paper presented the concept of sequence olap  s-olap . the preliminary ideas  significant research issues as well as major challenges of this project are presented. for future research  i will first dedicate to the performance analysis of various auxiliary data structures in builing the proposed s-cuboid  as well as their efficiencies in supporting the proposed s-olap operations. for the long term goal  i will study the entire research history of traditional olap system and try to incorporate the ideas into the s-olap system. for instance  the ideas of iceberg cube   bottom-up cube computation   and top-down cube computation  are good inspiration for s-olap research.
