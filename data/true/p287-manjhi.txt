existing energy-efficient approaches to in-network aggregation in sensor networks can be classified into two categories  tree-based and multi-path-based  with each having unique strengths and weaknesses. in this paper  we introduce tributary-delta  a novel approach that combines the advantages of the tree and multi-path approaches by running them simultaneously in different regions of the network. we present schemes for adjusting the regions in response to changes in network conditions  and show how many useful aggregates can be readily computed within this new framework. we then show how a difficult aggregate for this context- finding frequent items-can be efficiently computed within the framework. to this end  we devise the first algorithm for frequent items  and for quantiles  that provably minimizes the worst case total communication for non-regular trees. in addition  we give a multi-path algorithm for frequent items that is considerably more accurate than previous approaches. these algorithms form the basis for our efficient tributary-delta frequent items algorithm. through extensive simulation with real-world and synthetic data  we show the significant advantages of our techniques. for example  in computing count under realistic loss rates  our techniques reduce answer error by up to a factor of 1 compared to any previous technique.
1.	introduction
모networked collections of smart sensors are increasingly being used to monitor and query the physical world. these small sensor motes are typically battery-powered  possess limited cpus and memory  and organize themselves into ad hoc multi-hop wireless networks around more capable base stations. a paramount concern in these sensor networks is to conserve the limited battery power  as it is usually impractical to install new batteries in a deployed sensor network. because the battery drain for sending a message between two neighboring sensors exceeds by several orders of magnitude the drain for local operations within a sensor mote  minimiz-
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage  and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1 june 1  1  baltimore  maryland  usa.
copyright 1 acm 1-1/1 $1.

figure 1: tributaries and deltas
ing sensor communication is a primary means for conserving battery power  1  1 . thus for aggregation queries  e.g.  the average temperature reading across the sensor network   it is now accepted practice  1  1  1  that aggregates are computed in-network whenever possible-this avoids the excessive communication required to route all the sensor readings to the base station. with the in-network approach  sensor readings are accumulated into partial results that are combined as messages propagate toward the base station. in many common cases  such as sum  count  average  min  max   each sensor node transmits only one short message during the aggregation-a considerable energy savings over the route-all approach.
모existing energy-efficient approaches to in-network aggregation can be classified into two categories: tree-based and multi-path-based. in the tree-based approach  such as in tag   tinydb   and cougar    a spanning tree  rooted at the base station  is constructed for use in answering queries. subsequently  each query answer is generated by performing in-network aggregation along the tree  proceeding level-by-level from its leaves to its root. many aggregates  including those given above  can be computed exactly and with minimal communication on a tree topology  assuming no communication failures. however  wireless sensor networks have high communication failure rates  up to 1% loss rate is common    and each dropped message results in an entire subtree of readings being dropped from the aggregate answer. as a result  it is not uncommon to lose 1% of the readings in a multi-hop sensor network  causing significant answer inaccuracy .
energy componentserror componentslatencynumber ofmessagecommunica-approximationmessagessizetion errorerroraggregate:anycountfreq.itemsanycountfreq.itemsanytree  1  1  1  1 minimalsmallmediumvery largenonesmallminimalmulti-path  rings   1  1 minimalsmalllargevery smallsmallsmallminimaltributary-delta  this paper minimalsmallmediumvery smallvery smallsmallminimaltable 1: comparison of previous in-network aggregation approaches and the tributary-delta approach. the total energy consumption is given by its two components. the total error is given by the sum of the communication error produced by message losses within the network and the approximation error coming from the aggregation algorithm  independent of message loss . because the message size and approximation error depend on the aggregate  these metrics are shown for two representative aggregates: count and frequent모to overcome the severe robustness problems of the tree approach  two recent papers  1  1  propose using multipath routing for in-network aggregation. instead of having each node send its accumulated partial result to its single parent in an aggregation tree  the multi-path approach exploits the wireless broadcast medium by having each node broadcast its partial result to multiple neighbors. both papers recommend a topology called rings  in which the nodes items.
are divided into levels according to their hop count from the base station  and the multi-path aggregation is performed level-by-level toward the base station. this approach sends the same minimal number of messages as the tree approach  i.e.  one transmission per node   making it energy-efficient. it is also very robust to communication failures because each reading is accounted for in many paths to the base station  and all would have to fail for the reading to be lost. however  there are two drawbacks to the multi-path approach:  1  for many aggregates  the known energy-efficient techniques provide only an approximate answer  with accuracy guarantees   and  1  for some aggregates  the message size is longer than when using the tree approach  thereby consuming more energy.
모the first two rows of table 1 provide a qualitative comparison of the two previous in-network aggregation approaches. for multi-path  we consider the rings topology. as the table shows  the tree approach suffers from very high communication error while the multi-path approach can have larger message sizes and approximation errors.
tributary-delta. in this paper we present a new approach to in-network aggregation that combines the advantages of both the tree and multi-path approaches  by dynamically adapting the aggregation scheme to the current message loss rate. under low loss rates  trees are used for their low or zero approximation error and their short message size. under higher loss rates or when transmitting partial results accumulated from many sensor readings  multi-path is used for its robustness. we call our approach tributary-delta because of the visual analogy to a river flowing to a gulf: when far from the gulf  the merging of river tributaries forms a tree-like shape  whereas near the gulf  the river branches out into a multi-path delta in order to reach the gulf despite the increased obstacles  see figure 1 .
모we show that our tributary-delta approach significantly outperforms both previous approaches. an example result is shown in figure 1  full details in section 1 . as expected  the tree approach is more accurate than the multi-path approach at very low loss rates  because of its lower approximation error  1% versus 1% . however  at loss rates above 1%  tree is much worse than multi-path because of its high communication error. on the other hand  tributarydelta provides not just the best of both  e.g.  from running either tree or multi-path in the entire network   but in fact provides a significant error reduction over the best  across a wide range of loss rates-thus demonstrating the synergies of using both in tandem. the last row of table 1 summarizes the benefits of tributary-delta.

figure 1: rms error of a count query under varying message loss rates. the experimental setup and the full graph are provided in section 1.
모to enable simultaneous use of the tree and multi-path aggregation approaches  we must resolve several challenges. for example  how do the sensor nodes decide whether to use the tree or the multi-path aggregation approach  how do nodes using different approaches communicate with each other  how do nodes convert partial results when transitioning between approaches  we identify and address these and other challenges in this paper  through a careful system design and algorithmic study. we also discuss how a large number of aggregates can be computed within the tributary-delta framework.
모our most significant algorithmic result is a new tributarydelta algorithm for finding frequent items. for this result  we devise a new tree-based algorithm  a new multi-pathbased algorithm  and a new  combined  tributary-delta algorithm. previous tree-based frequent items algorithms worked only for balanced  regular1 trees  and/or used too much communication  1  1 . we present the first frequent items algorithm that provably minimizes the worst case total communication for non-regular trees that have certain properties common to typical sensor network deployments. in addition  our new multi-path algorithm uses low total communication while providing high accuracy; the only previous approaches  are far less accurate.
contributions. in summary  the main contributions of this paper are:
  we introduce the tributary-delta approach to in-network aggregation in sensor networks  for adapting the aggregation scheme to current message loss rates. we show that many aggregates can be readily computed in this framework.
  we present schemes for adjusting the balance between tributaries and deltas in response to changes in network conditions.
  we present a novel tributary-delta algorithm for finding frequent items-a difficult aggregate for this context. to this end  we devise the first algorithm for frequent items  and for quantiles  that provably minimizes worst case total communication for non-regular trees. the algorithm's guarantees hold for a class of trees that arise naturally in sensor networks; we also present a new tree construction algorithm well-suited to generating trees in this class. in addition  we give a multi-path algorithm for frequent items that is considerably more accurate than previous approaches.   we provide an extensive evaluation of tributary-delta aggregation on a realistic sensor network simulator  using real-world and synthetic data sets  confirming the significant advantages of our techniques. for example  in computing count under typical loss rates  1%   tributary-delta reduces errors by up to a factor of 1 compared to the best existing approach for that rate.
모although the general framework encompasses optimizing many possible metrics based on the criteria in table 1  in this paper we focus on the following setting. users provide target thresholds on both the communication error  e.g.  at least 1% of the nodes should be accounted for in the answer  and the approximation error  e.g.  the answer should be within 1% of the actual answer of the query applied to the  accounted for  nodes . our goal is to achieve these thresholds while incurring minimal latency  using a minimal number of messages  and minimizing the message size.
roadmap. section 1 describes background information and related work. section 1 overviews our tributary-delta approach. section 1 presents our adaptation design. section 1 discusses tributary-delta algorithms for many aggregates. section 1 presents our frequent items algorithm. section 1 presents our experimental results. finally  section 1 presents conclusions.
1.	preliminariesandrelatedwork
모there has been a flurry of recent papers on energy-efficient  in-network computation of aggregate queries in sensor networks  1  1  1  1  1  1  1  1 . as discussed in section 1  this previous work can be classified according to the aggregation topology used: tree-based or multi-path-based. in this section  we describe these two approaches in more detail and survey the related work. we begin by describing the general set-up used in this paper.
aggregation set-up. we have m sensor nodes each generating a stream of sensor readings. the sensor nodes are connected  either directly or via other sensor nodes  to a base station. aggregate queries  which may be one-time or continuous  are sent from the base station to all the nodes. queries may aggregate over a single value at each sensor  e.g.  the most recent reading  or over a window of values from each sensor's stream of readings. each sensor node evaluates the query locally  including any predicates   and produces a local result. there is an aggregation topology  e.g.  tree or rings  that is used to route these local results to the base station  combining them along the way into concise partial results. for continuous queries  the process of computing  routing and combining local results repeats itself at regular intervals  possibly in a pipelined fashion within the network .
모we consider the realistic setting where the communication between sensors may be lossy  and network conditions change over time. in evaluating the quality of an answer  we consider both the communication error  which results from message losses in the network  and the approximation error  which results from lossy data reduction performed to reduce message lengths .
tree-based. in the tree-based approach  1  1  1  1  1  1   a spanning tree rooted at the base station is constructed for use in answering queries. each node computes its level  i.e.  minimum number of hops from the root  in the tree during this construction by adding one to the level of its parent. in-network aggregation proceeds level-by-level toward the root  starting with the nodes at the highest level. to coordinate the sending and receiving of messages  nodes are loosely time synchronized and are allotted specific time intervals  according to their level  when they should be awake to send and receive messages. in this way  level i nodes are listening when level i + 1 nodes are sending. the period of time allotted for exchanging messages between two levels is called an epoch . epochs must be sufficiently long such that each sensor in a level can transmit its message once without interference from other sensors' transmissions. the latency of a query result is dominated by the product of the epoch duration and the number of levels.
모to adapt the tree to changing network conditions  each node monitors the link quality to and from its neighbors . this is done less frequently than aggregation  in order to conserve energy. if the relative link qualities warrant it  a node will switch to a new parent with better link quality  in order to make the tree more robust . however  because each lost message drops an entire subtree  even trees with high link quality produce very inaccurate answers once the tree is beyond a certain size. this inaccuracy has been previously studied  and can also be seen in figure 1.
모a key advantage of using a tree topology is that aggregating within the network is often straightforward  using minimal resources and incurring no approximation error. for example  for a sum query  each node transmits the sum of the readings in its subtree  by listening for its children's subtree sums  adding them to its own readings  and sending the result to its parent. in the absence of communication error  the resulting sum would be exact.
multi-path-based. the multi-path-based approach  1  1  allows for arbitrary aggregation topologies  beyond a tree. note that multi-path aggregation in general does not require a longer epoch length . in this paper  we focus on the rings topology  because it provides a good energyrobustness trade-off  1  1 . to construct a rings topology  first the base station transmits and any node hearing this transmission is in ring 1. at each subsequent step  nodes in ring i transmit and any node hearing one of these transmissions-but not already in a ring-is in ring i + 1. the ring number defines the level of a node in the rings topology. aggregation proceeds level-by-level  with level i + 1 nodes transmitting while level i nodes are listening. in contrast to trees  the rings topology exploits the wireless broadcast medium by having all level i nodes that hear a level i + 1 partial result incorporate that result into their own. this significantly increases robustness because each reading is accounted for in many paths to the base station  and all would have to fail for the reading to be unaccounted for in the query result. as with trees  nodes can monitor link quality and change levels as warranted.
모a key advantage of using a rings topology is that the communication error is typically very low  in stark contrast with trees. this can be seen in figure 1  where the accuracy of multi-path decreases very slowly with increasing loss rates  the approximation error is around 1% in this experiment  independent of the loss rate . moreover  the rings approach is as energy-efficient as the tree approach  within 1%  .
모however  because each partial result is accounted for in multiple other partial results  special techniques are required to avoid double-counting. previous work has shown how to avoid double-counting in computing count  sum  and many other aggregates  1  1 . for this paper  we adopt our terminology of   where the multi-path approach is called synopsis diffusion.1 there are three functions used to compute an aggregate:  1  a synopsis generation  sg  function that takes a stream of local sensor readings at a node and produces a partial result  called a synopsis; this function is applied by each node on its local readings.  1  a synopsis fusion  sf  function that takes two synopses and generates a new synopsis that summarizes both; this function is applied when combining partial results in-network.  1  a synopsis evaluation  se  function that translates a synopsis into a query answer; this function is applied at the base station.
other related work. many papers have presented techniques for computing aggregates over data streams  including distributed data streams  see  1  1  for surveys . several recent papers  1  1  have proposed duplicate-insensitive multi-path in-network aggregation techniques for peer-topeer networks or mobile environments. none of their techniques are suitable for the sensor network setting in which reducing energy consumption is of paramount importance.
모in summary  none of the previous work has proposed and studied combining the complementary strengths of the two approaches in order to obtain the best of both  and more .
1.	tributary-delta approach
모in our tributary-delta aggregation scheme  we leverage the synergies between the existing energy-efficient schemes  by combining the efficiency and accuracy of  small  trees under low loss rates with the robustness of multi-path schemes. specifically  part of the network runs a multi-path scheme while at the same time the rest of the network runs tree schemes. in the extreme  all nodes might either run a multipath or a tree scheme. we dynamically adjust the use of trees and multi-path  based on current message loss rates. in this section we provide an overview of our tributary-delta scheme.
모we begin by defining a directed graph g representing the aggregation topology during a tributary-delta aggregation. the sensors and the base station form the set of vertices of g  and there is a directed edge for each successful trans-

figure 1: combining tree and multi-path algorithms for computing count in the tributary-delta framework. bit vector  bv  is the multi-path synopsis for the count aggregate  1  1 .
mission. each vertex is labeled either m  for multi-path  or t  for tree  depending on whether it runs a multi-path aggregation algorithm or a tree aggregation algorithm. an edge is assigned the same label as that of its source vertex. note that both the set of edges and the labels of individual vertices and edges may change over time. figure 1 depicts an example graph g  where the edges are directed to the right in the figure. figure 1 depicts a portion of another example graph  where t1-t1 arevertices. t vertices and m1-m1 are mnote that in general  tree schemes will not properly account for any duplicates arising in multi-path partial results: the tree assumes there are no duplicates in its inputs. to avoid this potential problem  we impose the following correctness condition:
모property 1. edge correctness: an m edge can never be incident on a t vertex  i.e.  an m edge is always between two m vertices.
모that is  a multi-path partial result can only be received by a node running the multi-path scheme  and hence equipped to avoid double-counting . this property can also be expressed as the following equivalent property:
모property 1. path correctness: in any directed path in g  a t edge can never appear after an m edge.
모each property is a sufficient condition for correctness. the full paper  provides necessary and sufficient correctness conditions  which  while permitting additional topologies  add additional complications that make these topologies ill-suited to sensor networks.
모an implication of path correctness is that the m vertices will form a subgraph  a multi-path  delta   that includes the base station  which is fed by trees of t vertices   tribu-of g be taries    as depicted in figure 1. let the delta region
the set of m vertices. coincidentally  any graphis also desirable for high accuracy-partialg satisfying
path correctness
results near the base station account for larger numbers of sensor readings than partial results near the leaves of g  and hence the additional robustness provided by the delta region significantly improves answer accuracy.
모our tributary-delta scheme requires multi-path algorithms that can operate on  approximate or exact  partial results from both tree and multi-path schemes. for example  m1 in figure 1 receives inputs from both a t vertex and two m vertices. we address this algorithmic challenge in section 1.
dynamic adaptation. our goal is to dynamically adapt where in the sensor network we use trees versus where we use multi-path  based on current message loss rates in various regions of the network. however  an implication of edge correctness is that individual vertices cannot switch between the two modes independently. we say an m vertex isedges orswitchable  to a t vertex  if all its incoming edges arevertex istswitchable it has no incoming edges. similarly  a t if its parent is an m vertex or it has no parent. in figure 1  vertices t1  t1  t1  m1  and m1 are switchable. based on these two definitions  we make the following observation.
모observation 1. all children of a switchable m vertex are switchable t vertices.
note that a delta region uniquely defines the set of switchable m and t vertices inswitchableg. the next lemma implies thatt and m vertices  it is by considering only the always possible to expand  or shrink  the delta region if it makes sense to do so. let g1 be the connected component of g that includes the base station. then expanding  shrinking  the delta region only makes sense if there is a t vertex  an m vertex  respectively  in g1. a simple induction proof yields the following result:
모lemma 1. if the set of t vertices in g1 is not empty  at least one of them is switchable. if the set of m vertices in g1 is not empty  at least one of them is switchable.
in the next section  we study strategies for adapting the tributary and delta regions to changing network conditions.
1.	adaptingtonetworkconditions
모in this section we study in detail how our tributary-delta scheme dynamically adapts to changing network conditions.
1	adaptation design
모we first discuss a number of practical issues that arise in designing our adaptation strategies.
adaptation decision. recall from section 1 that the only possible ways to adapt to changing network conditions are  1  to shrink the delta region by switching switchable m vertices  multi-path nodes  toexpand the delta region by switching switchable  t vertices  tree nodes  or  1  tot vertices tree nodes  to m vertices  multi-path nodes . however  because of the different types of errors introduced by the tree and multi-path schemes  recall table 1   it is unclear how switching one or more nodes impacts the answer accuracy. therefore  we require users to specify a threshold on the minimum percentage of nodes that should contribute to the aggregate answer. it then becomes natural for the base station to be involved in the decision process: depending on the % of nodes contributing to the current result  the base station decides whether to shrink or expand the delta region for future results. because there is only minimal communication error in multi-path schemes  recall figure 1   increasing the delta region always increases the % contributing. similarly  decreasing the delta region always decreases the % contributing. the system seeks to match the target % contributing  in order to take advantage of the smaller approximation error in tree aggregation. because this design does not rely on the specifics of any one query  the resulting delta region is effective for a variety of concurrently running queries. designs specialized to particular queries are part of our future work.
synchronization. a key concern in switching individual nodes from tree aggregation to multi-path aggregation  and vice-versa  is how to ensure that nodes that should be communicating after the switch are indeed sending and receiving during the same epoch. when a node switches from m to
tent's listening epoch and change its new children's sending  it needs to change its sending epoch to match its new parepoch to match its listening epoch  etc. conversely  when a node switches from t to m  it needs to change its sending epoch to match the listening epoch of its neighboring nodes in the next level and change its children's sending epoch to match its listening epoch  etc. this re-synchronization overhead could arise  for example  if tag   a popular tree aggregation approach  were to be used together with rings for multi-path  and it would be a large deterrent to switching between tree and multi-path schemes. to ensure that no such re-synchronization is necessary  we make a simplifying design choice: a node in level i when switching from m to
tlevelmmust choose its tree parent from one of its neighbors ini   1. similarly  when the node switches fromi   1  includingt to
모  it transmits to all its neighbors in level its parent. in other words  all tree links should be a subset of the links in the ring. this ensures that the switched node can retain its current epoch  since the new parent in node in levellevel i   1 is already synchronized to receive data from thei. trees constructed with this restriction may have inferior link quality; however  this is mitigated with tributary-delta because  1  we use multi-path to overcome poor link quality and  1  our tree construction algorithm  see section 1.1   which guarantees that tree links are a subset of rings links  produces bushy trees that are effective in reducing total communication errors.
1	adaptation strategies
모in this section  we present two alternative strategies to shrink and expand the delta region. in both strategies  we augment the messages being sent between nodes with an  approximate  count of the number of nodes contributing to the partial result being sent. assuming that the base station knows the number of sensors in the network  it can compute the % contributing to the current result.
strategy td-coarse. in the first strategy  td-coarse  if the % contributing is below the user-specified threshold  the base station expands the delta region by broadcasting a mes-
sage askingtoone level.m nodes.similarly  if the % contributing is well aboveallthis effectively widens the delta region bythe current switchable t nodes to switch
the threshold  it shrinks the delta region by one level by switching all current switchable m nodes to t nodes. the coarse-grained control of td-coarse is well-suited to quickly adapting the size of the delta region to network-wide fluctuations. however  it can not adapt well to different conditions in different parts of the network; for this  we introduce the following more fine-grained strategy.
strategy td. in the second strategy  td  we use the exisnodes and switchabletence of the parent-child relationship among switchablet nodes  observation 1   as follows.m
each switchablean additional field that contains the number of nodes in itsm node includes in its outgoing messages subtree that did not contribute.1 as the multi-path aggregation is done  the maximum  max  and the minimum  min  of such numbers are maintained. if the % contributing is below the user-specified threshold  the base station expands the delta region by switching from t to m all children of switchable m nodes belonging to a subtree that has max nodes not contributing. in this way  subtrees with the greatest robustness problems are targeted for increased use of multi-path. shrinking is done by switching each switchable m node whose subtree has only min nodes not contributing. the fine-grained control of td facilitates adapting to non-uniform network conditions  at a cost of higher convergence time and additional message overhead because the base station needs to send one message every time it switches a small number of nodes. note that there are many possible heuristics to improve the adaptivity of td  such as using max/1 instead of max or maintaining the top-k values instead of just the top-1 value  max . exploration of optimal heuristics is part of our future work.
모note that the delta region in the above constructions may repeatedly shrink and expand  leading to unnecessary adaptation overhead. we use the following simple heuristic to dampen this possible oscillation: if the base station experiences a repeated sequence of expansion and shrinking  it gradually reduces the frequency of adjustments.
1.	computing simple aggregates
모to compute an aggregate in our tributary-delta framework  we need a corresponding tree algorithm  a multi-path algorithm  and a conversion function that takes a partial result generated by the tree algorithm and outputs a synopsis that can be used by the multi-path algorithm. for example  in figure 1  the node m1 receives two multi-path partial results  denoted as bv  and one tree partial result  1 . the conversion function needs to transform the tree result to a synopsis so that m1 can use its synopsis fusion function to combine it.
모the synopsis generated by the conversion function must be valid over the inputs contributing to the tree result. for example  the conversion function for the count aggregate should take the output of the tree scheme-a subtree count c- and generate a synopsis that the multi-path scheme equates with the value c. intuitively  this enables a node running a multi-path algorithm to become oblivious to whether an input synopsis is from a multi-path node or the result of a conversion function applied to a tree result.
모many aggregates  e.g.  count  sum  min  max  average  uniform sample  etc.  with known efficient multi-path  and tree algorithms have simple conversion functions   and hence can be efficiently computed in our tributarydelta framework. moreover  the uniform sample algorithm can be used to compute various other aggregates  e.g.  quantiles  statistical moments  using the framework.
모however  there are no previous  efficient multi-path algorithms for identifying frequent items in sensor networks. this is an important aggregate particularly in the context of biological and chemical sensors  where individual readings can be highly unreliable and it is necessary to get a consensus measure . in the next section  we present our new multi-path algorithm  and extend it to our tributary-delta framework.
1.	identifying frequent items
in this section we present the first energy-efficient tributary-delta algorithm for finding frequent items  describing first the tree scheme  section 1   then the multi-path scheme  section 1   and finally the conversion function  section 1 .
모following  1  1   we consider the following formulation of the frequent items problem. each of the m sensor nodes generates a collection of items. for example  an item can be a value of a sensor reading at a particular point in time. the same  item  may appear multiple times at one or more sensor nodes. let c u  be the frequency of occurrence of item u over all m nodes. given a user-supplied error tolerance   the goal is to obtain for each item-deficient count c  u  at the base station  where each  c u  satisfies

and n denotes the sum of item occurrences across all items  i.e.  n = pu c u . by computing -deficient counts  communication is not wasted aggregating counts for rare items  i.e.  items with . moreover  for small  values  little error is introduced by using -deficient counting for frequent items  i.e.  items with . given a user specified support threshold   similar to  1  1   we report as frequent all items with -deficient counts greater than    thus ensuring that there are no false negatives  and all false positives have frequency at least  .
1	tree algorithm
모in this subsection  we present our tree-based frequent items algorithm  min total-load  the first algorithm for identifying frequent items that uses only  words1 of total communication  which is optimal. the algorithm's guarantees hold for a class of trees that arise naturally in sensor networks. previous tree-based frequent items algorithms  1 
1  1  provided only a weak bound of  on total communication  even for the simplified case of balanced  regular trees.
1.1	solution approach and challenges
모a useful data structure encapsulating the partial result sent by a node x to its parent is a summary  defined as follows. a summary includes a  possibly empty  set of items u and their estimates  c u . each estimate  c u  satisfies max   where n = pu c u  such that c u  is the frequency of item u in the  multi-set  union of the multi-sets belonging to nodes in the subtree rooted at x. the salient property of a summary is that items with frequency at mostneed not be stored  resulting in a smaller-sized summary and therefore  less communication.
모our approach  similar to  1  1   is to distribute the  error tolerance among intermediate nodes in the tree. we make the error tolerance a function of the height of a node  which is defined recursively as follows: the height of a leaf node is 1; the height of any other node is one more than the maximum height of its children. let   denote the error tolerance of a node with height i.
모algorithm 1 presents the steps to generate a summary for a node x of height k  for a generic setting of the 's. proceeding level-by-level up the tree  each node uses algorithm 1 to generate an  -summary  until at last the base station outputs an  -deficient count for each item  where h is the height of the base station. for correctness  we need
algorithm 1: generate a -summary  executed by all nodes  where k is the height of the node 
input: summaries  from each child among the node's children c  and its own summary s1 =
 1   u       
output: single-summary
1. set
1. for each
1. for eachand if  c u  뫞 1 remove  u c  u   from s

 . as long as  the userspecified guarantee is met. the sequence   is called the precision gradient   because the precision of the data gradually decreases as it traverses the aggregation tree.
모thus far the approach has been similar to . the key new challenge we address is how to set a precision gradient that minimizes the worst case total communication and is not restricted to balanced  regular trees. note that when minimizing the maximum load on a link  as considered in previous approaches  1  1   it suffices to bound the load on each link. this is a local property: for a node of height k 
step 1 of algorithm 1 implies that estimates for at most  items will be present in the summary it sends on its outgoing link . total communication  however  is a global property  and requires minimizing a sum. indeed  it is not obvious how to set the precision gradient to achieve optimal total communication  even for regular trees.
1.1	solution: the min total-load algorithm
모we provide intuition for our solution by first considering a balanced  regular tree of degree d. in such trees  the number of nodes at height k is a d1k-th fraction of the number at height 1. moreover  as discussed above  the maximum number of counters sent by a node at height.
	 	 
thus the total communication from height k nodes is proportional to the product of and . to minimize total communication  it is then necessary to have large differences 1  when k is small  so that the total number of counters sent by the numerous height k nodes is kept small. on the other hand  large differences for smaller k's leave only small differences for larger k's  because the sum of all the differences is at most . thus for larger k's  the  term is much larger than for smaller k's.
hence  care must be taken to ensure that the total number of counters sent is kept small even for larger k's  by keeping the term from getting too large. our solution min totalload balances the allocation by setting  1  to be a constant fraction of the final   and then making  vary as ck for some c   d so that the total number of counters  the product ofand  that could possibly be sent
	 	 
by all nodes at height k still decreases with increasing k. to extend our solution to non-regular trees  we exploit the observation that the maximum possible total communication of a tree  with our solution  can only decrease if nodes in an  initially balanced  regular  tree are replaced by nodes of lesser height.
d-dominating tree. min total-load is based on the notion of a d-dominating tree  which we define as follows.
example tree teregular tree t1h1111h i 1111h i 1
1
1
1
1
1
1
1
1table 1: example of a 1-dominating tree.
for any tree  let h i  denote the fraction of nodes having height at most i. mathematically  h i  = m1 pij=1 h j   where h j  denotes the number of nodes at height j and m denotes the total number of nodes. for any d 뫟 1  we say that a tree is d-dominating if for any
 . note that for any tree  h i  is monotonically non-decreasing as i increases  so every tree is 1-dominating. from the definition of a d-dominating tree  it follows that a tree that is  d + 붻 -dominating is also d-dominating for any 붻 뫟 1. also  given any tree and a precision 붻1   1  we can always find some d such that the tree is d-dominating  but not  d + 붻1 -dominating. we refer to such a d as the domination factor for the tree.
모a relatively straightforward induction proof yields the following result:
모lemma 1. a tree in which each internal node of height i has at least d children of height i   1 is d-dominating.
example. consider a tree te with height 1 and h i  values as shown in table 1. the table also shows the h i  and the h i  value of a completely balanced  regular tree t1 of height 1 and degree 1. as the table shows  for all i  h i  of te is at least h i  of t1. from lemma 1  we know that t1 is 1-dominating. therefore  the example tree is 1dominating. assuming the granularity of d is 1  it can be shown that te has a domination factor of 1  i.e.  te is not 1 dominating .
모we are now ready to present the precision gradient settings for our min total-load algorithm:
모lemma 1. for any d-dominating tree of m nodes  where d   1  a precision gradient setting of
i
withlimits total communication to
모proof. in step 1 of algorithm 1  the frequency estimate of each item u is decremented by at least
1  . since pu뫍s c  u  뫞 n  frequency estimates for at most  items are sent by a node at height i to its parent. furthermore  because the maximum number of possible estimates a node at height i can send on its outgoing link increases with its height  뫚 di/1   the total communication for a d-dominating tree is bounded by a  hypothetical  tree in which exactly  fraction of the nodes occur at height i. therefore  the total communication is bounded by:
 m d   1 	1	뫏m d뫏  1  x	1
i=1	i 1    i     i   1   = 	d 	d	1  i=1 d i 1 /1 d d
	뫞 m 뫏d   1	m 뫏뫏d + 1 	m  뫏 1  
	=	=	1 +
	  	d   1		d	1		d	1
1.1	trees with large domination factors
모as lemma 1 shows  our min total-load algorithm works especially well for trees that are d-dominating for high d values. the chief concern for guaranteeing low communication is to ensure that the domination factor d is sufficiently far from 1  say at least 1. in section 1  we show that a realworld sensor deployment has a domination factor of 1  suggesting that while it may be infeasible to construct a regular tree in a sensor network  it may be easy to generate d-dominating trees for d 뫟 1. moreover  we show next an explicit tree construction algorithm that seeks to increase the domination factor.
모we modify the standard tree construction algorithm  described in section 1  with two optimizations. first  when a node in level i chooses its parent  and even when it switches parents  it selects a node only from level i 1; the standard algorithm  allows choosing a parent from the same level. second  we use the following opportunistic parent switching technique  inspired by lemma 1. each node of height j + 1 that has two or more children of height j  pins down any two of its height j children  so that they cannot switch parents  and then flags itself. next  the non-pinned nodes in each level i switch parents randomly to any other reachable non-flagged node in level i   1. as soon as a non-flagged node has at least two flagged children of the same height  it pins both of them and then flags itself. this local search technique quickly makes the tree 1-dominating if there is an opportunity to do so.
1.1	extensions
모in the full paper   we provide the details on the following two extensions to our tree algorithm.
combining objective functions. limiting total communication places an upper bound on the energy usage of all the sensors. however  in some cases  limiting the maximum load on a link is also very important  1  1  1 . a precision gradient setting that simultaneously achieves both optimal  within constant factors  maximum and optimal  within constant factors  total communication  can be obtained  by combining solutions that are optimal for each of the two individual metrics. we call this variant of our algorithm hybrid  because its objective function includes both maximum and total communication.
computing quantiles. the quantiles algorithm by greenwald and khanna  can be extended to use our precision gradients and hence to achieve useful bounds. for example  our techniques above for bounding total communication to
  words and for simultaneously bounding multiple communication metrics can be easily extended to the problem of finding quantiles. as such  they are the first quantiles algorithms that achieve these bounds.
1	multi-path algorithm
모we are aware of two previous multi-path algorithms for computing frequent items. we find that both algorithms  one that performs multi-path counting of the items in the network and keeps track of the items with high count values   and the other that uses sampling   suffer from relatively high false positive and false negative rates under a real sensor dataset . we address this problem with a new multi-path algorithm for finding frequent items with high accuracy.
모ideally  we would like to base our algorithm on algorithm 1  adapting it to be duplicate-insensitive so that it works correctly in the multi-path setting. steps 1 and 1 of algorithm 1 are readily adapted: simply replace the addition operator in those steps with a known duplicate-insensitive

algorithm 1: synopsis fusion function
inputs: synopses s1 = hn 1 { u c 1 u  }i and s1 = hn 1 { u  c 1 u  }i  of class i
output: synopsis s = hn   { u c  u  }i  of either class i or i + 1
1. set  n := n 1  n 1	  is duplicate-insensitive sum 
1. for each item u 뫍  s1 뫋 s1   add  u c 1 u   c 1 u   to s
1. if  n   1i+1  then increment the class of s from i to i + 1 and for each item u 뫍  s1 뫋 s1 : if    drop  u c  u   from s  we restrict 붾   1 

addition operator  which we will denote  . step 1 is more problematic  however  because it uses a subtraction operator and no duplicate-insensitive subtraction algorithms exist that combine high accuracy with small synopses.
overcoming the duplicate-insensitive subtraction problem. most duplicate-insensitive addition algorithms  for positive numbers  guarantee that the error in their estimates is at most a constant factor of the actual value. specifically  for a user-specified relative error 1  and confidence parameter 붻c  1   붻c   1  the estimate is within a relative error c of the actual sum with probability at least 1   붻c. because each added item increases the actual sum  the allowed absolute error increases. if subtraction were allowed  the actual value would decrease and it is not known how to achieve a corresponding reduction in error while preserving a small synopsis.
모our solution is to avoid using subtraction altogether. first  we note that the primary purpose of the subtraction in step 1 is to enable items with small estimated counts to be dropped from the summary. instead of subtracting at each node and dropping the item if its estimate is negative  we eliminate the subtraction and drop the item if its estimate is below a rising threshold.
모second  we observe that we do not need highly accurate duplicate-insensitive addition in our thresholding approach. if we give ourselves some slack on the threshold  then we can tolerate less accurate addition and will not drop items we should not have dropped. we may fail to drop some items that should be dropped  but this does not change the asymptotic communication bounds. the importance of making use of less accurate addition arises from the fact that known duplicate-insensitive addition algorithms  1  1  1  1  require synopses whose size is proportional to . when  this equals 1; when  this equals 1.
모finally  our algorithm adapts from  the concept of classes. a synopsis is in class i if i is the logarithm of the number of items it represents. the idea is to have the error tolerance  of a synopsis vary linearly with its class number and only combine synopses having the same class. assuming there are no duplicates  doing so ensures that there is always an opportunity for further pruning once any two synopses are combined. therefore  a synopsis never becomes too large. even with duplicates  as our analysis later shows  the size of a synopsis does not grow beyond a constant factor of the case when there are no duplicates. also  because the count for the total number of items represented by a synopsis is approximate  because  is used   this approximate count determines the class of a synopsis. as long as the relative error is less than 1  there are at most logn + 1 classes of synopses varying from i = 1 ... logn.
모we now describe the components of our multi-path algorithm  using the terminology presented in section 1.
synopsis generation. each sensor node processes its collection of items by counting item frequencies and discarding  pruning  all items u whose frequency is at most   where n1 is the total number of items in its collection and i = blogn1c. then the node generates a class i synopsis by using a duplicate-insensitive addition algorithm to compute a frequency estimate of each remaining item. if the node is a leaf node  it forwards the synopsis to its parent.
synopsis fusion. each intermediate node  in general  receives from each of its children at most a single synopsis of each class. after receiving all synopses from its children  beginning with the smallest class for which the node has a synopsis  the node starts combining two synopses of the same class using algorithm 1  until it is left with at most one synopsis of each class. it then transmits the resulting collection of synopses to its parent. the parameter 붾 controls the accepted slack in the thresholding procedure  as a function of the error parameter c.
synopsis evaluation. finally  at the base station  the frequency estimates corresponding to an item are simply added  again using   across all the different logn classes.
accuracy and communication bounds. the accuracy and communication bounds of our algorithm are summarized in the following theorem. the bounds are in terms of the number of sensors m  the total number of items n  the user-specified error tolerance  and confidence parameter 붻  and the relative error parameter   where  and c are each between 1 and 1. in addition  the bound assumes that the duplicate-insensitive sum operator  is also accuracy-preserving  as defined next.
모definition 1. suppose denotes an    -estimate of a scalar x  with a relative error of c  and a confidence parameter of 붻c. then  the operator  is called an accuracy
preserving duplicate-insensitive sum operator if 
  where z = x + y .
모an example of an accuracy preserving duplicate-insensitive sum operator can be found in .
모theorem 1. when  is an accuracy preserving duplicateinsensitive sum operator  then with probability at least 1 붻  for all items u  the algorithm produces estimated frequencies c  u  such that  1 u .
moreover  the maximum load on a link is  memory words.
the proof is left to the full paper .
1	tributary-delta algorithm
모recall from the discussion in section 1 that to combine tree and multi-path algorithms  we need a conversion function that takes a partial result generated by the tree algorithm and outputs a synopsis that can be used by the multi-path algorithm. for frequent items  when using our tree and multi-path algorithms provided in section 1 and section 1 respectively  this conversion function can simply be the synopsis generation  sg  function of our multi-path algorithm  applied to the estimated frequencies of the tree algorithm. specifically  we take the summary   c  u  }i from algorithm 1 and view  c u  as the actual frequency to which we apply the thresholding test of sg  section 1   letting the n1 in sg be the n from the summary  in order to create the synopsis. in this way  the final error in estimating the frequency of an item is at most the sum of the errors in the tree and the multi-path algorithm. so  given a user-specified error   we can obtain  approximate  -deficient counts in the tributary-delta framework  by running our tree-algorithm with error tolerance a  where
  and our multi-path algorithm with error tolerance
b  such that.
1.	experimental results
모in this section we evaluate our two proposed tributarydelta approaches  td-coarse and td  in varying network conditions  using existing tree and multi-path approaches as baselines. we begin in section 1 by describing the real-world data and the simulation environment we used. then  in section 1  we show the different ways in which
td-coarse and td adapt to changes in network conditions. using a simple aggregate  sum   we report the error reductions due to our proposed approaches over the baseline approaches in section 1. finally  in section 1  we provide measurements of communication load for our frequent items algorithm min total-load and evaluate td-coarse and td for this more complex aggregate.
1	methodology
모we implement tag   sd  and our proposed tributarydelta approaches  td-coarse and td  within the tag simulator . tag is a tree-based aggregation approach used by tinydb   whereas sd  for synopsis diffusion  is a multi-path aggregation approach over rings . in each simulation run  we use sum as the aggregate collecting an aggregate value every epoch for 1 epochs  unless noted otherwise. we begin data collection only after the underlying aggregation topologies become stable. in all the experiments  we use a variant of   as in   for achieving duplicate-insensitive addition. we allow the tributarydelta approaches to adapt their topologies every 1 epochs. recall from section 1 that the adaptivity decisions in our proposed approaches are guided by a threshold on the percentage of nodes contributing to the aggregate. we use 1% as the threshold. we use 1-byte messages  as used by the tinydb system. this allows us to fit 1-bit sum synopses  with the help of run-length encoding   within a single message  and produce an approximate sum based on the average of these 1 estimates.
scenarios. we use labdata  a scenario reconstructing a real deployment  and synthetic  a synthetic scenario with several failure models  for our experiments. using actual sensor locations and knowledge of communication loss rates among sensors  labdata simulates a deployment of 1 sensors recording light conditions in the intel research berkeley laboratory . the dataset contains around 1 million sensor readings. the synthetic scenario is a deployment of 1 sensors placed randomly in a 1 ft 뫄 1 ft grid  with a base station at location  1 . we study two failure models for synthetic: global p   in which all nodes have a message loss rate of p  and regional p1 p1   in which all nodes within the rectangular region { 1   1 } of the 1 뫄 1 deployment area experience a message loss rate of p1 while other nodes have a message loss rate of p1.
1 adaptivity of td-coarse and td to study the adaptivity of td-coarse and td  we apply

figure 1: evolution of the td topology for varying loss rates. each dot depicts a sensor located at the given coordinates in the deployment area. the larger dots comprise the delta region. the base station is at  1 .
the regional p1 p1  failure model with increasing p1 and a fixed p1 = 1. in td-coarse  because the delta region expands uniformly around the base station  all nodes near the base station are switched to multi-path  even those experiencing small message loss. in td  this problem does not arise because the delta region expands only in the direction of the failure region. figure 1 a  and figure 1 b  capture pictorially the response of td to such localized failures. even at a high loss rate  in td  the delta region mostly consists of nodes actually experiencing high loss rate.
모when a global p  failure model with increasing values of p is applied  both td-coarse and td respond similarly by increasing their delta regions   differing only in how the increase is achieved-expanding by all switchable nodes at a time for td-coarse versus gradually for td.
1	evaluation using a simple aggregate
모in this section we evaluate the error reduction of our two proposed approaches  td-coarse and td  in varying network conditions  using the tag and sd approaches as baselines. we restrict ourselves to simple aggregates like count and sum for which the partial results can fit in a single tinydb packet for both tag and sd. to ensure that all approaches use comparable energy levels  we disallow retransmissions  as in the original tinydb implementation .
we measure the error as the relative root mean square
 rms  error-defined as  where v is the actual value and vt is the aggregate computed at time t. the closer this value is to zero the closer the aggregate is to the actual value.
real scenario. we find the rms error in evaluating the sum aggregate on labdata to be 1 for tag and 1 for sd. both td and td-coarse are able to reduce the error to 1 by running synopsis diffusion over most of the nodes.
synthetic scenarios. for the remainder of this section  we use synthetic scenarios. figure 1 a   the complete graph for figure 1  presents the rms error of different schemes under the global p  failure model. at all loss rates in both cases  the error for either td-coarse or td is no worse than the minimum of tag or sd. in particular  the error is reduced significantly at low loss rates  1 뫞 p 뫞 1   when some tree nodes can directly provide exact aggregates to the base station. this effect is more pronounced in figure 1 b  with the td strategy under a regional p 1  failure model. td uses multi-path aggregation only in the failure region and so exact aggregation over a significant portion of nodes can be

 a  global p  failure  b  regional p 1  failure figure 1: rms errors and loss rates.
carried out using tree aggregation.
모next  to evaluate how well our tributary-delta schemes adapt to dynamic scenarios  starting with the global 1  failure model  we first introduce regional 1 1  at time t = 1. then at t = 1  we switch to global 1 . finally  at t = 1  we restore the global 1  failure model. figure 1 shows the relative errors of the answers provided by different schemes over time. we use relative error instead of rms error because each data point corresponds to just a single aggregate answer.
모as expected  figure 1 a    tag is more accurate when loss rates are low  t 뫍  1  or t 뫍  1   whereas sd is more accurate when loss rates are high  t 뫍  1  . figure 1 b  and figure 1 c  compare the relative errors of td-coarse and td with the smallest of the errors given by tag and sd. at a high level  both td-coarse and td  when converged  have at most the error given by any of the two existing approaches. however  the graphs reveal a number of subtle differences between the two tributary-delta schemes. first  because td can adjust its delta region at a finer granularity  it can converge to provide a more accurate result. second  the coarse granularity of td-coarse adversely affects its convergence: the delta region continues to expand and shrink around the optimal point  e.g.  for t 뫍  1  in figure 1 b  . the base station can use simple heuristics to stop the oscillation  e.g.  at t = 1   but even then it may end up using a delta region larger than necessary. finally  the benefits of td come at the cost of a higher convergence time compared to td-coarse. as shown in figure 1 c   td takes around 1 epochs to converge after the network condition changes. the time can be reduced by carefully choosing some parameters  e.g.  how often the topology is adapted   a full exploration of which is beyond the scope of this paper.
1	evaluation with frequent items
모we begin in section 1.1 by evaluating our tree construction algorithm presented in section 1.1. then  in section 1.1  we evaluate min total-load  our efficient frequent items algorithm for trees. finally  in section 1.1  we evaluate td-coarse and td for the frequent items aggregate.
1.1	evaluation of tree construction algorithm
모as mentioned in section 1.1  our min total-load algorithm has smaller overhead  by constant factors  if the aggregation tree is d-dominating for large d values. we note that  in practice  typical sensor deployments tend to have this property. for example  we find the labdata dataset to have a domination factor of 1.
모figure 1 a  and figure 1 b  show the domination factors of the aggregation trees in different synthetic scenarios.


	 a  tag and sd	 b  td-coarse	 c  td
figure 1: timeline showing the relative errors of different aggregation schemes.	 1 1 1 1	 1	 1 1 1	 1 1 1 1 1
	density	deployment area width
	 a  effect of density	 b  effect of deployment shape
figure 1: improvement in domination factor due to our tree construction algorithm.

figure 1: average and maximum load of a sensor in a tree topology.  note the log-scale on the y-axis. 
in figure 1 a   while keeping the deployment area fixed at 1뫄1  we vary the sensor density. in figure 1 b   we keep the sensor density fixed  1 sensor per square unit area  and vary the size of the deployment area by changing its width  the height remains 1 across all experiments . the graphs show that our tree construction algorithm  section 1.1  significantly improves the domination factor d. this is particularly useful when the domination factor of the tree is low because of low sensor density or narrow deployment area  since even a slight improvement in the d value greatly reduces the constant factor in min total-load  which is proportional to 
1.1	frequent items over tree
모figure 1 compares our two frequent items algorithms min total-load  section 1.1  and hybrid  the algorithm mentioned in section 1.1  against the two best known existing algorithms: min max-load  and quantilesbased1 . we report the average and maximum load  number of integer values transmitted  of a node  under no message loss  on two sets of data. the first two sets of bars in the graph represent the results with the labdata dataset. the graph shows that even though the communication load of our hybrid algorithm is only guaranteed to be within a factor of 1 of the best of min total-load and min maxload   with our real-world data set it performs significantly better. specifically  hybrid is 1% and 1% better than the best of min max-load and min total-load for average load and maximum load  respectively. it also shows that even though our min total-load algorithm does not aim to reduce maximum load of a node  in practice it performs very close to min max-load. the quantiles-based algorithm performs significantly worse than the other algorithms because it is not optimized for the bushy tree we encounter in labdata.
모as discussed in section 1  the average load for our min total-load and hybrid algorithms is upper bounded by a constant for any dataset  recall lemma 1 and section 1.1 noting that the average load is the total communication divided by the number of nodes   whereas it is logarithmic in the number of nodes for min max-load and quantilesbased. therefore  we can always construct a stream of items for which the improvement of min total-load and hybrid over min max-load and quantiles-based is significant  e.g.  zero vs. nonzero . as an example  in the last two sets of bars in figure 1  we present results over a synthetic dataset  in which every sensor node receives a stream of items such that  1  the same item never occurs in multiple streams and  1  within a stream the items are uniformly distributed. as shown  min total-load incurs only half the total communication required for the min max-load algorithm.
1.1	frequent items over tributary-delta
모similar to the methodology in  1  1   we use min totalload with error margin 1% to report all items with frequency more than the support threshold s = 1% of the total number of item occurrences in the labdata. however  because communication failures mean that the tree part may not meet this error margin guarantee  we likewise relax the multi-path part's error guarantees  in order to reduce message overheads. in particular  instead of using an accuracy preserving duplicate-insensitive sum operator  definition 1   which would be necessary for providing error guarantees  we continue using the low overhead  best-effort algorithm in .  the full paper  discusses the performance of min total-load when using .  to compensate for the undercounting in the tree part  we report all items whose estimated counts are more than    of the total count. this introduces false positives in the result. however we find this

	 a  global loss	 b  global loss & retransmission
figure 1: false negatives in the estimated frequent items.  false positives are   1%. 
to be small    1%  in our experiments with no communication failures. communication failures further reduce the false positive rate  but introduce false negatives in the estimated results because some of the items with frequency above fraction s are not reported due to under-estimation resulting from message loss.
모figure 1 a  shows the false negative rates of different aggregation schemes under the global p  failure model. as in our previous results  td performs as well as the tag or sd schemes alone. in the full paper   we show that under regional p 1   td is significantly better than tag or sd  in line with our previous results.
모in contrast to the sum or count aggregate studied in section 1  with the frequent items aggregate  a multi-path partial result can consist of more tinydb messages than a tree partial result  1 times on average in this experiment . to make both approaches use comparable energy while keeping the latency  which increases linearly with the number of retransmissions  acceptable  we let the tree nodes retransmit their messages twice.1 keeping the latency low is particularly important for many real-time monitoring and control applications . the results are shown in figure 1 b . as expected  retransmission significantly reduces the false negatives of tag. still  at loss rates greater than 1  the multipath algorithm still outperforms the tree algorithm and td can effectively combine the benefits of both the algorithms.
1.	conclusion
모in this paper  we have presented tributary-delta  a novel energy-efficient approach to in-network aggregation in sensor networks. tributary-delta combines the advantages of the existing tree- and multi-path-based approaches by running them simultaneously in different parts of the network. we have studied this new approach and presented schemes for adjusting the balance between tributaries and deltas in response to changes in network conditions. we have also shown how a difficult aggregate for this context-finding frequent items-can be efficiently computed in the tributarydelta framework. our simulation results on real-world and synthetic data showed that our techniques are greatly superior to the existing tree- and multi-path-based approaches. for example  in computing count under realistic loss rates  our techniques can reduce errors by up to a factor of 1 compared to any previous technique.
