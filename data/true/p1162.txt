order-based queries over xml data include xpath navigation axes such as following-sibling and following. in this paper  we present holistic algorithms that evaluate such order-based queries. an experimental comparison with previous approaches shows the performance benefits of our algorithms.
categories and subject descriptors: h.1  database management : systems-query processing
general terms: algorithms  experimentation
keywords: holistic algorithms  order-based queries  xml
1. introduction
　xml is poised to become the basis for web-based and databasecentric applications. thanks to standard specifications for web services  such as soap  wsdl  etc.   applications can receive requests for data and return their answers tagged in xml. a key issue in xml data management is effective support of the ordered  tree-structured data model that the language employs.
　consider an xml database of articles. for each article entry  the tree structure and the order in which its sections are listed is relevant. information extraction tools can extract the sections of an article following the related work section using the query:
/article/section title	'related work' / following-sibling::section
　queries with navigation axes such as following-sibling and following are referred to as order-based queries. this paper complements previous approaches  1  1  1  and investigates whether holistic techniques can be devised to answer order-based queries in xpath and xquery. our contributions are:
1. we devise algorithms for the following-sibling and following axes as well as their backward counterparts.
1. we propose holistic approaches for  twig  queries with orderbased forward and backward axes of the same type.
1. we experimentally show that our solutions offer better queryperformance than previous approaches.
　we proceed with section 1 that describes our techniques  while in section 1  their efficiency is experimentally investigated. section 1 concludes the paper.

 the research of zografoula vagena and vassilis j. tsotras was partially supported by nsf grant iis-1  uc micro and lotus interworks.
copyright is held by the author/owner.
www 1  may 1  1  chiba  japan. acm 1-1/1.
1. algorithmic approaches
　we describe set-based processing techniques for the order-based axes. for queries that contain both forward and backward axes  we first convert the backward axes into their forward counterparts  based on the ideas presented in . efficient algorithms are then developed to answer the modified queries.
1 the tree encoding
　to enable set-at-a-time structural matching  we map the document into sequences of nodes. each sequence maintains nodes with the same tag and each node is augmented with information that identifies its position within the xml tree  as in . the position of an xml node is represented as:  leftpos  rightpos  prightpos  where:  a  leftpos and rightpos are generated by counting tags from the beginning of the document until the start and the end tags of the element are visited  respectively  and   c  prightpos is the rightpos of its parent node. several structural relationships between elements can thus be identified. an element follows an element if the rightpos of is smaller than the leftpos of . similarly  an element is following-sibling of an element if the rightpos of is smaller than the leftpos of and the prightpos of is equal to the prightpos of .
1 single forward axis step
　consider the query /following-sibling:: . our processing algorithm's input consists of two streams  one with nodes and one with nodes. these streams are sequentially accessed  effectively computing a  merge  join. an important observation is that the following-siblings for some document node occur after its descendants have been encountered. in other words  node has to be buffered until the following-siblings of its descendants have been processed first. this is achieved by maintaining a stack that keeps nodes which have been accessed and are still needed to identify future following-sibling nodes. note that an node may be followed by many other nodes with the same label. such nodes conceptually form a linked-list  csl list . new nodes are appended to the end of such a list. if a node becomes a following-sibling to the node at the end of a csl list  it is automatically a followingsibling to all other nodes in that list.
　if the query contains a following axis  we need to identify for each document node with label   all nodes that occur after in document order and are not its descendants. the processing algorithm resembles the one for the following-sibling axis. the main difference is that after having identified the first match for a node   all other nodes in the stream have to be joined with it.
　since the processing of the two forward axes are similar  we focus on the following-sibling axis from now on.
1
1 non-branching forward path
　such queries contain a number of steps where all the intermediate nodes correspond to context nodes  while the leaf corresponds to a test node. the algorithm maintains one stack for each query context node. each stack buffers nodes with following-siblings yet to be visited. in addition  a number of csl lists are associated at each time with a stack. the role of a csl list is similar to that in section 1  i.e.  to hold context-siblings. what is different  however  is that now an element that is added in a csl list   remembers  the latest element  in document order  in the previous query step for which is a following-sibling. this is achieved by maintaining a step-pointer from to the current last element in the corresponding csl list of . step-pointers combine information between query steps and  along with the csl lists  encode all partial results of the query. when a test node is accessed and the stack of the previous step is not empty  the following-sibling paths containing that node are decoded and returned.
1 branching forward path
　the most general query has the form of a subtree  or twig . such queries can be processed holistically through a variation of the twigstack  algorithm  which dealt with twig queries containing descendant and child axes. one thing to note here is that although twigstack can guarantee node participation in the final result for queries with the descendant axis by inspecting a bounded number of lookahead symbols  such guarantees are not possible in the case of the following-sibling axis. the reason is that  as with the child axis  the necessary number of lookahead symbols is in the order of the size of the document.
1 forward and backward axes
　by adapting the method proposed in   a twig query with both following-sibling and preceding-sibling axes can be converted to a dag query with only following-sibling axes. the key issue that needs to be addressed for dag queries is that a query node may have multiple parents in the query  i.e.  may need to satisfy the following-sibling constraint for multiple context query nodes. we call such a query node a join node from now on. for a document node to participate in one total result  it is necessary that:  a  has a following-sibling in each of the document node sequences that correspond to children of in the query   b  is following-sibling for at least one in each of the document node sequences that correspond to parent nodes of in the query   c  each of the following-sibling nodes recursively satisfies this property   d  each of the nodes recursively satisfies this property  and  e  the join node conditions are satisfied. with that in mind  we modify the approaches  described in the previous sections  so as to check that a produced dag instance satisfies all these constraints. the special shape of the query dag  i.e.  if a node has two or more parents  their unique common ancestor is the
root node  enables the efficient checking of the above constraints.
1. experimental evaluation
　in this section  we present experimental results comparing the performance of the proposed algorithms  we refer to them as gnf  with the staircase  and arb  approaches. the dataset we used was the 1g  text  database generated by the xmark benchmark. we used the queries shown in table 1. staircase join was excluded from query q1 as it does not directly support twig queries. for the arb algorithm  we report the time after the arb database has been created.
　the results are presented in figure 1. in each case  the gnf technique performed better. for the single step query q1  staircase
q1 :incategory/following-sibling::mailboxq1 :location/following-sibling::incategory/ following-sibling::mailboxq1 :location ./following-sibling::incategory / following-sibling::mailboxtable 1: queries for xmark data

figure 1: staircase join  arb and gnf.
and gnf perform very similarly because both algorithms take into consideration only elements that are needed to create the results. when the number of query steps increases  the staircase becomes worse because it incurs the overhead of the intermediate result materialization. in every case  arb performed considerably worse; this is because it needs to access the whole document twice for each query  while the other two approaches take into consideration only relevant parts of the documents.
1. conclusions
　we studied the problem of supporting the ordered  tree shaped model of xml data. we proposed efficient algorithms to answer queries with the order-based navigation axes  both forward and backward ones   and validated them experimentally. to the best of our knowledge  this is the first approach that addresses those navigational axes in a complete  scalable  xml model-aware fashion.
