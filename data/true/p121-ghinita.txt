mobile devices equipped with positioning capabilities  e.g.  gps  can ask location-dependent queries to location based services  lbs . to protect privacy  the user location must not be disclosed. existing solutions utilize a trusted anonymizer between the users and the lbs. this approach has several drawbacks:  i  all users must trust the third party anonymizer  which is a single point of attack.  ii  a large number of cooperating  trustworthy users is needed.  iii  privacy is guaranteed only for a single snapshot of user locations; users are not protected against correlation attacks  e.g.  history of user movement .
　we propose a novel framework to support private locationdependent queries  based on the theoretical work on private information retrieval  pir . our framework does not require a trusted third party  since privacy is achieved via cryptographic techniques. compared to existing work  our approach achieves stronger privacy for snapshots of user locations; moreover  it is the first to provide provable privacy guarantees against correlation attacks. we use our framework to implement approximate and exact algorithms for nearest-neighbor search. we optimize query execution by employing data mining techniques  which identify redundant computations. contrary to common belief  the experimental results suggest that pir approaches incur reasonable overhead and are applicable in practice.
categories and subject descriptors
h.1  general : security  integrity  and protection; h.1  database applications : spatial databases and gis
general terms
design  experimentation  security
keywords
location anonymity  private information retrieval  query privacy
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod'1  june 1  1  vancouver  bc  canada.
copyright 1 acm 1-1-1/1 ...$1.
1. introduction
　an increasing number of communication devices  e.g.  mobile phones  pdas   feature positioning capabilities  e.g.  gps . users can ask location-dependent queries  such as
 find the nearest hospital   which are answered by location based services  lbs  like mapquest or google maps. however  queries may disclose sensitive information about individuals  including health condition  lifestyle habits  political and religious affiliations  or may result in unsolicited advertisement  i.e.  spam . privacy concerns are expected to rise as lbss become more common.
　observe that privacy is not protected by replacing the real user identity with a fake one  i.e.  pseudonym   because  in order to process location-dependent queries  the lbs needs the exact location of the querying user. an attacker  which may be the lbs itself  can infer the identity of the query source by associating the location with a particular individual. this can be easily performed in practice  with the help of a public telephone directory  for instance  which contains subscribers' addresses.
　most existing solutions adopt the k-anonymity  principle: a query is considered private  if the probability of identifying the querying user does not exceed 1/k  where k is a user-specified anonymity requirement. to enforce this principle  a trusted third-party anonymizer is employed  1  1  1  1   see figure 1 . the anonymizer maintains the current locations of all subscribed users. instead of sending the nearest neighbor  nn  query to the lbs  the user  alice in our example  contacts the anonymizer  which generates a cloaking region  cr  enclosing alice as well as k   1 other users in her vicinity. in figure 1  k = 1 and the cr contains u1 and u1 in addition to alice. the cr is sent to the lbs  which cannot identify alice with probability larger than 1/k. the lbs computes a candidate set that includes all points of interest  poi  which may potentially be the nn for any point within the entire cr . the candidate set  i.e.  {p1 p1 p1 p1}  is sent back to the anonymizer  which filters the false hits and returns the actual nn  i.e.  p1  to alice. we discuss these methods in section 1.
　existing methods have several drawbacks:  i  the anonymizer is a single point of attack: if an attacker gains access to it  the privacy of all users is compromised. it is also a bottleneck  since it must process the frequent updates of user locations.  ii  a large number of users must subscribe to the service  otherwise cr cannot be constructed. it is assumed that all users are trustworthy. however  if some of them are malicious  they can easily collude to compromise the privacy

 authors' work has been funded by nsf grant nsf-1

figure 1: existing three-tier architecture
of a targeted user.  iii  it is assumed that the attacker has no background information about the users  but in practice it is difficult to model the exact knowledge. assume that alice is searching for the nearest women's clinic  and the cr contains alice and bob. from the query content  the attacker can identify alice as the query source.  iv  privacy is guaranteed only within a static snapshot of user locations; users are not protected against correlation attacks. for example  if alice asks the same query from different locations as she moves  she can be easily identified because she will be included in all crs.
　we propose a framework for private location-dependent queries that solves these problems. our framework is based on the theory of private information retrieval  pir  and does not need an anonymizer. recent research on pir  1  1  resulted in protocols that allow a client to privately retrieve information from a database  without the database server learning what particular information the client has requested. most techniques are expressed in a theoretical setting  where the database is an n-bit binary string x  see figure 1 . the client wants to find the value of the ith bit of x  i.e.  xi . to preserve privacy  the client sends an encrypted request q i  to the server. the server responds with a value r x q i    which allows the client to compute xi. we focus on computational pir  which employs cryptographic techniques  and relies on the fact that it is computationally intractable for an attacker to find the value of i  given q i . furthermore  the client can easily determine the value of xi based on the server's response r x q i  . pir theory is discussed in section 1.
　in this paper we show that pir can be used to compute privately the nearest neighbor of a user with acceptable cost  by retrieving a small fraction of the lbs' database. consider the example of figure 1.a  where u is the querying user and the lbs contains four points of interest p1 p1 p1 p1. in an off-line phase  the lbs generates a kd-tree index of the pois and partitions the space into three regions a b c.
to answer a query  the server first sends to u the regions

x1x1...xnfigure 1: pir framework
p1b
p1
up1

a　1 p1
c1
	 a  approximate nn	 b  exact nn
figure 1: finding the nearest neighbor of u
a b c. the user finds the region  i.e.  a  that contains him  and utilizes pir to request all points within a; therefore  the server does not know which region was retrieved. the user receives the pois in a in encrypted form and calculates p1 as his nn. the method can be used with a variety of indices. in section 1 we present implementations based on the hilbert curve and on an r-tree variant. note that the result is approximate; in our example the true nn is p1. we show experimentally that the approximation error is low.
　we also propose a method for finding the exact nn. in a pre-processing phase  the server computes the voronoi diagram for the pois  see figure 1.b . each poi pi is assigned to its voronoi cell; by definition  pi is the nn of any point within that cell. the server superimposes a regular grid of arbitrary granularity on top of the voronoi diagram. each grid cell stores information about the voronoi cells intersecting it. for example d1 stores {p1}  whereas c1 stores {p1 p1}. upon asking a query  the client first retrieves the granularity of the grid  and calculates the grid cell that contains him  i.e.  c1 . then  he employs pir to request the contents of c1. he receives {p1 p1}  encrypted  and calculates p1 as his exact nn. the method is described in section 1. note that the cost is typically higher compared to approximate nn.
　pir has been criticized of being too costly to be applied in practice.  showed that the computational time of pir may be longer than the time required for an oblivious transfer of the database.  assumes that the server agrees to surrender the entire database to the client. in practice  this is rarely the case  since the database is a valuable asset for the server  who charges the client  either directly or indirectly  e.g.  advertisements   based on the actual usage. moreover  most queries do not need to retrieve the entire database. still  the cpu cost of pir can be high  since it involves numerous multiplications of large numbers. nevertheless  we show that much of the computation is redundant. in section 1 we develop a query optimizer which employs data mining techniques to identify such redundancy. the resulting execution plan is up to 1% cheaper in terms of cpu cost. moreover  we show that the required computations are easily parallelized.
summarizing  our contributions are:
1. we propose a novel framework for private locationdependent queries  which uses pir protocols and eliminates the need for any trusted third party. our work is the first to provide provable privacy guarantees against correlation attacks.
1. we develop algorithms for approximate and exact private nearest neighbor search. we utilize data mining techniques to optimize query execution.
1. we show experimentally that the cost is reasonable;hence our methods are applicable in practice.
1. related work
　most existing approaches for private location-dependent queries follow the user-anonymizer-lbs framework of figure 1. the anonymizer sends to the lbs a cloaking region  cr  instead of the actual user location; this procedure is called cloaking. ref.  combines spatial with temporal cloaking. each query q specifies a temporal interval δt that the corresponding user u is willing to wait. if within δt  k   1 other clients in the vicinity of u also issue queries  all these queries are combined in a single cr; otherwise  q is rejected. in casper   the anonymizer maintains the locations of the clients using a pyramid data structure  similar to a quad-tree. assume u asks a query and let c be the lowest-level cell of the quad-tree where u lies. if c contains enough users  i.e.  |c| − k   c becomes the cr. otherwise  the horizontal ch and vertical cv neighbors of c are retrieved. if |c “ ch| − k or |c “ cv| − k  the corresponding union of cells becomes the cr; otherwise  the anonymizer retrieves the parent of c and repeats this process recursively. interval cloak  is similar to casper in terms of both the data structure used by the anonymizer  a quad-tree   and the cloaking algorithm. the main difference is that interval cloak does not consider neighboring cells at the same level when determining the cr  but ascends directly to the ancestor level. casper and interval cloak guarantee privacy only for uniform distribution of user locations.
　hilbert cloak  uses the hilbert space filling curve to map the 1-d space into 1-d values. these values are then indexed by an annotated b+-tree. the algorithm partitions the 1-d sorted list into groups of k users  the last group may have up to 1k   1 users . for querying user u the algorithm finds the group to which u belongs  and returns the minimum bounding rectangle of the group as the cr. the same cr is returned for any user in a given group. hilbert cloak guarantees privacy for any distribution of user locations.
　the previous approaches assume a static snapshot of user locations and do not consider correlation attacks  e.g.  history of user movement . in   correlation attacks are handled as follows: at the initial timestamp t1  cloaking region cr1 is generated  which encloses a set as of at least k users. at a subsequent timestamp ti  the algorithm computes a new anonymizing region cri that encloses the same users in as  but contains their locations at timestamp ti. there are two drawbacks:  i  as users move  the resulting cr may grow very large  leading to prohibitive query cost.  ii  if a user in as disconnects from the service  the query must be dropped. furthermore  in  it is assumed that there are no malicious users.
　privacy in lbs has also been studied in the context of related problems. in   the cr is a closed region around the query point  which is independent of the number of users inside. given cr  the lbs returns the probability that each candidate result satisfies the query based on its location with respect to the cr. ref.   on the other hand  eliminates the anonymizer by organizing users in a peer-to-peer system. the querying user u searches his neighborhood until he finds k   1 other peers  which are used to construct the cr. however  u tends to be close to the center of the cr; therefore an attacker can identify u with high probability. ref.  also uses a peer-to-peer system to support distributed anonymization; although a centralized anonymizer is not required  all users must trust each other. more relevant to our work is the approach of : in a preprocessing phase  a trusted third party transforms  using 1-d to 1-d mapping  and encrypts the database. the database is then uploaded to the lbs  which does not know the decryption key. all users possess tamper-resistant devices which store the decryption key  but they do not know the key themselves. users send encrypted queries to the lbs and decrypt the answers to extract the results. the method assumes that none of the tamper-resistant devices is compromised. if this condition is violated  the privacy of all users is threatened.
　our work builds on the theoretical results of private information retrieval  pir   which is defined as follows: a server s holds a database with n bits  x =  x1 ...xn . a user u has a particular index i and wishes to retrieve the value of xi  without disclosing to s the value of i. the pir concept was introduced in  in an information theoretic setting  requiring that even if s had infinite computational power  it could not find i. it is proven in  that in any solution with a single server  u must receive the entire database  i.e.  Θ n  cost . nevertheless  in practice  it is sufficient to ensure that s cannot find i with polynomial-time computations; this problem is known as computational pir.  showed that the communication cost for a single server is Θ nε   where ε is an arbitrarily small positive constant. our work employs computational pir.
　several approaches employ cryptographic techniques to privately answer nn queries over relational data. most of them are based on some version of the secure multiparty computation problem . let two parties a and b hold objects a and b  respectively. they want to compute a function f a b  without a learning anything about b and vice versa. they encrypt their objects using random keys and follow a protocol  which results into two shares sa and sb given to a and b  respectively. by combining their shares  they compute the value of f. in contrast to our problem  which hides the querying user from the lbs   existing nn techniques assume that the query is public  whereas the database is partitioned into several servers  neither of which wants to reveal their data to the others. ref.  assumes vertically partitioned data and uses secure multiparty computation to implement a private version of fagin's  algorithm. ref.  follows a similar approach  but data is horizontally partitioned among the servers. the computation cost is o n1  and may be prohibitive in practice. ref.  also assumes horizontally partitioned data  but focuses on top-k queries.
　more relevant to our problem is the work of  which uses pir to compute the nn of a query point. the server does not learn the query point and the user does not learn anything more than the nn. to achieve this  the method computes private approximations of the euclidean distance by adapting an algorithm  that approximates the hamming distance in {1}d space  d is the dimensionality . the〔 cost of  is o  n1  for the exact nn and o   n  for an approximation through sampling. the paper is mostly of theoretical interest  since the o  notation hides polylogarithmic factors that may affect the cost; the authors do not provide any experimental evaluation of the algorithms.
symboldescriptionq1 q1
nk/1-bit primesy1:t  array of k-bit numberspir queryz1:t 1 : m   array of k-bit numberspir replytable 1: summary of notations
1. pir framework for lbs
　this section provides an overview of the proposed pir framework: section 1 outlines an existing pir protocol for binary data  which we use as a building block in our techniques. section 1 discusses the advantages of our pir framework  compared to existing spatial cloaking techniques.
1 computational pir protocol
　computational pir  relies on the quadratic residuosity assumption  qra   which states that it is computationally hard to find the quadratic residues in modulo arithmetic of a large composite number n = q1 ， q1  where q1 q1 are large primes  see table 1 for a summary of notations . define
	 	 1 
the set of numbers in zn which are prime with n  gcd is the greatest common divisor . then the set of quadratic residues  qr  modulo n is defined as:
	.	 1 
the complement of qr with respect to z n constitutes the set of quadratic non-residues  qnr . let
	 	 1 
where `ny ＞ denotes the jacobi symbol . then  exactly half of the numbers in z+1n are in qr  while the other half are in qnr. according to qra  for y （ z+1n   it is computationally intractable to decide whether y （ qr or y （ qnr. formally  define the quadratic residuosity predicate qn such that:
	qn y  = 1   y （ qr	 1 
then  if q1 and q1 are -bit primes  for every constant c and any function c y  computable in polynomial time  there exists k1 such that
		 1 
hence  the probability of distinguishing between a qr and a qnr is negligible for large-enough k.
　let  and consider that the database x is organized as a square t 〜 t matrix m  the matrix is padded with extra entries if n is not a perfect square . let ma b be the matrix element corresponding to xi that is requested by the user u. u randomly generates modulus n  similar to a public key in asymmetric cryptography   and sends it to the server  together with query message y =  y1 ...yt   such that yb （ qnr  and.

figure 1: pir example. u requests x1
the server computes for every row r of m the value
t
	zr = y wr j	 1 
j=1
where wr j = yj1 if mr j = 1  or yj otherwise1. the server returns z =  z1 ...zt . based on the euler criterion  u computes the following formula:
		 1 
if equation 1 is true  then za （ qr else za （ qnr. since u knows the factorization of n  equation 1 can be efficiently computed using the legendre symbol . the user determines the value of ma b as follows: if za （ qr then ma b = 1  else ma b = 1.
　example 1. figure 1 shows an example  where n = 1. u requests x1  which corresponds to m1. therefore  u generates a message y =  y1 y1 y1 y1   where y1 y1 y1 （ qr and y1 （ qnr. the server replies with the message z =  z1 z1 z1 z1 . if z1 （ qr then u concludes that x1 = 1  else x1 = 1.
　the protocol requires o n  multiplications at the server  and o 〔n  communication cost. the latter can be reduced to o nε   1   ε   1  by applying the method recursively . although the recursive variation is asymptotically better than the basic one  our experiments revealed that the overhead of the recursion is not justified in practice.
　the previous protocol retrieves privately one bit of information. the same idea can be extended to retrieve an object pi which is represented as an m-bit binary string. let d be a database containing n objects: d = {p1 p1 ...pn}. again  the server generates a matrix m with the difference that each cell contains an m-bit object. conceptually  this is equivalent to maintaining m matrices m m ...m m   one for each bit of the objects. assume that u requests object pi. same as the 1-bit case  u sends a message y =  y1 ...yt . however  the server applies y to each one of the m matrices  resulting to m answer messages: z z ...z m . u receives these messages and computes all m bits of pi. the communication and computational cost increase to o m〔n  and o m ， n   respectively. in the rest of the paper  we use
pir pi 
to denote that a user u retrieves privately an object pi from the server  using the described protocol.

1
according to  the formula can be simplified as follows:
wr j = yj if mr j = 1  otherwise wr j = 1
1 private location-dependent queries
　there are two privacy issues in location-dependent queries:  i  the user must hide his identity  e.g.  username  ip address  etc . this is orthogonal to our problem and can be achieved through a widely available anonymous web browsing service  that service does not learn the location of u .  ii  the user must hide his location. similar to previous research on spatial k-anonymity  see section 1   our pir framework focuses on this issue. the advantages of our approach are:
　pir does not disclose any spatial information. as opposed to cr-based methods  which only perturb location  but still disclose the cr   no location information is disclosed. instead  the data  i.e.  pois  are retrieved based on object index  by employing the provably private pir protocol. this approach prevents any type of attack based on user location. in sections 1 and 1  we develop methods to find the nn of a user with exactly one pir request  irrespective of his location.
　pir protects against correlation attacks. assume that u asks a continuous query as he moves. existing methods generate one cloaking region cri per location  but all cri will include u. by intersecting the set of users in all cri  an attacker can identify u with high probability; this is called correlation attack. note that this attack is possible because the cr reveals spatial information. since the pir framework does not reveal any spatial information  u is protected against correlation attacks.
　pir reduces significantly the identification probability. let u be the set of all possible users  e.g.  all mobile phone users within a country ; |u| is typically a large number  i.e.  in the order of millions . from the server's point of view  the pir request may have originated from any ui （ u. therefore  the probability to identify u as the querying user is 1/|u|. in contrast  k-anonymity techniques require a subset of users to subscribe to the anonymization service; typically . moreover  only k users are included in a cloaking region cr  and  otherwise cr grows large and the query cost becomes prohibitive  typically k is in the order of 1  1  1  . therefore  the probability 1/k of identifying u is several orders of magnitude larger than that of the pir framework.
　pir does not require any trusted third party  since privacy is achieved through cryptographic techniques. existing techniques  on the other hand  need:  i  an anonymizer  which is a single point of attack  and  ii  a large set u of subscribed users  all of whom must be trustworthy  since malicious users may collude to reveal the location of u. furthermore  users in u must accept the cost of sending frequent location updates to the anonymizer  even if they do not ask queries.
　pir reduces the number of disclosed poi. existing techniques disclose a large set of candidate pois  see figure 1 . since the database is a valuable asset of the lbs  users may be charged according to the result size. we will show  section 1  that pir techniques disclose far fewer pois.
1. approximate nearest neighbors
　in this section we describe our approxnn method  which employs the pir framework to retrieve privately the nearest point of interest  i.e.  nn  of u from a lbs. we show that a

figure 1: 1 pois on a 1 〜 1 hilbert curve
good approximation of the nn can be found with only one pir request. for simplicity  in section 1 we describe our method using the 1-d hilbert ordering. in section 1 we generalize to 1-d partitionings  such as kd-trees and r-trees.
1 approximate nn using hilbert ordering
　the hilbert space filling curve is a continuous fractal that maps the 1-d space to 1-d. let pi be a poi and denote its hilbert value as h pi . the hilbert ordering of a database d = {p1 p1 ...pn} is a list of all objects sorted in ascending order of their hilbert values. figure 1 shows an example database with 1 pois d = {p1 ...p1}  where h p1  = 1  h p1  = 1  etc. the granularity of the hilbert curve is 1〜1. the granularity does not affect the cost of our method  therefore it can be arbitrarily fine.
　if two pois are close in the 1-d space  they are likely to be close in the hilbert ordering  as well . therefore  an approximation of the nn of u is the poi pi whose hilbert value h pi  is closest to h u . since the pois are sorted on their hilbert value  we can use binary search to compute the approximate nn in o logn  steps. in our example  h u  = 1  therefore we retrieve p1 ★ p1 ★ p1 ★ p1. the answer is p1 since its distance from u in the 1-d space is |h p1    h u | = |1   1| = 1  which is the smallest among all pois.
note that the answer is approximate; the true nn is p1.
　there are two problems with this approach: first  since the search must not reveal any information  o log n  costly private requests for pir pi  must be performed. second  a side effect of the pir protocol is that each pir pi  retrieves not one  but 〔n pois. recall the example of figure 1  where u is interested in x1. the server returns z1 z1 z1 z1  from which u can compute the entire column 1 of m  i.e.  x1 x1 x1 x1. consequently  the binary search will retrieve o 〔nlogn  pois  which represent a large fraction of the database.
u 1  root 1 1	m	1 1	send root
1 p1 p1 p1
pir p1  p1  p1 
1 1 1 1 1 p1 p1 p1
p1  p1  p1
p1 p1 p1 p1 p1 p1 p1 p1 p1 p1 p1 p1	u=1	s
	 a  1-way b+-tree	 b  matrix m	 c  protocol
figure 1: approximate nn using hilbert
　observe  however  that each pir request is intuitively analogous to a page access  on a disk. therefore  the pois can be arranged in a b+-tree  where each node contains at most pois. the b+-tree for our running example is shown in figure 1.a; since there are 1 pois  the capacity of each node is 1. each entry in the root has a key and a pointer to a leaf. all hilbert values in a leaf are less or equal
approximate nn protocol
user u: initiate query
server: send root node
user u: let b be the column that includes u y =  y1 : y〔n   yb （ qnr  and
send y
server: send z 1 : m  =  z1 : z〔n  1 : m 
user u: calculate distance to all pois in column b return the approximate nn

figure 1: protocol for approximate nn
to the corresponding root key. each leaf node corresponds to one column of the pir matrix m  see figure 1.b . note that m stores the pois without their hilbert value. without loss of generality  we assume that each poi consists of its coordinates: pi =  xi yi ; more complex objects are easily supported. during query processing the server sends to u the root node  i.e.  . in the example h u  = 1 ＋ 1  therefore u must retrieve privately the first column of m. this is done with one request pir {p1 p1 p1} . next  u computes his nn from the set {p1 p1 p1}. the answer is p1  which happens to be the exact nn. note that by retrieving several pois in the neighborhood of u  the approximation error decreases; however  the method remains approximate. observe that the height of the tree is always log〔n n = 1. the fact that u asks for the root node does not reveal any information to the server  since all queries require the root. therefore  the server sends the root  which contains only hilbert values but no pois  in a low-cost plain format  i.e.  does not use pir . consequently  the nn is computed with only one pir request  i.e.  one column of m . figure 1 shows the protocol. the communication cost is o 〔n  and u retrieves up to pois; for instance  if the lbs contains 1 pois  u retrieves 1% of them. in section 1 we show that existing k-anonymity methods retrieve more pois.
1 generalization to 1-d partitionings
　the previous method can be extended to 1-d partitionings. the only requirement is that data must be partitioned into at most 〔n buckets  each containing up to 〔n pois. consider the case of the kd-tree . the original insertion algorithm partitions the space either horizontally or vertically such that every partition contains one point. we modify the algorithm as follows: let n be the number of pois in the current partition  initially   and let g be the number of remaining available partitions  initially  there are 
we allow splits that create partitions e1 and e1 such that  and
		 1 
subsequently  the algorithm is recursively applied to e1 and e1  with  and  remaining partitions  respectively. out of the eligible splits  we choose the most balanced one.
　in the example of figure 1.a there are n = 1 pois  and 1 available buckets. the points are split into regions a  which contains |a| = 1 pois  and bc  which contains |bc| = 1 pois. bc is further split into b  where |b| = 1  and c  where |c| = 1 . the resulting kd-tree has 1 levels. the root contains regions a b c and the leaf level contains 1 nodes with 1 pois each  which are arranged in a pir matrix m. query processing follows the protocol of figure 1. since u is in region c  column 1 is retrieved; the nn is p1.

figure 1: 1-d approximate nn
　as another case study  consider the r-tree. originally  each node would store between f/1 and f objects  where f is the node capacity; internal nodes contain minimum bounding rectangles  mbr  which enclose the objects of their children. we modify the r-tree construction algorithm such that there are 1 levels and the root contains no more than 〔n mbrs. let n be the number of pois in the current partition. the original algorithm checks all possible partitionings withpois  along the x and yaxis. it selects the best one  e.g.  lowest total area  or total perimeter  etc  and continues recursively. we modify this algorithm to validate a split only if equation 1 is satisfied. figure 1.b shows an example where mbrs a b c contain 1 pois each. the leaf nodes are arranged in a pir matrix m and query processing follows the protocol of figure 1. u is closer to mbr b  therefore column 1 is retrieved and the
nn is p1.
　both 1-d methods return the approximate nn by retrieving 〔n pois. the communication cost is o 〔n . therefore  in terms of cost  they are the same as the hilbertbased method. the only difference is the approximation error  which depends on the characteristics of the dataset  e.g.  density  skew . the case studies of the kd-tree and r-tree demonstrate a general method for accommodating any partitioning in our pir framework. the choice of the appropriate partitioning for a specific dataset is outside the scope of this paper. note that  all variations of approxnn can also return the approximate ith-nearest neighbor  where
1 ＋ i ＋ 〔n.
1. exact nearest neighbors
　in this section we present a method  called exactnn  which returns the poi that is the exact nearest neighbor of user u. in a preprocessing phase  exactnn computes the voronoi tessellation  of the set of pois  see figure 1 . every voronoi cell contains one poi. by definition  the nn of any point within a voronoi cell is the poi enclosed in that cell. exactnn superimposes a regular g 〜 g grid on top of the voronoi diagram. then  for every cell c of the grid  it determines all voronoi cells that intersect it  and adds the corresponding pois to c. hence  cell c contains all potential nns of every location inside it1. for example  figure 1 depicts a 1 〜 1 grid  where cell a1 contains {p1}  cell b1 contains {p1 p1}  etc. during query processing  u learns the granularity of the grid; therefore he can calculate the cell that encloses his location  i.e.  d1 in our example . next  u

1
 exactnn can be extended to support range queries  if each grid cell c stores the set of pois it encloses

figure 1: exact nearest neighbor
issues a private request pir d1 ; from the contents of d1 u finds his nn  i.e.  p1 .
　in contrast to approxnn methods  the objects of the pir matrix m of exactnn are not the pois. instead  each object in m corresponds to the contents of an entire grid cell c. for instance  our example contains 1 pois  i.e.  p1 p1 p1 p1   but m contains 1 objects  since there are 1 cells in the grid. in the previous section  n  i.e.  the number of objects in m  was the same as the number of pois. to avoid confusion  n still refers to the number of objects in m  i.e.  n = 1 in the example  and we use |poi| to denote the number of pois.
　all objects in m must have the same number of bits  otherwise the server may infer the requested cell based on the amount of bits transferred. let pmax be the maximum number of pois per grid cell. if a cell has fewer than pmax pois  the server adds dummy pois as placeholders. in our example  pmax = 1 because of cells a1 and c1. therefore  all other cells are padded with dummy pois. for instance  cell a1 becomes {p1    }. recall from table 1 that m denotes the number of bits of each object in m. since there are pmax pois in each grid cell  m = |pi| ， pmax  where |pi| is the number of bits in the representation of each poi.
　since the number of objects in m is n = g1  depending on the granularity of the grid  n may be larger or smaller than the number of pois. pmax  hence m  too   also depends on g. therefore the communication and computational cost of exactnn depends on g. in section 1 we discuss how to select an appropriate value for g.

exact nn protocol
user u: initiate query
server: send grid granularity g
user u: let b be the column that includes u y =  y1 : y〔n   yb （ qnr  and
send y
server: send z 1 : m  =  z1 : z〔n  1 : m 
user u: let a be the row that includes u discard dummy pois in za
calculate distance to real pois in za
return the exact nn

figure 1: protocol for exact nn
　the protocol for exactnn is shown in figure 1. it is similar to the approxnn protocol  with one difference: let  be the cell that contains u  where a is the row and b the column. u issues a private request . recall that  in addition to  the byproduct of this request are the pois of the entire column b. approxnn would utilize the extra pois to improve the approximation of the result. on the other hand  the extra results are useless for exactnn  since the exact nn is always in . a possible concern is that exactnn reveals to the user g，pmax pois  which may be more than those revealed by approxnn.in practice  however  this is not a problem because column b includes many duplicates. for example  cells d1 d1 d1 d1 in figure 1 all contain the same poi p1; therefore the request pir d1  reveals only p1 to the user. in section 1 we discuss an optimization which reduces further the number of revealed pois.
1 grid granularity
　for a particular choice of grid granularity g  the pir protocol overhead of exactnn is k ， g + k ， m ， g communication1  the first term corresponds to request y; the second to reply z   and o m ， g1  server computation  recall that m = |pi| ， pmax . by increasing g  i.e.  finer grid   pmax may decrease or remain the same  depending on the data characteristics. figure 1 shows the general form of the communication cost  as a function of g. initially the cost decreases fast because pmax decreases  but later the cost increases again at finer granularity  as pmax reaches a lower bound  either 1  or the maximum of duplicate pois . we could select the value of g that minimizes the communication cost  but there is a tradeoff  as the cpu cost increases quadratically to g. we could include the cpu cost in the graph and find the granularity that minimizes the total cost  expressed as response time . this would require the exact cpu speed and network bandwidth; the latter is problematic  since the bandwidth of each user differs. a good tradeoff is to select the granularity gopt near the point where the rate of decrease of the communication cost slows down. that is the point where the slope of the tangent of the cost function becomes  1.

	gopt	g
figure 1: finding the optimal grid granularity
　in practice  since pmax is not known in advance  the graph of figure 1 is generated as follows: first  we compute the voronoi diagram of the dataset. then  we select a set of values gi using random sampling. for each of these values  we superimpose the resulting grid on the voronoi diagram  and calculate pmax by counting the pois in each cell. the communication cost is ci gi  = k ，gi + k ，m，gi . finally  we apply curve fitting on the points to obtain the complete curve.
1. optimizations
　this section presents optimizations that are applicable to the previous methods. by employing these optimizations  the communication cost is reduced by as much as 1%  whereas the computational cost is reduced by up to 1% for a single cpu and more for multiple cpus.

1
recall that k is the number of bits in the modulus

figure 1: rectangular pir matrix m
1 compression
　the size of z  i.e.  the server's answer  is k，m，r bits  where r is the number of rows in the pir matrix m. however  there is a lot of redundancy inside z. consider the example of figure 1. cells a1 b1 c1 d1 have at least one dummy object each. the same holds for a1 b1 c1 d1. assuming that the dummy object corresponds to bits mi ...mj  then z1 mi : mj  and z1 mi : mj  will be the same. since each one of these results is k bits  the redundancy is significant. in our implementation we use standard compression techniques to compress the result. our experiments showed that  in many cases  compression may save up to 1% of the communication cost.
1 rectangular vs. square pir matrix
　in the previous sections the pir matrix m is assumed to be square. however  m can have any rectangular shape  with r rows and s columns  see figure 1 . the shape of m does not affect the cpu cost  since the number of multiplications does not change. on the other hand  the communication cost becomes: c r s  = k ， s + k ， m ， r  where the first part is the size of the user's request y1..s and the second part is the size of the server's answer z1..r. c r s  is minimized for:
		 1 
 if each object has 1 bit  i.e.  m = 1   c r s  is minimized for r = s = 〔n  i.e.  square matrix . in our exactnn method  on the other hand  1; therefore  the communication cost is minimized for r smaller than s. rectangular matrices have an additional benefit: they can reduce the number of pois that the user learns. consider the example of figure 1.a  where r = n and s = 1. the server returns z1..n  therefore  the user learns n pois. on the other hand  in figure 1.b r = 1 and the server returns only 1 poi. by using rectangular m in the exactnn algorithm  the user learns up to r ， pmax pois. this is much less than the pois that a square matrix would reveal.
　rectangular m could also reduce the communication cost in the approxnn methods  since 1. however  there is a drawback: recall that the approxnn methods organize pois in an index  whose root node is always sent to the user. the size of the root is equal to the number of columns s. in the extreme case  i.e.  for large enough m   equation 1 results in s 「 n  therefore the root node reveals the entire database to the user. the minimum number of revealed pois  i.e.     is achieved for square m. in our implementation we use a square matrix m for the approxnn methods.

figure 1: pre-compiled optimized execution plan
1 avoiding redundant multiplications
　from equation 1  section 1   it is clear that a pir request requires m，n multiplications with yi （ y. each yi is a k-bit number; to ensure that factorization is hard  k needs to be in the order of hundreds. therefore  the cpu cost of the multiplications is high. nevertheless  many multiplications are redundant  since they are repeated several times. in this section we propose an optimization technique  which employs data mining to avoid redundant multiplications. although in this paper we only evaluate the effectiveness of the proposed optimization for the location privacy problem  our technique is general and can be used in other pir applications.
　by using the simplification of   section 1   in each row of the pir matrix we only need to consider the '1' bits. for example  in figure 1  the result for row 1 is: z1 = y1，y1，y1，y1. observe that the partial product y1 = y1，y1，y1 appears in rows 1  1 and 1. if y1 is computed once  it can be reused to compute z1 = y1 ， y1  z1 = y1 ， y1 and z1 = y1  thus saving many multiplications. the same idea applies to y1  which appears in rows 1  1 and 1.
intuitively  the previous idea can be implemented as a
 cache . when a new pir request arrives  the server starts processing it and stores the partial results in the cache. if a partial product is repeated  the corresponding partial result is retrieved from the cache. unfortunately  the number of possible partial products is 1s  where s is the number of columns in m. s can be in the order of thousands  therefore the method is prohibitively expensive for on-line use.
　observe that  although the result depends on the input y  the set of multiplications depends only on the server's data and is the same for any pir request. therefore  similarly to pre-compiled query plans in databases  we generate in an off-line phase an optimized execution plan that avoids redundant multiplications. then  during query processing  the server routes the input y through the operators of the plan  in order to compute fast the result z. the execution plan for our running example is shown in figure 1.
　in the off-line phase  we employ data mining techniques to identify redundant partial products. following the data mining terminology  each item corresponds to one column of matrix m  whereas each transaction corresponds to a row of m. for example  row 1 in figure 1 corresponds to transaction t1 = 1. a '1' bit means that the corresponding item belongs to the transaction. there are r ， m transactions with s items each. an itemset corresponds to a partial product. in order to avoid many multiplications  we must identify frequent and long itemsets. we use the apriori algorithm . initially  apriori considers all itemsets with one item and prunes those that do not appear in at least fmin transactions. then  it considers all possible combinations with two of the remaining items and continues recursively with itemsets containing more items.
　accessing the execution plan incurs an overhead on query execution. therefore  the frequency and length of the discovered itemsets must be large enough such that the savings from the multiplications are more than the overhead. the cut-off values for frequency and length can be estimated by measuring the actual multiplication time of the particular cpu. moreover  by decreasing fmin the running time of apriori increases. therefore  fmin must be selected such that apriori finishes within a reasonable time. note that the identification of frequent itemsets is a costly operation  therefore it is not appropriate for databases with frequent updates. however  in many lbss updates are infrequent  e.g.  hospitals change rarely . similar to data warehouses  our method is appropriate for batch periodic updates  e.g.  once per night .
　let it =  it1 it1 ...  be the list of frequent itemsets sorted in descending order of itemset length. in the example of figure 1  it =  1  which corresponds to y1 and y1. we use the following greedy algorithm to build the execution plan for row zi: let ti be the transaction that corresponds to zi. we traverse the list it and select the first  i.e.  longest  itemset itj which appears in ti. the rationale for this heuristic is that longer itemsets correspond to longer partial products  hence they are preferred for their higher potential in multiplication savings. we include itj in the execution plan of ti  remove from ti all items in itj  this step is necessary in order to ensure correctness  and repeat the process for the rest of itemsets in it. the pseudocode is shown in figure 1  lines 1 and 1 use bitwise operations for performance reasons . the same process is repeated for all rows of m.

buildexecutionplan
input: transaction ti  from row i of m   list of frequent itemsets it
1. execplani =  
1. foreach itemset itj （ it
1. if*/
1.
1. j
1. if  ti = 1  /*no more '1's in ti*/
1. break
1.
1.
1. output execplani

figure 1: execution plan for one row
　figure 1 shows the architecture of the pir optimizer. once a query is received  the server checks for each row the associated execution plan execplani: for each itemset it （ execplani  the server checks whether the partial product of it has already been tabulated in table prod; if so  it is used directly  otherwise  the server computes the product and stores it in prod to be used for subsequent rows. the overhead of this technique consists of the lookup in the prod table  which can be efficiently manipulated as a hash table  having as key the signature of it. the experiments show that  by using the optimized execution plan  the computation cost is reduced by up to 1%.
1 parallelism
　the pir framework involves a large number of multiplications in a regular pattern. consequently  the computations can be easily parallelized. the parallel computing infras-

figure 1: pir optimizer architecture
tructure can vary from multicore cpu  to multi-cpu to computer cluster. matrix m is partitioned horizontally in as many partitions as the available cpus  and each cpu receives the corresponding partition in an off-line phase. during query processing  all cpus receive the input vector y and calculate their part of the result. communication is minimal  only the input and output  since each partition does not depend on the others. therefore  parallel implementations achieve almost linear speedup. in our experiments we used up to 1 cpus resulting to up to 1 times faster execution time.
1. experimental evaluation
　we developed a c++ prototype of the proposed pir framework. we tested the methods using both synthetic  uniform and gaussian  and real  sequoia1  1k pois in california  datasets. our experimental testbed consisted of a pentium 1.1ghz machine with 1gb of ram  running linux os. we employed the gmp1 library for operations with large integers  required by pir   and the zlib1 library for data compression. in our experiments  we measured the com-
munication cost  as well as the computational cost at the server  which is the dominating factor for pir. the cpu time includes the compression of the result before returning it to the client  which only accounts for a small fraction of the total cpu time . we also measured the computational cost at the client. we varied k  i.e.  modulus bits  between 1 and 1  and the number of pois between 1 and 1. each poi consists of its  x y  coordinates  i.e.  1 bits .
1 1d and 1d approximate nn
　first we compare the approximate nn methods. 1d refers to the hilbert variant  whereas 1d refers to the r-tree variant. figure 1.a shows the server cpu time with varying k for the real sequoia set. recall that  for approximate methods  n is the number of pois. the cpu time is very similar for both 1dapprox and 1dapprox  since in both cases it mainly depends on the data size. cpu time varies ap-〔 proximately as k k  which is the average complexity of the multiplication algorithms implemented in gmp.
　figure 1.b  shows the communication cost  which is linear to k. both methods incur similar cost  since the sets of elements  i.e.  pois  stored in the pir matrix are the same in both cases. the slight difference is due to the distinct distribution of pois along rows and columns. for k = 1  the communication cost is 1mb.

1 http://www.rtreeportal.org
1 http://gmplib.org/
1 http://www.zlib.net

	 a 	 b 
figure 1: variable k  sequoia set  1k poi 

	 a 	 b 
figure 1: variable data size  k = 1 bits
　figure 1.a shows the cpu time for varying data size  synthetic sets  and k = 1. the cpu time is linear to n  since the number of multiplications is proportional to the number of '1' bits in the data. the communication cost follows the expected theoretical dependency of  as shown in figure 1.b. compression is more effective with gaussian data  because there are more pois with nearby  possibly identical  coordinates  increasing redundancy.
　next  we investigate the approximation error of the proposed techniques. we generate 1 queries originating at random locations that follow the poi distribution  this is a reasonable assumption  since the dataset is likely to correspond to an urban area  for instance . given query point q  the returned result r and actual nn p  we express the approximate nn error as err =  dist q r  dist q p  /maxd  where maxd is the side of the  square  data space.

unif1k unif1k gauss1k gauss1ksequoia
figure 1: approximation error
　figure 1 shows the average error for 1dapprox and 1dapprox. the error is slightly larger for uniform data  as pois are scattered in the entire dataspace. for gaussian data  the clustering of pois in the pir matrix is more effective  leading to better accuracy. the error decreases when data density increases  and the average error is always below 1% of the dataspace size. furthermore  the results revealed that despite their approximate nature  the methods return the exact nn for 1% of the queries  whereas the maximum worst-case error encountered was 1% of the dataspace size. 1dapprox and 1dapprox have similar cpu time and
1k1k1k1k1kuniform11111gaussian11111sequoia1table 1: grid granularity for exactnn

   figure 1: variable k  sequoia set  1k poi  comparable communication cost  since they both follow the same 1-level tree approach. the choice between the two depends on the characteristics of the data and is outside the scope of this paper. in the rest of the experiments  we only consider the 1dapprox method.
1 exact methods
　we evaluate the performance of exactnn in comparison with 1dapprox. the grid size of exactnn was determined as described in section 1. table 1 shows the resulting grid size for each dataset. note that  for exactnn we use the rectangular pir matrix optimization from section 1. figure 1.a depicts the cpu time versus k for the real dataset. the trend is similar to approximate methods  but the absolute values are higher for exactnn  due to the larger size of the pir matrix  recall that the m value for exactnn may be considerably larger than that for 1dapprox . in section 1 we evaluate methods that reduce the cpu time. figure 1.b confirms that the communication cost is linear to k.

figure 1: variable data size  k = 1 bits
　figure 1.a shows the cpu time versus the data size. recall that n for exactnn depends on the grid granularity  and is not equal to the data size. for uniform data  the number of grid cells  i.e.  n value  required to maintain a constant pmax grows proportionally with data size  therefore the cpu time increases linearly. on the other hand  for skewed data  in order to maintain a value of m which provides low communication cost  it may be necessary to use a finer grid  resulting in increased cpu time. however  the results show that the cpu time is almost linear to the number of poi  confirming that the heuristic for choosing the grid granularity is effective. the good choice of granularity is also reflected in the communication cost  figure 1.b . observe that  for gaussian data  pmax  hence m  increases  and consequently the communication cost increases.
1 execution time optimizations
　in this experiment we evaluate our optimizer1  which employs data mining  dm  to reduce the cpu cost of pir at the server. we run the apriori algorithm on the real dataset and retain all frequent itemsets with a support of at least 1%. figure 1 shows the results: for small k values  the gain in execution time is less significant  because multiplications are relatively inexpensive. however  as k increases  the benefit of avoiding redundant multiplications becomes clear: the cpu time is reduced by up to 1% for 1dapprox  and 1% for exactnn.

figure 1: dm optimization  sequoia set
　the pir computations are suitable for parallel execution. we implemented a message passing interface  mpi  version of the server  and tested it on a linux cluster with intel xeon 1 ghz nodes. in figure 1  we show the effect of parallel processing. we vary the number of cpus from 1 to 1; note that  since each individual cpu is slower than the one used in the previous experiments  the 1-cpu time is slightly larger. the speed-up obtained is almost linear for 1dapprox  where we obtained improvements by a factor of 1 for 1 cpus. for exactnn  the speed-up is slightly lower  up to 1 for 1 cpus  because the dummy objects correspond to a lot of '1' bits and result in load imbalance among the cpus. we expect better performance with a more sophisticated load-balancing algorithm. for a typical value of k = 1 bits  1dapprox finishes in 1sec  whereas exactnn needs 1sec.

figure 1: parallel execution  sequoia set
1 user cpu time
　the user is typically equipped with a slow pda; therefore he cannot afford expensive computations. however  our experiments show that the cpu cost for the user is low. in figure 1.a we use the real dataset and vary k. the user needs to generate random k-bit numbers and perform qr/qnr verifications of the k-bit replies. for typical k = 1  the cpu time does not exceed 1sec. in figure 1.b we set k = 1 and vary the data size  we use the gaussian dataset . when the data size increases  so does

1
 for the execution time optimization experiments  we use square pir matrices for both 1dapprox and exactnn

	 a 	 b 
figure 1: user cpu time
the number of columns in matrix m. consequently  the size of the query vector y   as well as the size of the reply vector z  increases. the resulting cpu time is always lower than
1sec.
1 pir vs. anonymizer-based methods
　we compare our methods with hilbert cloak  hc    which offers privacy guarantees for snapshot queries  and outperforms other cloaking-based location privacy techniques in terms of overhead  i.e. size of cloaking region  cr . direct comparison is difficult  since the architectures are completely different and there are many unknowns  e.g.  how many users subscribe in the anonymizer service  how often they update their location  how often they ask private queries  etc . instead we study the number of pois that the user learns from each query  recall from section 1 that the user is charged by the number of retrieved pois .

	1k	1k	1k	1k 1k 1k 1k	 1	 1	 1	 1	 1	 1
	users	k  degree of anonymity 
	 a 	 b 
figure 1: pir vs. k-anonymity  sequoia set
　we consider the sequoia dataset  and for hc we generate a number of subscribed users between 1k and 1k  at locations that follow the poi data distribution  as discussed in section 1 . figure 1.a shows the number of disclosed poi for varying number of subscribed users  and a value of anonymity degree k of 1  i.e.  1% probability of identifying the source . if the number of subscribed users is low  the size of the generated cr is large  and a huge number of pois are included in the result. only for a very large number of subscribers does the poi count become comparable with that of 1dapprox  which is roughly 1 for the sequoia set. the number of disclosed pois is even lower for exactnn  i.e.  1 pois in average   due to the rectangular pir matrix. this result shows that  in order to maintain a reasonable degree of disclosed pois  i.e.  a compact cr   cloaking-based methods need to have a large number of subscribed users. this translates into a high cost of location updates  mobile users change location frequently   and also poses privacy concerns  since all users must be trustworthy. the disclosed poi number is constant for pir methods  because no subscribed users are required.
　in figure 1.b we fix the number of subscribed users to 1 and vary k. hc discloses the same number of poi as exactnn for k   1  which means that the identification probability of hc exceeds 1%. however  the identification probability of exactnn is   where u is the set of all possible users  see section 1 .
1 discussion
　the experimental results show that  although our pir techniques are relatively expensive compared to usual query execution  the overhead is still reasonable. for the real dataset and a typical value of k = 1 bits  the communication cost for 1dapprox and exactnn is roughly 1mb and 1mb  respectively. the corresponding cpu time at the server is 1sec and 1sec  respectively  by employing optimization and/or using multiple cpus . the cpu time at the user is 1sec at most  and the number of disclosed pois  hence the resulting financial cost of using the lbs   is low. existing cloaking-based approaches have many hidden efficiency issues  such as handling location updates  and managing a large number of user requests. in addition  existing methods have important drawbacks of qualitative nature: first  they lack privacy guarantees for continuous queries  i.e.  correlation attack   and fail completely if some of the users are malicious. second it may not be commercially feasible to gather the required large number of subscribers who will offer continuously their resources for a sporadic benefit. third  there may be legal reasons which prohibit the anonymizer to gather locations of users.
1. conclusions
　in this paper  we employed the private information retrieval theory to guarantee privacy in location-dependent queries. to the best of our knowledge  this is the first work to provide a practical pir implementation with optimizations that achieve reasonable communication and cpu cost. compared to previous work  our architecture is simpler  more secure  i.e.  does not require an anonymizer or collaborating trustworthy users   and is the first one to protect against correlation attacks.
　currently  we are working on sophisticated heuristics to generate better optimized execution plans  in order to reduce further the cpu cost. in the future  we plan to investigate the extension of our framework to different types of queries  such as spatial joins.
1. repeatability assessment result
　the results in figures 1 and figure 1 were verified by the sigmod repeatability committee. the committee has been unable to repeat the experiment described in figure 1 due to the lack of appropriate hardware.
