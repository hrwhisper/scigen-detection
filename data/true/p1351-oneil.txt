object/relational mapping  orm  provides a methodology and mechanism for object-oriented systems to hold their long-term data safely in a database  with transactional control over it  yet have it expressed when needed in program objects. instead of bundles of special code for this  orm encourages models and use of constraints for the application  which then runs in a context set up by the orm. today's web applications are particularly well-suited to this approach  as they are necessarily multithreaded and thus are prone to race conditions unless the interaction with the database is very carefully implemented. the orm approach was first realized in hibernate  an open source project for java systems started in 1  and this year is joined by microsoft's entity data model for .net systems. both are described here. 
categories and subject descriptors 
h.1  database management : h.1 logical design data models  normal forms  schema and subschema  h.1 languages database  persistent  programming languages h.1 database 
applications  d.1 software engineering  d.1 design tools and techniques object-oriented design methods d.1 software architectures data abstraction  
general terms 
design  languages  algorithms 
keywords 
object-relational mapping  impedance mismatch  data model  persistence  schema mapping  web application  hibernate  entity data model 
1. introduction 
programmers strongly prefer to work with persistent data held  for the moment  anyway  in program objects  rather than use sql directly for data access  even though this means working around the famous  impedance mismatch  between tabular data and object state. object/relational mapping systems bridge this mismatch  by whisking data to and from a relational database to appropriate objects  based on o/r mappings. o/r mappings map object schemas  class diagrams  etc.  to database schemas  part of the technology of last year's sigmod keynote talk  by phil bernstein on schema mapping. as phil mentioned  there is a recently developed schema language in microsoft's ado.net called the entity data model   for release in 1 ; this will be described more fully in the current talk. a comparable model and system was developed by the open-source hibernate project  founded and led by gavin king starting in 1  after his frustration as a software developer with the  heavy-weight  entity java beans  ejb  of the older java enterprise platform. king describes the hibernate system in an excellent book on the subject . the current ejb specification  ejb 1  uses the direct descendent of hibernate 1  known as java persistence architecture  jpa .  
 
figure 1. orm in use in one of many apps using the database. 
 
i will call the common ideas of microsoft's entity data model and the hibernate model  and jpa  simply the  entity model   since the entities correspond to the objects  making them the centers of attention. the entity model is a refinement of the entity-relationship  e-r  model of chen   and the extended e-r model  eer  that incorporates inheritance/generalization hierarchies. the entity model sits between the object world of applications and the underlying database s  where all persistent data is stored  as shown in figure 1. typically  other applications access the database as well  as the database represents shared enterprise data.  
both hibernate and edm provide a full object/relational mapping system  and have gui tools to help with development. for simplicity  i'll be covering hibernate and edm  and ignoring jpa  since it is so close to hibernate and largely derives from it. as the standardized offering  jpa is advancing in adoption by all the major java enterprise application server products. hibernate and its jpa implementation is part of jboss   the first application server with this capability. openjpa  originally from bea's kodo product  is now an open-source project at apache  and is available for bea's weblogic server  and ibm's websphere . oracle's toplink 1g supports jpa .  

 
copyright is held by the author/owner s . 
sigmod'1  june 1  1  vancouver  bc  canada. acm 1-1-1/1. 
with the entity model  the mapping from application objects to tables is made in two hops  with the entity model in the middle  apparently a more complex task than a single mapping.  why would this be a good idea  the answer is that this entity model is useful to the practitioners for designing and implementing real systems. it abstracts away some of the nitty-gritty details of database table setup and pastes over some of the deficiencies of relational tables  such as the difficulty of expressing a generalization/inheritance hierarchy. it provides guidance towards workable database schemas. 
with these o/r mapping systems and their entity models  a programmer is encouraged to think in terms of entities and their relationships. the system takes over all the details of handling relationships at runtime  delivering object graphs for complex objects  for example  ready for programmatic use.  the system automatically tracks updates made to the objects  and performs the necessary sql insert  update  and delete statements at commit time.  thus the business logic programming can be done in the comfort of object-oriented languages  usually java or c#  with transactions delineating the discrete actions of the application at the object level. the objects we are discussing here are a subset of all the objects in the application  the ones  temporarily  representing persistent data. they are often called persistent objects  but this name causes some confusion with object serialization  the java/c# object persistence mechanism   so i will use another common name  domain object.  
of course there are differences between the hibernate and edm systems  but the main thrust of what i present is their common features  a convergence of technology relevant to the database community.  in fact  the edm system so far is available only in beta release  free   so it is still a work in progress and lacks some needed features. 
for simplicity  a single database server is considered  although both systems can handle distributed transactions with the help of jta/dtc. the hibernate platform is in use for systems involving up to hundreds of entities and tens of thousands of users  that is  it is scalable up to the point that the database s  involved is/are overloaded. this approach is relevant to most dynamic internet sites  all but the very largest  plus most non-web database applications with significant user interaction. 
 
1. the entity model 
an entity has attributes as in e-r  called properties in the entity model  and a unique identifier  often a  surrogate  key  meaning one whose value is not important to the application aside from its use as an identifier.  for example  in this approach a ssn would not be used as an id but rather as a property. we will assume this in what follows  for simplicity. natural keys can also be used. see ambler  for discussion of key choices. the unique identifier is persistent  like its corresponding database primary key. 
relationships boil down to the binary n-1  1 and n-n cases.  a ternary relationship is not directly supported by the entity model  but can be expressed by promoting its links to entity instances.   
as is well known  databases are bad at modeling inheritance hierarchies. there are several ways to do it  none completely satisfactory. the entity model abstracts the concept  and then provides alternative implementations  selected by configuration. 
 
today  the programmer needs to craft specific directions in xml or provide code annotations to get a class inheritance hierarchy properly mapped to the chosen database solution.  both hibernate and edm can follow the most common alternatives  known as table-per-hierarchy  one table for all variants  and table-per-type  one table for base plus one table per subclass  
1. the pizza shop example 
this example is available at www.cs.umb.edu/~eoneil/orm. this website contains side-by-side implementations  using hibernate and microsoft edm  of a simple system with four database entities related by an n-n relationship and an n-1 relationship  one entity has no relationship to the others and is ignored in the figures . see figure 1. it is a system for ordering free pizza to be delivered to a specified room number in a dormitory. the  student  user has choices of pizza size and toppings  so each order has one size and a set of toppings. the  admin  can add and delete topping choices and sizes  mark pizza orders as ready  finish off a day and start another  etc. although the system is simple  it is implemented with the layered architecture of larger applications  with a transactional service layer called by the presentation layer  which contains all the user interface code.  
 

 
figure 1. e-r diagram for pizza shop database 
 
 
figure 1 shows the database schema for the system. the n-1 relationship is simply represented by the sizeid foreign key in the pizza order table. the n-n relationship needs a  link table  with foreign keys to the two related tables  pizza order and topping. 
the corresponding entity model is shown in figure 1. the relationships are now reduced to annotated lines between the entities  as is also commonly done in uml  for object models. the link table is considered an implementation detail and suppressed from the top-level diagram. its existence can be surmised from the cardinality markings  1..*   and  1..* having stars at both ends of the relationship line. these markings denote  1 n  and  1 n  multiplicity  respectively. pizzasize has the default multiplicity of  1  in its relationship and thus has no marking on its end for the n-1 relationship. 

 
figure 1. database schema with link table order topping  
 
 
figure 1. entity model 
during execution  a pizza order is a small object graph of domain objects: the main pizzaorder object referencing a pizzasize object and a collection of topping objects. here is a quick example of application code working with the domain objects. to find the size name for a pizzaorder order  just  dot  through the to-1 relationship: 
order.getsize  .getsizename   // hibernate/java order.size.sizename                         // edm/c#   
we will also look at an example of iterating through the toppings. to get orders from the database  we use the hibernate session or edm objectcontext  context  object to create a query that can return pizzaorder objects  as follows: 
query orders =                //hibernate   context.createquery  select o from      pizzaorder o   + 
     where o.roomnumber =   + roomnumber 
      +  and o.day =   + day ;  
 
objectquery pizzaorder  orders =   //edm       new objectquery pizzaorder        select value o from 
    pizzaentities.pizzaorder as o   +  
     where o.roomnumber =   + roomnumber 
       +  and o.day =   + day  context ;  
 
 
we see that we are not really giving up sql query power by using o/r mapping. sql itself is mapped into the object world  allowing joins  inner and outer   ordering  group by  polymorphism  across subclasses   and prepared statements. the query results can consist of domain objects or other program objects. if the object query language is still too restrictive  the underlying connection to the database can be used for direct sql. such direct sql is commonly used for batch updates and database reloads. 
1. the presentation  service  and data access object  dao  layers 
in serious applications  the code is organized into three layers  the presentation  service  and dao  data access object  layers. see figure 1. the presentation layer code calls the service layer methods  and the service layer code calls the dao layer methods. domain objects are passed as arguments and return values of these calls; they are used in all the layers. domain objects carry data around but don't have to be  dumb  data carriers  that is  they can have specialized methods to help with the needed work. 
presentation-layer code implements the user interface  ui . it calls the service layer for all actions related to persistent data. the presentation layer for the pizza project is provided in two versions for each o/r mapping framework  a line-oriented ui and a web application with server-side scripting in jsp 1/asp.net.  
 
 
figure 1. a layered database application 
 
service-layer code implements the basic transactional actions by calling the dao layer to get domain objects  working with them  and then possibly updating them with the help of the dao. this layer is also called the business layer  because it implements the business model actions. here we see methods makeorder  getorderstatus  alltoppings  allpizzasizes  addtopping  etc.  together constituting the  service api   applications programming interface  called by the presentation layer. these names are capitalized for c#  makeorder  etc.  to follow coding conventions. the service-layer code starts up a transaction around the needed actions and ultimately commits or aborts it.  
 
figure 1. calls down the layers in pizza shop 
dao code inherits an ongoing transaction from its service-layer caller  and works with the o/r framework to get and update domain objects. daos use object queries  as shown in the code above  or primary-key lookups to read data  or less commonly  direct sql.  figure 1 indicates some of the calls involved in making a new pizza order. first  in a previous time  and transaction  to what is shown here  the presentation layer calls the service layer to get topping and pizzasize objects to show the user the possible pizzas to order. after the user decides  the presentation layer calls makeorder    and the service layer runs a transaction. during the transaction  the service layer calls the dao layer  and the new pizza order object graph is persisted. in particular  a new row is added to pizza order and one row for each topping is added to order topping. if the topping has meanwhile disappeared  the dao access fails and the service layer aborts the transaction. 
1. the entity context 
the execution environment provided by the o/r mapping platforms is delivered by the hibernate session and the edm objectcontext  seen as the  context  object earlier in dao code. let us call this common idea the entity context. the entity context provides a private cache of objects for the application execution in one unit of work  thread   with at most one object instance for each entity id. see figure 1. the entity context manages the loading and saving of database objects under the general control of the configuration and entity context api. usually  database updates are deferred until synchronization between the object cache and database is needed. when an object is accessed  the entity context provides the needed data out of the object cache  or if it is not found  the database is read. thus rereads of database data by one thread are prevented  unless explicitly requested through the entity context api   preventing some repeated-read anomalies. 
the database maintains a buffer cache of recently accessed rows  so the access to popular rows is very fast. this buffer sits logically in front of the disk data as is shared among all the apps  not just the ones using orm. it is of course essential to provide enough memory in the database buffering system. this often requires changing the database configuration from the defaults of its installation. database indexing is just as important as ever. 
the entity context can handle a new id created on insert of a row for a new entity  even though id generation on insert is not available in standard sql. each database product has a way to do this  by an auto-incrementing datatype or  sequence . this useful sql extension is made portable and attractive. 
 
figure 1. entity contexts and corresponding database data 
1. the domain object life cycle 
when you create a new domain object  it has no connection to the entity context.  thus you must explicitly introduce it to the entity context with a hibernate save or edm addobject operation.  in edm  every domain class is a subclass of entityobject  a system class.  in hibernate  there is no such system superclass. on noting the system superclass for domain classes in edm  you immediately worry about testability and code reuse  the bane of frameworks based on subclassing. however  the situation is not as bad as it might sound. c# provides  partial classes   so that all the systemprovided code can be in one .cs file and all the application-provided code can be in another. the application-side partial class can be compiled by itself  wholly apart from the system classes  as part of a test program  for example. 
in both systems  the data in the domain objects  obtained during the entity context lifetime  is still there after the entity context is closed down. in the typical application  the objects are filled out in the service layer and returned for display in the presentation layer after the entity context is closed down. after use in the presentation layer  the domain objects are discarded  having done their job delivering persistent data. 
1. transactions 
when the entity context actually interacts with the database  the database will start up a transaction if one is not yet running  and commit it after the current statement  a process known as autocommit. to extend a transaction lifetime to contain multiple database accesses  an application needs to start up and commit a transaction itself. these calls to start and finish a transaction are part of the entity context api. in a layered application  these calls are in the service layer  to allow the core business code to run the show. 
the commit of the transaction triggers a synchronization of the entity context to the database  in the simple use of the entity api . 
there are three isolation levels to choose from: read committed  rc   read committed with versioning  or serializable  sr .  rc without versioning allows update anomalies without notification  and thus is not recommended. rc with versioning provides  very nearly  ansi repeatable read  sr except allowing predicate anomalies  because of the rereads from the object cache. in versioning  the framework checks versions before writing and aborts the transaction if the database data has changed  as in snapshot isolation. however  note that full snapshot isolation stabilizes predicates where this does not. with the serializable level  versioning is redundant  accessed data is locked up  and deadlocks can occur  causing aborts. as usual  no free lunch. 
1 transactions vs. entity context lifetimes: are conversations a good idea  
each transaction lives within a certain entity context. the simplest setup  used in the pizza project  has one transaction in each entity context lifetime. however  in general  an entity context can contain a sequence of transactions  possibly with large delays between the transactions  usually caused by ui actions. this multi-transaction scenario in an entity context is called a  conversation . in this case  in the times between transactions  the objects in entity context may stray from their  official  database values  as other activities change things. to help avoid such problems  the entity context can be refreshed from the database by explicit call s  to the entity context api  or the entity context can be dropped and recreated  the simple way. dropping and recreating an entity context is probably not much more expensive than a full refresh. in the case of web apps  the possibilities of extremely long waits between user requests argue for the simple context-per-transaction approach  to avoid wasting memory on idle conversations. 
1. theory 
the development of hibernate has been entirely in the realm of practicing software engineers  and has gone remarkably unnoticed in the academic world. because of the best software architects' strong belief in  clean  solutions  the results hang together as a beautiful system. the development of edm has had input from the model-mapping community led by phil bernstein  and they have published papers  1  1  explaining how the relationship between the entities and tables can be seen as views  and their updates as view maintenance. clearly this analysis should be applied to the hibernate system to bolster its foundations and check it out for related potential problems. schema evolution is also relevant of course. 
the hibernate community often uses a simplified uml class diagram to express the entity model. edm also has such a diagram. it would be interesting to examine how the entity model restricts the general uml class diagram. one of the troublesome cases is  in er terms  an n-n relationship with attributes. 
1. scaling up 
at the small-scale level  all the software can run on one system  which is very convenient for development. for production use  we are considering the case that one database server with plenty of resources can handle the transactional load of the applications using it. to offload the database server  the web application itself can run on application servers on the same fast local network as the database server. similarly  to offload the application servers  the web servers can run on dedicated servers also on the local network  usually separated by a firewall switch. the switch ensures that static content's network traffic is localized to the outer network. further  if there is a lot of static data  images  etc.   a content delivery network can be used to offload the web servers.  thus the upper end of the relevant range of applicability of this scenario involves many servers and can handle many simultaneous users. 
consider the case that each request that reaches the application server gets its own entity context. then the database server's cache is providing the memory cache for all the domain data used by the application servers. the application servers themselves do not need to cache domain data except in the entity contexts themselves  and that is only for the current request cycle  each of which should last for less than one second. although popular domain data is retrieved over and over from the database to the app servers  the retrieval is much faster than disk retrieval  since popular data stays in the database cache  and network transfer on a local network has latency in microseconds  compared to multiple milliseconds for disk access. further  the total data transfer rate from database to app servers is easily seen to be trivial for today's fast local networks  as long as the domain objects themselves are not huge.  
figure 1 shows two concurrent requests being handled in one application server  each with its own entity context  object cache  getting data from the common database cache  or occasionally from the disk.  
	 
figure 1. data access in a web application  where the database and application server reside on a fast local network. 
 
if the application outgrows this simple one-database-server solution  it means the website is quite successful and should be able to afford investment in reengineering. if most of the domain data can be classified as application-specific slow-changing non-critical data  a second-level cache can be provided in the application servers to offload the database for this kind of data  leaving the database to directly handle the core application-shared and/or money-related data. above this size  we are considering truly large-scale sites  another topic. 
1. the future 
the basic systems are in place for very useful designs  but it's still too hard to build them from scratch  or even from an existing database schema  except in the simplest cases. a programmer's workbench can and will be built  to suggest possible refactorings and help with incremental additions to a model  working from the entity model side or the object side. the competition between the java community and the c#/microsoft community will at least be interesting and may bring us more useful tools and other innovations. 
about the presenter: elizabeth  betty  o'neil is a professor of computer science at the university of massachusetts at boston. she has worked with her husband  patrick o'neil  on research in database performance  indexing  and on authoring a database textbook.  she has worked as a database system software developer for sybase iq  microsoft  and amdahl  and has developed and taught courses in database-backed web applications as well as database systems.   
