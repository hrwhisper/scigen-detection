xml is becoming the universal format for data exchange between applications. recently  the emergence of web services as standard means of publishing and accessing data on the web introduced a new class of xml documents  which we call intensional documents. these are xml documents where some of the data is given explicitly while other parts are defined only intensionally by means of embedded calls to web services.
﹛when such documents are exchanged between applications  one has the choice to materialize the intensional data  i.e. to invoke the embedded calls  or not  before the document is sent. this choice may be influenced by various parameters  such as performance and security considerations. this paper addresses the problem of guiding this materialization process.
﹛we argue that  just like for regular xml data  schemas  ala dtd and xml schema  may be used to control the exchange of intensional data and  in particular  to determine which data should be materialized before sending a document  and which should not. we formalize the problem and provide algorithms to solve it. we also present an implementation that complies with real life standards for xml data  schemas  and web services  and is used in the active xml system  1  1 .
1. introduction
﹛xml  a self-describing semi-structured data model  is becoming the standard format for data exchange between applications. recently  the use of xml documents where some of the data is given explicitly while other parts consist of programs that generate data  started gaining popularity. we refer to such documents as intensional documents  since some parts in them are defined by programs. we will call materialization the process of evaluating some of the programs included in an xml document and replacing them by their results. the goal of this paper is to study the new issues raised by the exchange of such intensional xml documents between applications  and in particular how to decide which

 this project is partially supported by eu ist project dbglobe  ist 1 
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1  june 1  1  san diego  ca.
copyright 1 acm 1-1-x/1 ...$1.
data should be materialized before the document is sent and which should not.
﹛this work was developed in the context of the active xml system and language  1  1  1 . the system is centered around active xml documents  which are xml documents where parts of the content is explicit xml data whereas other parts are generated by calls to web services. in the present paper  we are only concerned with certain aspects of active xml that are relevant to many other systems  which we describe below. we will thus use the term intensional documents to denote documents with such features.
﹛to understand the problem  let us first highlight an essential difference between the exchange of regular xml data and that of intensional xml data. in frameworks such as sun's jsp   or php   intensional data is provided by programming constructs embedded inside documents. upon request  all the code is evaluated and replaced by its result to obtain a regular  fully materialized html or xml document. this simple scenario has recently changed due to emerging standards for web services such as soap and wsdl   and uddi . web services are becoming the standard means of accessing  describing and advertising valuable  dynamic  up-to-date sources of information over the web. recent frameworks such as macromedia mx   apache jelly  and active xml  1  1  1   allow for the definition of intensional data by embedding calls to web services inside documents.
﹛this new generation of intensional documents have a property that we view here as crucial: since web services can be called from essentially anywhere on the web  one does not need anymore to materialize all the intensional data before sending a document. instead  a more flexible data exchange paradigm is possible  where the sender sends an intensional document and gives the receiver the freedom to materialize the data if and when needed. in general  one can use a hybrid approach  where some data is materialized by the sender and some by the receiver.
﹛as a simple example  consider an intensional document for the home-page of a local newspaper. it may contain some extensional xml data  such as general information about the newspaper  and some intensional fragments  e.g. one for the current temperature in the city  obtained from a weather forecast web service  and a listing of current art exhibits  obtained from the timeout local guide. a newspaper reader may receive the full materialized document  a
﹛smaller intensional one  or one where some data is materialized  e.g. the temperature  and some left intensional  e.g. art exhibits .
﹛before getting to the description of the technical solution we propose  let us see some of the considerations that may guide the choice of materializing or not some information:
performance the decision whether to execute calls before or after the data transfer may be influenced by the current system load or the cost of communication. for instance  if the sender's system is overloaded or communication is expensive  the sender may prefer to send smaller files and delegate as much materialization of the data as possible to the receiver. otherwise  it may decide to materialize as much data as possible before transmission  in order to reduce the processing on the receiver's side.
capabilities although web services may in principle be called remotely from anywhere on the internet  it may be the case that the particular receiver of the intensional document cannot perform them  e.g.  a newspaper reader's browser may not be able to handle the intensional parts of a document. and even if it does  the user may not have access to a particular service  e.g.  by lack of access rights. in such cases  it is compulsory to materialize the corresponding information before sending the document.
security even if the receiver is capable of invoking service calls  she may prefer not to do so for security reasons. indeed  service calls may have side effects. receiving intensional data from an untrusted party and invoking the calls embedded in it may thus lead to severe security violations. to overcome this problem  the receiver may decide to refuse documents with calls to services that do not belong to some specific list. it is then the responsibility of a helpful sender to materialize all the data generated by such service calls before sending the document.
functionalities last but not least  the choice may be guided by the application. in some cases  e.g. for a uddi-like service registry  the origin of the information is what is truly requested by the receiver  hence service calls should not be materialized. in other cases  one may prefer to hide the true origin of the information  e.g.  for confidentiality reasons  or because it is an asset of the sender  so the data must be materialized. finally  calling services might also involve some fees that should be payed by one or the other party.
﹛observe that the data returned by a service  say timeout  may itself contain some intensional parts. therefore  the decision of materializing some information or not is inherently a recursive process. for instance  for a receiver who cannot handle intensional documents  the newspaper server would have to recursively materialize all the data before sending it.
﹛how can one guide the materialization of data  for purely extensional data  schemas  like dtd and xml schema  are used to specify the desired format of the exchanged data. similarly  we use schemas to control the exchange of intensional data and  in particular  the invocation of service calls. the novelty here is that schemas also entail information about which parts of the data are allowed to be intensional and which service calls may appear where in the documents. before sending information  the sender must check if the data  in its current structure  matches the schema expected by the receiver and if not  the sender must perform the required calls for transforming the data into the desired structure  if possible.
﹛a typical such scenario is depicted in figure 1. the sender and the receiver  based on their personal policies  have agreed on a specific data exchange schema. now  consider some particular data t to be sent  represented by the grey triangle in the figure . in fact  this document represents a set of equivalent  increasingly materialized  pieces of information - the documents that may be obtained from t by materializing some of the service calls  q  g and f . among them  the sender must find at least one document conforming to the exchange schema  e.g.  the dashed one  and send it. the contributions of the paper are as follows:

figure 1: data exchange scenario for intensional documents
1. we provide a simple but flexible xml-based syntax to embed service calls in xml documents  and introduce an extension of xml schema for describing the required structure of the exchanged data. this consists in adding new type constructors for service call nodes. in particular  our typing distinguishes between accepting a concrete type  e.g. a temperature element  and accepting a service call returning some data of this type  e.g.     ↙ temperature.
1. given a document t and a data exchange schema  the sender needs to decide which data has to be materialized. we present algorithms that  based on schema and data analysis  find an effective sequence of call invocations  if such a sequence exists  or detect a failure if it does not . the algorithms provide different levels of guarantee of success for this rewriting process  ranging from  sure  success to a  possible  one.
1. at a higher level  in order to check compatibility between applications  the sender may wish to verify that all the documents generated by its application may be sent to the target receiver  which involves comparing two schemas. we show that this problem can be easily reduced to the previous one.
﹛as explained above  our algorithms find an effective sequence of call invocations  if one exists  and detect failure otherwise. in a more general context  an error may arise because of type discrepancies between the caller and the receiver. one may then want to modify the data and convert it to the right structure  using data translation techniques such as  1  1 . as a simple example  one may need to convert a temperature from celsius degrees to fahrenheit. although such aspects are clearly complementary and could be added to our framework  they are not considered here. the focus here is on partially materializing the given data to match the specified schema.
﹛the core technique of this work is based on automata theory. for presentation reasons  we detail a simplified version of the main algorithm. we briefly sketch a more dynamic  optimized one  that is based on the same core idea and is used in our implementation.
﹛although the problems studied in this paper are related to standard typing problems in programming languages   things are different here  due to the regular expressions present in xml schemas. indeed  the general problem that will be formalized here is still open. we introduce a restriction that is practically founded and leads to a tractable solution.
﹛all the ideas presented here have been implemented and tested in the context of the active xml system 1  1 . this system provides persistent storage for intensional documents with embedded calls to web services  along with active features to automatically trigger these services and thus enrich/update the intensional documents. furthermore  it allows users to declaratively specify web services that support intensional documents as input and output parameters. we used the algorithms described here to implement a module that controls the types of documents being sent to  and returned by  these web services. this module is in charge of materializing the appropriate data fragments to meet the interface requirements.
﹛in the following  we assume that the reader is familiar with xml and its typing languages  dtd or xml schema . whereas basic notions of soap and wsdl might be helpful to understand the details  they are not necessary.
﹛the paper is organized as follows: section 1 describes a simple data model and schema specification language and formalizes the general problem. additional features for a richer data model that facilitate the design of real life applications are also introduced informally. section 1 focuses on difficulties that arise in this context  and presents the key restriction that we consider. it also introduces the notions of  safe  and  possible  rewriting which are studied in section 1 and 1 respectively. the problem of checking compatibility between intensional schemas is considered in section 1. the implementation is briefly described in section 1. the last section studies related works and concludes.
1. the model and the problem
﹛to simplify the presentation  we start by formalizing the problem using a simple data model and a dtd-like schema specification. more precisely  we define the notion of rewriting  which corresponds to the process of invoking some service calls in an intensional document  in order to make it conform to a given schema. once this is clear  we explain how things can be extended to provide the features ignored by the first simple model  and in particular we show how richer schemas are taken into account.
simple intensional xml. we model intensional xml documents as labeled trees consisting of two types of nodes: data nodes and function nodes. the latter correspond to service calls. we assume the existence of some disjoint domains: n of nodes  l of labels  f of function names 1  and d of data values. in the sequel we use v u w to denote nodes  a b c to denote labels  and f g q to denote function names.
definition 1. an intensional document d is an expression
 t 竹   where t =  n e    is an ordered tree. n   n is a finite set of nodes  e   n ℅ n are the edges    associates with each node in n a total order on its children  and 竹 : n ↙ l ﹍ f ﹍ d is a labeling function for the nodes  where only leaf nodes may be assigned data values from d.
﹛nodes with a label in l ﹍ d are called data nodes while those with a label in f are called function nodes. the children subtrees of a function node are the function parameters. when the function is called  these subtrees are passed to it. the return value then replaces the function node in the document. this is illustrated in figure 1  where function nodes are represented by squares. here  the

timeouttimeout
	 exhibits 	 exhibits 
 1∼c 
 1/1 
	a. before	b. after
figure 1: an intensional document before/after a call.
get temp web service is invoked with the city name as a parameter. it returns a temp element  which replaces the function node. an example of the actual xml representation of intensional documents is given in section 1. observe that the parameter subtrees and the return values may themselves be intensional documents  i.e. contain function nodes.
simple schema. we next define simple dtd-like schemas for intensional documents. the specification associates  1  a regular expression with each element name that describes the structure of the corresponding elements  and  1  a pair of regular expressions with each function name  that describe the function signature  namely its input and output types.
﹛definition 1. a document schema s is an expression  l f 而   where l   l and f   f are finite sets of labels and function names respectively  而 is a function that maps each label name l ﹋ l to a regular expression over l ﹍ f or to the keyword  data   for atomic data   and maps each function name f ﹋ f to a pair of such expressions  called the input and output type of f and denoted by 而in f  and 而out f .
for instance  the following is an example of a schema. data :
   而 newspaper 
而 title  而 date  而 temp  而 city  而 exhibit  functions :=
= =
=
=
=title.date. get temp | temp 
. timeout | exhibit  
data data data data
title. get date | date 而in get temp =city而out get temp =temp而in timeout =data而out timeout = exhibit | performance  而in get date =title而out get date =date﹛we next define the semantics of a schema  i.e.  the set of its instances. to do so  if r is a regular expression over l ﹍ f  we denote by lang r  the regular language defined by r. the expression lang data  denotes the set of data values in d.
﹛definition 1. an intensional document t is an instance of a schema s =  l f 而  if for each data node  resp. function node  n ﹋ t with label l ﹋ l  resp. l ﹋ f   the labels of n's children form a word in lang 而 l    resp. in lang 而in l   .
﹛for a function name f ﹋ f  a sequence t1 ... tn of intensional trees is an input instance  resp. output instance  of f  if the labels of the roots form a word in lang 而in f    resp. lang 而out f    and all the trees are instances 1 of s.

﹛it is easy to see that the document of figure 1.a is an instance of the schema of      but not of a schema with 而1 identical to 而 above  except for:
     而1 newspaper  = title.date.temp. timeout | exhibit  
however  the document can always be turned into an instance of the schema of       by invoking the get temp service call and replacing it by its return value. on the other hand  consider a schema with 而1 identical to 而  except for:
      而1 newspaper  = title.date.temp.exhibit 
according to the signature  a call to timeout may also return performance elements. therefore  in general  the document may not become an instance of the schema of      . however  it is possible that it becomes one  if timeout returns a sequence of exhibits . the only way to know is to call the service.
﹛this type of  on-line  testing is fine if the calls have no side effects or do not cost money. if they do  we might want to warn the sender  before invoking the call  that the overall process may not succeed  and see if she wants to proceed nevertheless.
rewritings. when the proper invocation of service calls leads for sure to the desired structure  we say that the rewriting is safe  and when it only possibly does  that this is a possible rewriting. these notions are formalized next.
	v	1
﹛definition 1. for a tree t  we say that t ↙ t if t is obtained from t by selecting a function node v in t with some label f and replacing it by an arbitrary output instance of f 1. if t ↙v1 t1 ↙v1 t1 ... ↙vn tn we say that t rewrites into tn  denoted t ↙  tn. the nodes v1 ... vn are called the rewriting sequence. the set of all trees t1 s.t. t ↙  t1 is denoted ext t .
﹛note that in the rewriting process  the replacement of a function node v by its output instance is independent of any function semantics. in particular  we may replace two occurrences of the same function by two different output instances. stressing somewhat the semantics  this can be interpreted as if the value returned by the function changes over time. this captures the behavior of real life web services  like a temperature or stock exchange service  where two consecutive calls may return a different result.
﹛definition 1. let t be a tree and s a schema. we say that t possibly rewrites into s if ext t  contains some instance of s. we say that t safely rewrites into s either if t is already an instance of s  or if there exists some node v in t s.t. all trees t1 where t ↙v t1 safely rewrite into s.
﹛the fact that t safely rewrites into s means that we can be sure  without actually making any call  that we can choose a sequence of calls that will turn t into an instance of s. for instance  the document of figure 1.a safely rewrites into the schema of      but only possibly rewrites into that of        .
﹛finally  to check compatibility between applications  we may want to check whether all documents generated by one application  e.g. the sender application  can be safely rewritten into the structure required by the second application  e.g. the agreed data exchange format .

﹛definition 1. let s be a schema with some distinguished label r called the root label. we say that s safely rewrites into another schema s1 if all the instances t of s with root label r rewrite safely into instances of s1.
﹛for instance  consider the schema of     presented above with document as the root label. this schema safely rewrites into the schema of      but does not safely rewrite into the one of        .
the results. going back to the data exchange scenario described in the introduction  we can now specify our main contributions:
 1  we present an algorithm that tests whether a document t can be safely rewritten into some schema s and  if so  provides an effective rewriting sequence  and
 1  when safe rewriting is not possible  we present an algorithm that tests whether  nevertheless  t may be possibly rewritten into s  and finds a possibly successful rewriting sequence  if one exists.
 1  we also provide an algorithm for testing  given two schemas  whether one can be safely rewritten into the other.
1 a richer data model
﹛in order to make our presentation clear  and to simplify the definition of document and schema rewritings  we used a very simple data model and schema language. we will now present some useful extensions that bring more expressive power  and facilitate the design of real life applications.
function patterns. the schemas we have seen so far specify that a particular function  identified by its name  may appear in the document. but sometimes  one does not know in advance which functions will be used at a given place  and yet may want to allow their usage  provided that they conform to certain conditions. for instance  we may have several editions of the newspaper of figure 1.a  for different cities. a common intensional schema for such documents should not require the use of a particular get temp function  but rather allow for a set of functions  which have a proper signature. the particular weather forecast function that will be used may depend on the city and be  for instance  retrieved from some uddi service registry. we may also want to check that the function is safe according to some security policy.
﹛to specify such sets of functions  we use function patterns. a function pattern definition consists of a boolean predicate over function names and a function signature. a function belongs to the pattern if its name satisfies the boolean predicate and its signature is the same as the required one.
﹛in terms of implementation  one can assume that the boolean predicate is implemented as a web service that takes a function name as input and returns true/false.
﹛let p be a domain of function pattern names. a schema s =  l f p 而  now also contains  in addition to the elements and functions  a set of function patterns p   p. 而 associate with each function pattern p ﹋ p a signature and a boolean predicate over function names. we can now  for instance  write a schema for our local newspapers as:
老 newspaper  = title.date. forecast | temp 
﹛﹛﹛﹛﹛﹛﹛. timeout | exhibit   而name forecast  = uddif ＿ inacl 而in forecast  = city 而out forecast  = temp
this schema enforces the fact that the function used in the document has the proper signature and satisfies the boolean predicates uddif and inacl. the first predicate  uudif  is a web service that checks if the given function  service  is registered in some particular uddi registry. predicate inacl then verifies if the client has the necessary access privileges for executing the given function  calling the service .
wildcards. together with function patterns  one may also use wildcards in schemas. their use is already common for data  to express the fact that a certain part of a document may contain an arbitrary unconstrained subtree. xml schema further allows one to restrict wildcards to  or exclude from them  certain domains of data  through the use of namespaces . this extends naturally to our context  using wildcards to allow certain document parts to contain arbitrary sub-trees with arbitrary functions  or restrict it to  resp. exclude from it  certain classes of functions.
﹛the combination of wildcards and function patterns allows for great flexibility in describing the structure of documents. for instance  one may specify that the temperature is obtained from an arbitrary function that returns a correct temp element  but may take any argument  being data or function call.
restricted service invocations. another interesting extension is the following: we assumed so far that all the functions appearing in a document may be invoked in a rewriting  in order to match a given schema. this is not always the case  for the same reasons as mentioned in the introduction  security  cost  access rights  etc. . the logic of rewritings will have to take this into account  essentially by considering  among all possible rewritings  only a proper subset. for that  the function names/patterns in the schema can be partitioned into two disjoint groups of invocable and noninvocable ones. a legal rewriting is then one that invokes only invocable functions. the notions of safe and possible rewritings extend naturally to consider only legal rewritings. since we are interested here only in such rewritings  whenever we talk in the sequel about a function invocation  we mean an invocable one.
xml and xml schema. the simple xml trees considered above ignore a number of features of xml  such as attributes  and use a single domain for data values. a richer setting may be obtained by using the full fledged xml data model . similarly  richer schemas may be defined by adopting xml schema   rather than using the simple dtd-like schema used above. indeed  our implementation is based on the full xml model and on an extension of xml schema.
﹛in our prototype  functions embedded in xml documents are represented by special function elements that identify the web services to be invoked and specify the value of input parameters. xml schemas are enriched for intensional documents  to form xml schemaint  by function and function pattern definitions. in both cases  things are very much along the lines of the simple model we used above. we will see an example and more details of this in section 1.
1. exchanging intensional data
﹛we start by considering document rewriting. schema rewriting is considered later in section 1.
﹛given a document t that the sender wishes to send  and an agreed data exchange schema s  the sender needs to rewrite t into s. a possible process is as follows:
1. check if t safely rewrites to s and if so  find a rewriting sequence  namely a sequence of functions that need to be invoked to transform t into the required structure  preferably the shortest or cheapest one  according to some criteria .
1. if a safe rewriting does not exist  check whether at least t may rewrite to s. if it is acceptable to do so  the sender accepts that the rewriting may fail   try to find a successful rewriting sequence if one exists  preferably with the least side effects on the path to find it  and at the least cost .
a variant is to combine safe and possible rewritings. for instance  one could consider a mixed approach  that first invokes some function calls  and then attempts from there to find safe rewritings. there are many alternative strategies.
﹛we will first consider safe document rewriting  then move to the unsafe case  and finally consider the mixed approach. as in the previous section  to simplify the presentation  we first consider the problems in the context of the simple data model defined above. then in section 1 we will show that the proposed solutions naturally extend to richer data/schemas and in particular to the context of full fledged xml and xml schema.
﹛before presenting solutions  let us first explain some of the difficulties that one encounters when attempting to rewrite a document to a desired exchange schema. while the examples given in the previous sections were rather simple - and one could determine by a simple observation of the document which service calls need to be issued - things may in general be much more complex. we explain next why this is the case and present a restriction that will make the problem tractable.
going back and forth. the rewriting sequence may depend on the answers being returned by the functions: we may call one function at some place in the document  and then decide  possibly based on its answer  that another function in the new data or in a different part of the document needs to be called  and so on. in general  this may force us to analyze the same portion of the document many times  re-examining the same function call again and again  deciding at each iteration whether  based on the answers returned so far  the function now needs to be called or not. such an iterative process may naturally be very expensive. we thus restrict our attention here to a simpler class of  one-pass  left-to-right rewritings 1 where for each node  the children are processed from left to right  and once a child function is invoked  no further invocations are applied to its left hand sibling functions  i.e. successive children invocations are limited to the new children functions possibly returned by the call  plus the right hand siblings. .
﹛observe that in general  with this restriction  one can miss a successful rewriting that is not left-to-right. in all the real-life examples that we considered  left-to-right rewritings were not limiting.
infinite search space. the essence of safe rewriting is that it succeeds no matter what specific answers  among the possible ones  the invoked functions return. the domain of the possible answers of each function is determined by its output type. since the regular expression defining this type may contain starred   *   subexpressions  the domain is infinite  and the safe rewriting should account for each possible element in this infinite domain. moreover  the result of a service call may contain intensional data  namely other function calls. in general the number of such new functions may be unbounded. for instance  consider a get exhibits function  with output type 而out get exhibits  = get exhibit .
when get exhibits is invoked  an arbitrary large number of
get exhibit functions may be returned  and one has to check for

each of the occurrences whether this particular function call needs to be invoked and whether  after the invocation  the document can still be  safely  rewritten into the desired schema.
recursive calls. as explained above  when a function is invoked  the returned data may itself contain new calls. to conform to the target schema  these calls may need to be triggered as well. the answer again may contain some new calls  etc. this may lead to infinite computations. observe that such recursive situations do occur in practice. for example  a search engine web service may return  for a given keyword  some document urls plus  possibly  a function node for obtaining more answers. calling this function  one can obtain a new list and perhaps another function node  etc. if the target schema requires plain xml data we need to repeatedly call the handles until all the data has been obtained. in this example  and often in general  one may want to bound the recursion. this suggests the following definition and our corresponding restriction:
	v1	vn
﹛definition 1. for a rewriting sequence t ↙ t1 ... ↙ tn  we say that a function node vj depends on a function node vi if vj ﹋ ti but 1﹋ ti 1  namely if the node vj was returned by the invocation of the function vi .
﹛we say that a rewriting sequence is of depth k if the dependency graph among the nodes contains no paths of length greater than k.
therestriction. the restriction that we will impose below is the following: we will consider only k-depth left-to-right rewritings.
﹛note that while this restriction limits the search space  the latter remains infinite  due to the starred sub-expressions appearing in the schema. however  under this restriction  we can exhibit a finite representation  based on automata  of the search space and use automata-based techniques to solve the safe rewriting problem.
﹛even with this restriction  the framework is general enough to handle most practical cases. it remains open whether the problem of arbitrary safe rewriting  without the left-to-right k-depth restriction  is decidable. we proved decidability of arbitrary safe rewriting for a restricted class of schemas but those are only of theoretical interest. due to space limitations  this will not be presented here.
1. safe rewriting
﹛in this section  we present an algorithm for k-depth safe rewriting.
﹛we are given a document tree t and a schema s1 =  l1 f1 而1  describing the signature of all the functions in the document  as well as the elements/functions used in these signatures . this corresponds to having a wsdl description for each service being used  which is a normal requirement for web services. we are also given a data exchange schema s =  l f 而   and our goal is to safely rewrite t into s  with a k-depth rewriting .
﹛to simplify  we assume that common functions have the same definitions in s1 and s. this is reasonable since the function definitions represent the wsdl description of the functions  as given by the service providers. while this assumption simplifies the rewriting process  it is not essential. the algorithm can be extended to handle distinct signatures  but we omit this here for space reasons.
﹛for clarity  we decompose the presentation of the algorithm into three parts.
1. the first part explains how to deal with function parameters. the main point is that  since the parameters may themselves contain other function calls  with parameters   the tree rewriting starts from the deepest function calls and recursively moves upward.
1. the second part explains how the rewriting in each such iteration is performed. the key observation is that this can be achieved by traversing the tree from top to bottom  handling one node  and its direct children  at a time.
1. finally  the third and most intricate part  explains how each such node  and its direct children  is handled. in particular  we show how to decide which of the functions among these children needs to be invoked in order to make the node fit the desired structure.
for presentation reasons  we give here a simplified version of the actual algorithm used in the implementation. to optimize the computation  a more dynamic variant  based on the same idea  is used there. we explain the main principles of this variant in section 1.
rewritingfunction parameters. to invoke a function  its parameters should be of the right type. if they are not  they should be rewritten to fit that type. when rewriting the parameters  again  the functions appearing in them can be invoked only if their own parameters are  or can be rewritten into  the expected input type. we thus start from the  deepest  functions  i.e. those having no function occurrences in the parameters  and recursively move upward:
  for the deepest functions  we verify that their parameters are indeed instances of the corresponding input types. if not  the rewriting fails.
  then moving upward  we look at a function f and its parameters. all the functions appearing in these parameters were already handled - namely their parameters can be safely rewritten to the appropriate type. we thus ignore the parameters of these lower level calls  together with all the functions included in them  and just try to safely rewrite f's own parameters into the required structure. if this is not possible  the rewriting fails.  for the same reason as above .
at the end of this process we know that all the outmost function calls in t are fine. we can thus ignore their parameters  and whatever functions that appear in them  and need to safely rewrite t into s by invoking only these outmost calls.
top down traversal. in each iteration of the above recursive procedure we are given a tree  or a forest  where the parameters of all the outmost functions have already been handled  and we need to safely rewrite the tree  forest  by invoking only these outmost functions. to do that we can traverse the tree forest  top down  treating at each step a single node and its immediate children.
﹛consider a node n whose children labels form a word w. note that the subtree rooted at n can be safely rewritten into the target schema s =  l f 而  if and only if  1  w can be safely rewritten into a word in lang 而 label n    and  1  each of n's children subtrees can itself be safely rewritten into an instance of s 1. thus  we can start from the root and  going down  for each node n try to safely rewrite the sequence of its children into a word in lang 而 label n   . the algorithm succeeds if all these individual rewritings succeed.

﹛the safe rewriting of a word w involves the invocation of functions in w and  recursively  new functions that are added to w by those invocations. to conclude the description of our rewriting algorithm we thus only need to explain how this is done.
rewriting the children of a node n. this is the most intricate part of the algorithm. we are given a word w - the sequence of labels of n's children - and our goal is to rewrite w to fit the target schema. namely  we need to rewrite w so that it becomes a word in the regular language r = 而 label n  . the rewriting process invokes functions in w and  recursively  new functions that are added to w by those invocations. each such invocation changes w  replacing the function occurrence by its returned answer. the possible changes that the invocation of a function fi may cause are determined by the output type rfi = 而out fi  of fi 1. for instance  if w = a1 a1 ... fi ... am  invoking fi changes w into some w1 = a1 a1 ... b1 ... bk ... am where b1 ... bk ﹋ lang rfi .
﹛since the functions signatures  as well as the target schema  are given in terms of regular expressions  it is convenient to reason about them  and about the overall rewriting process  by analyzing the relationships between their corresponding finite state automata. we assume some basic knowledge of regular languages and finite state automata  and use in our algorithm standard notions such as the intersection and complement of regular languages and the cartesian product of automata. for basic material  see for instance .
﹛given the word w  the output types rf1 ... rfn of the available functions  and the target regular language r  the algorithm in figure 1 tests if w can be safely rewritten into a word in r  and if so  finds a safe rewriting sequence.
﹛we give the intuition behind this algorithm next. to illustrate  we use the newspaper document in figure 1.a. assume that we look at the root newspaper node. its children labels form the word w = title.date.get temp.timeout. assume that we want to find a safe rewriting for this word into a word in the regular language 而1 newspaper  of the schema of  **   namely
r = title.date.temp. timeout | exhibit  .
﹛the process of rewriting involves choosing some functions in w and replacing them by a possible output; then choosing some other functions  which might have been returned by the previous calls  and replacing them by their output  and so on  up to depth k. for each function occurrence we have two choices: either to leave it untouched  or to replace it by some word in it output type. the automaton akw constructed in steps 1 of the algorithm represents precisely all the words that can be generated by such a k-depth rewriting process. the fork nodes are the nodes where a choice  i.e. invoking the function or not  exists  and the two fork options represent the possible consequent steps in the automaton  depending on which of the two choices was made. going back to the above example  figure 1 shows the 1-depth automaton aw1 for the word w = title.date.get temp.timeout  with the signature of the get temp and timeout functions defined as in section 1. q1 and q1 are the fork nodes and their two outgoing edges represent their fork options for get temp and timeout  resp. an  edge represents the choice of invoking the function while a function edge represents the choice not to invoke it.
﹛suppose first that we want to verify that all possible rewritings lead to a  good  word  i.e. that they belong to the target language

safe rewriting  word w  functions output types rf1 ...rfn  target language r 1build finite state automata for the following regular languages:1 a  an automaton aw accepting w as a single word.1 b  automata afi  i = 1...n  each accepting the regular language rfi.
1 c  an automaton a accepting the complement of the regular language r. the automaton should be deterministic and complete  namely each state has outgoing edges for all possible letters.1let akw := aw.1for j = 1 ... k1consider all the edges e =  v u  in akw that are labeled by an  invocable  function name fi and were not treated in previous iterations. for each such edge:1 a  extend akw by attaching a copy of the automaton afi  with its initial and final accepting states linked to v and u resp. by  moves.1 b  denote v as a fork node  for the edge e .1 c  the two fork options of v  for e  are e itself and the new outgoing  edge.1
construct the cartesian product automaton a℅ = akw ℅ a.1the fork nodes and fork options in a℅ reflect those of akw:1 a  the fork nodes  q p  ﹋ a℅ are those where q was a fork node in akw.1 b  similarly  a fork option in a℅ consists of all edges originating from one fork option edge in akw.1mark nodes in a℅ as follows.1 a  first mark all accepting states   namely nodes  q p 

where q and p are accepting states in akw and a resp.1 b  then iteratively: mark regular  non fork  nodes if one of their outgoing edges points to a marked node; mark fork nodes if in both their fork options  for some fi  contain an edge that points to a marked node.1a safe rewriting exists iff the initial state is not marked.1to obtain such a rewriting:1 a  follow a non marked path  corresponding to w  starting from the initial state of a℅ to a state  q p  where q is an accepting state of akw.1- the non marked fork options on the path determine the rewriting choices  i.e. which functions to call .1- when a function is invoked we continue the path with the new rewritten word  rather than the original w .1 b  to minimize the rewriting cost  chose a path with minimal number/cost of function invocations.1exitfigure 1: safe rewriting of w into r.

figure 1: the aw1 automaton from the newspaper document.

figure 1: the complement automaton a for schema  ** .

figure 1: the cartesian product automaton a℅.
r. to put things in regular language terms  the intersection of the language of akw  consisting of these words  with the complement of the target language r should be empty. a standard way to test that the intersection of two regular languages is empty is to  i  construct

an automaton a for the complement of the language r   ii  build a

cartesian product automaton a℅ = akw ℅ a for the two automata

akw and a  and  iii  check whether it accepts no words.

﹛the cartesian product automaton of akw and a is built in step 1 of the algorithm. to continue with the above example  the complement automaton for the regular language r = 而1 newspaper  of the schema of  **  is given in figure 1. the accepting states are p1 p1 p1 and p1. for brevity we use  *  to denote all possible alphabet transitions besides those appearing in other outgoing edges.

the cartesian product automaton a℅ = aw1 ℅ a  where aw1 and

a are the automata of figures 1 and 1  resp.  is given in figure 1. the initial state is  q1 p1  and the final accepting one is  q1 p1 .
﹛note however that  when searching for safe rewriting  one does not need to verify that all possible rewritings lead to a 'good word' 

i.e.  that none the words in akw belongs to a. we only have to verify that for each function  there is some fork option  i.e. invoking the function or not  that  if taken  will not lead to an accepting state. since we are looking for left-to-right safe rewritings  we need to check that  traversing the input from left to right  at least one such 'good' fork options exists for each function call on the way. the marking of nodes in steps 1 of the algorithm achieves just that. recall that we required in step  1  that the complement

automaton a is complete. this is precisely what guarantees that all the fork nodes/options of akw are recorded in a℅ and makes the above marking possible.
﹛the marking for our particular example is illustrated in figure 1. the colored nodes are the marked ones. as can be seen  the fork nodes  q1 p1  and  q1 p1  are not marked. for the first node  this is because fork option is not marked. for the second one  it is due
to the unmarked timeout fork option. consequently  the initial
state is not marked as well and there is a safe rewriting of the newspaper element to the schema of  ** . the safe rewriting sequence is the one obtained by following a non marked path. each fork node on the path  together with its non-marked fork option  determines

figure 1: the cartesian product automaton a1℅.
what needs to be done with the corresponding function - edge means  invoke the function  while a function edge means  do not invoke . in our example  it is easy to see  following the path with colored background  that get temp needs to be invoked while timeout should not.
﹛for another example  consider the schema of  *** . here a newspaper is required to have the structure conforming to the regular expression title.date.temp.exhibit . the complement automaton

a1 for this language is given in figure 1. to test whether it is possible to safely rewrite our newspaper document into this schema 

we construct a cartesian product automaton a1℅ = aw1 ℅ a1  with
aw1 as in figure 1 and a1 as in figure 1 . given in figure 1.
﹛as one can see  in this case  the two fork nodes  q1 p1  and  q1 p1  have both their fork options marked. consequently the initial state is marked as well and there is no safe rewriting of w into the schema of  *** . note that this is precisely what our intuitive discussion from section 1 indicated: the invocation of timeout may return performance elements  hence the result may not conform to the desired structure.
﹛the following proposition states the correctness of our algorithm. we omit the proof for space reasons.
﹛proposition 1. the above algorithm finds a k-depth left-toright safe rewriting if one exists.
complexity. we conclude this section by briefly discussing the complexity of the algorithm. recall that we use s1 to denote the schema of the sender and s to denote the agreed data exchange schema. the complexity of deciding whether a safe rewriting exists is determined by the size of the cartesian product automaton: we need to construct it and then traverse and mark its nodes. more precisely  the complexity is bounded by o | a℅ |1  = o  | awk |

℅ | a | 1 . the size of akw is at most o  | s1 | + | w | k  and the

size of the complement automaton a is at most exponential in the automaton being complemented   namely at most exponential in the size of the target schema s. this exponential blow up may happen however only when s uses non deterministic regular ex-
possible rewriting  word w  functions output types rf1 ...rfn  target language r 1build finite state automaton for the following regular languages:1 a  an automaton akw as in figure 1 b  an automaton a accepting the regular language r.1construct the cartesian product automaton a℅ = akw ℅ a.1mark all nodes in a℅ having some outgoing path leading to a final state.1a rewriting may exist if the initial state is marked.1to obtain such a rewriting:1 a  follow a marked path from the initial state of a℅ to a final one  with the fork options on the path determining the rewriting choices  as in figure 1 .1 c  backtrack when the calls return a value that does not allow to to continue to an accepting state.1 d  to minimize the rewriting cost  chose a path with minimal number/cost of function invocations.1exit
exhibit
figure 1: an automaton a for schema  *** 
figure 1: possible rewriting of w into r
pressions  i.e. regular expressions whose corresponding finite state automaton is non deterministic . note however that xml schema enforces the usage of deterministic regular expressions only. hence for most practical cases  the complexity is polynomial in the size of the schemas s1 and s  with the exponent determined by k .
﹛the complexity of actually performing the rewriting depends on the size of the answers returned by the called functions. if x is the maximal answer size  the length of the generated word is bounded by w ℅ xk.
1. possible rewriting
﹛we considered safe rewriting in the previous section. we now turn to possible rewriting. while function signatures provide an  upper bound  of the possible output  when invoked with the actual given parameters they may return a restricted  appropriate  output  so a rewriting that looked non feasible  unsafe  may turn to be possible after some function calls. to test if a rewriting may exist  we follow a similar three-steps procedure as for safe rewriting:  1  test functions parameters first   1  traverse the tree top down  and  1  check each node individually  trying to rewrite the word w consisting of the labels of its direct children.
﹛steps  1  and  1  are exactly as before. for step  1   figure 1 provides an algorithm to test if the children of a given node may rewrite to the target schema. as before we use the automaton akw that describes all the words that may be derived from the word w in a k-depth rewriting. w may rewrite to a word in the target language r iff some of these derived words belong to r. namely  the intersection of the two languages  akw and r  is not empty. to test this we construct   in step 1 of the algorithm   the cartesian product automaton for these two languages and test   in step 1   that the final state is reachable from the initial one . to find the actual rewriting  we follow an accepting path: we invoke functions  or not  as indicated by the fork options on the path  and backtrack when failing  i.e. when the function returns a value that does not
correspond to the acceptance path. 
﹛for instance  consider the automaton a for the schema of  ***  with newspaper structure title.date.temp.exhibit  given in figure 1. the initial state is p1 and the final accepting states are p1 and p1. the cartesian product automaton in figure 1 and a as in figure 1  is given in figure 1. the initial state is  q1 p1 . the final accepting states are  q1 p1  and  q1 p1   and all states  including the initial one  have an outgoing path to figure 1: cartesian product automaton for possible rewriting.
a final state. the only possible fork options left in the automaton  and which may lead to a possible rewriting  are the ones requiring the invocation of both get temp and timeout functions. if timeout returns nothing but exhibits the rewriting succeeds. the correctness of this algorithm is stated below.
﹛proposition 1. the above algorithm finds a k-depth left-toright rewriting  if one exists.
﹛the complexity here is again determined by the size of the cartesian product automaton. however  in this case  it uses the schema automaton a  rather than its complement  as for safe rewriting . hence  the complexity is polynomial in the size of the schemas s1 and s  with the exponent determined by k .
amixedapproach. as seen above  much of the work in searching for a safe rewriting comes from the size of the automaton akw that accounts for all possible outputs of function invocation. a mixed approach  that invokes some of the functions  e.g. ones with no side effects or low price  to get their actual output  while safely verifying other functions can be clearly beneficial. in terms of the algorithm of figure 1 above  rather than using the full function signature automaton afi  we will use a smaller one that describes just the type of the actual returned result. this may greatly simplify the resulting automaton akw. the output of the invoked calls can also be later used in the actual rewriting. details are omitted.
1. schema rewriting
﹛so far  we considered the rewriting of a single document. at a higher level  to check compatibility between applications  the sender may wish to verify that all the documents generated by her application can indeed be sent to the target receiver. given a schema s1 for the sender documents  and some distinguished root label r  we want to verify that all the instances of s1 with root r can be safely rewritten to the schema s. interestingly  it turns out that safe rewriting for schemas is not more difficult than that of documents. in fact  rather than testing all the schema instances  an infinite number  it suffices to look at a small number of representative documents. the key idea is that testing whether all the elements of a given type have a safe rewriting is analogous to testing whether a single function element  with an output of that type  can be safely rewritten into the target schema. thus  to check s1  we need to look at one such function per element type in s1  and test whether a document containing it as its single element can be safely rewritten. we omit the details for space reasons.
1. implementation
﹛the ideas and algorithms presented in the previous sections have been implemented and used in the schema enforcement module of the activexml system  1  1 . we next present how the intensional data model and schema language of the previous sections map to xml  xml schema  soap and wsdl. then we briefly describe the activexml system and the schema enforcement module.
using the standards. in the implementation  an intensional
xml document is a syntactically well-formed xml document. this is because we also use an xml-based syntax to express the intensional parts in it. to distinguish these parts from the rest of the document  we exploit the xml namespace  mechanism. more precisely  the namespace http://www.activexml.com/ns/int is defined for function  service  calls. these calls can appear at any place where xml elements are allowed. the following example corresponds to the document of figure 1.a:
  xml version= 1   
 newspaper xmlns:int= http://www.activexml.com/ns/int  
 title  the sun  /title 
 date  1/1  /date 
 int:fun endpointurl= http://www.forecast.com/soap  methodname= get temp  namespaceuri= urn:xmethods-weather  
 int:params 
 int:param 
 city paris /city 
 /int:param 
 /int:params 
 /int:fun 
 int:fun endpointurl= http://www.timeout.com/paris  methodname= timeout   namespaceuri= urn:timeout-program  
 int:params 
 int:param  exhibits  /param 
 /int:params 
 /int:fun 
 /newspaper 
﹛three attributes of the function nodes provide the necessary information to call the soap service: the url of the server  the method name  and the associated namespace.
﹛in order to define schemas for intensional documents  we use xml schemaint  which is an extension of xml schema. to describe intensional data  xml schemaint introduces functions and function patterns. these are declared and used like elements and types in the standard xml schema language. in particular  it is possible to declare functions and function patterns globally  and reference these declarations inside complex type definitions  e.g. sequence  choice  all . we give next the xml representation of function patterns that are described by a combination of some optional attributes and two optional sub-elements  params and return:
 functionpattern
	id = ncname	methodname = token
	endpointurl = anyuri	namespaceuri = anyuri
wsdlsignature = anyuri ref = ncname 
contents:  params   return  
 /functionpattern 
﹛the id attribute identifies the function pattern  which can then be referenced by another function pattern using the ref attribute. attributes methodname  endpointurl and namespaceuri designate the soap function that implements the boolean predicate used for the function pattern. it takes as input parameter the function to validate. as a convention  when these parameters are omitted  the predicate returns true for all functions. the contents detail the function signature  i.e. the expected types for the input parameters and the result of function calls. these types are also defined using xml schemaint  and may contain intensional parts.
﹛to illustrate this syntax  consider the function pattern forecast  that captures any function with one input parameter of element type city  returning an element of type temp. it is simply described by:
 functionpattern id= forecast  
 params 
﹛ param   element ref= city /   /param   /params 
 result   element ref= temp /   /result 
 /functionpattern 
﹛functions are declared in a similar way as function patterns  by using elements of type function. the main difference is that the three attributes methodname  endpointurl and namespaceuri directly identify the function that can be used.
﹛as mentioned already  function and function pattern declarations may be used at any place where regular element and type declarations are allowed. for example  a newspaper element with structure title.date. forecast | temp . timeout | exhibit   may be defined in xml schemaint as:
 element name= newspaper  
 complextype 
 sequence 
 element ref= title / 
 element ref= date / 
 choice 
 functionpattern ref= forecast / 
 element ref= temp / 
 /choice 
 choice 
 functionpattern ref= timeout / 
 element ref= exhibit  minoccurs= 1  maxoccurs= unbounded / 
 /choice 
 /complextype 
 /element 
﹛similarly to xml schema  we require the definitions to be unambiguous . namely  when parsing a document  for each element and each function node  the sub-elements can be sequentially assigned a corresponding type/function pattern in a deterministic way by looking only at the element/function name.
﹛one of the major features of the wsdl language is to describe the input and output types of web services functions using xml schema. we extend wsdl in the obvious way  by simply allowing these types to describe intensional data  using xml schemaint. finally  xml schemaint allows wsdl or wsdlint descriptions to be referenced in the definition of a function or function pattern  instead of defining the signature explicitly  using the wsdlsignature attribute .
the activexml system. activexml is a peer-to-peer system that is centered around intensional xml documents. each peer contains a repository of intensional documents  and provides some active features to enrich them by automatically triggering the function calls they contain. it also provides some web services  defined declaratively as queries/updates on top of the repository documents. all the exchanges between the activexml peers  and with other web service providers/consumers use the soap protocol.
﹛the important point here is that both the services that an activexml peer invokes and those that it provides potentially accept intensional input parameters and return intensional results. calls to  regular  web services should comply with the input and output types defined in their wsdl description. similarly  when calling an activexml peer  the parameters of the call should comply with its interface. the role of the schema enforcement module is  i  to verify whether the call parameters conform to the wsdlint description of the service   ii  if not  to try to rewrite them into the required structure and  iii  if this fails  to report an error. similarly  before an activexml service returns its answer  the module performs the same three steps on the returned data.
