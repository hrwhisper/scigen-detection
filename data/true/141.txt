　we present the implementation and experiments of a web switch that transforms a cluster-based web system  web cluster  with best-effort management policies into a system that gives guaranteed performance to different classes of users and applications.
keywords: distributed web systems  quality of service  performance evaluation  dispatching algorithms.
1 introduction
　the web is becoming a more mature and business-oriented media  so the need for differentiatedusers and services is much stronger. this differentiation is desired to accommodate heterogeneous application requirements and user expectations  and to permit differentiated pricing for content hosting or service providing.
　in this study  we work on the server side of the web and implement a prototype satisfying  quality of web services   qows  features that are inspired by the well known network qos principles: service classification  performance isolation  high resource utilization and request admission. in particular  we realize a layer-1 web switch which may implement several qows policies without having to modify the software of other components of the web cluster  as proposed by other papers in this area  1  1  1 .
1 prototype architecture
　we consider a multiple node architecture  namely web cluster  as a platform to introduce qows mechanisms. a web cluster refers to a web site publicized with one hostname that uses two or more server machines housed together in a single location to handle user requests. it has a front-end component  web switch  that acts as the network representative for the web site  a layer of web servers for static requests and a layer of back-end servers for dynamic requests. our prototype is a twoway web cluster  where the qows-enhanced web switch operates at the layer-1 of the osi protocol stack and implements access control and request dispatching among the server nodes.
　different proposals for introducing qos and qows require modifications in the software of the http server  1  1   or at the operating system level . we propose a qows-enhanced web switch which may implement several policies for service classification and request admission control  because it works at layer-1. the other two goals of qos  that is  performance isolation and high resource utilization are achieved by partitioning system resources among the classes of services and users. since each client request is served by one server  web and/or back-end   we can consider as resource unit of the web cluster an entire web or back-end server. other research results consider finer grain system resources  such as cpu  disk of a server node.
in this paper we consider three policies that implement qows mechanisms  major details can be found in .
switchadm works on service classification and resource admission. it does not admit requests when the current sum of the server loads in the web cluster exceeds a given threshold. once the request has been admitted to the system  it uses the weighted round robin  wrr  policy to select the target server.
staticpart adds to switchadm a policy to statically partition the servers in as many sets as the classes of services provided by the web cluster.
dynamicpart adds to staticpart a periodic evaluation of the system load. this algorithm can dynamically change the server partitions  if the previous choice does not allow to satisfy the service level agreement  sla  for the most important service/user classes.
　the implementation of the qows-enhanced web cluster is based on off-the-shelf hardware and software components. the nodes of the system are connected through a switched 1mbps fast-ethernet that does not represent the bottleneck for our experiments. the servers run on 1 dual processor pentiumiii-1mhz with 1mb of memory. all nodes of the cluster use a 1com 1b 1btx network interface  and an ibm ultra ata/1 disk with transfer rate of 1mbps and seek time of 1 msec. each node is equipped with linux operating system  kernel release 1.1   and apache 1.1 web server software.
　the layer-1 web switch is implemented on a dedicated machine having the same characteristics as the server node. it is implemented through the apache web server software by selecting the surrogate reverse proxy approach proposed in . the apache web server running on the web switch node is configured as a surrogate  reverse proxy  through the mod proxy and mod rewrite modules. the dispatching algorithms are implemented as c modules that are activated once at startup of the apache servers. because the web switch requires information about the server load  each server uses a collector c module that collects the number of active http connections  by differentiating requests for static and dynamic pages. every 1 seconds the manager c module running on the web switch gathers server load information through a socket communication mechanism.
　for the experiments described in the following section we consider two classes of users  a top class and normal class  and two classes of services  static and dynamic requests . the service level agreement  sla  for the top class users states that the  1-percentile of the latency time of static and dynamic requests must be less than seconds and seconds  respectively . the normal class requests receive best effort services.
　the sla targets that are suitable for the available web cluster architecture are evaluated through a methodology that cannot be reported here. we have evaluated the server and web switch capacity for various service classes. from these performance results  we have that the slas for the top class users can be set to and seconds for static and dynamic requests  respectively.
1 experimental results
　in this section we verify whether the proposed qows-aware policies and mechanisms satisfy all slas for different workload scenarios  and we compare the performance of the qows-enabled web cluster against a qows-blind system. as synthetic workload generator  we use a modified version of the webstone benchmark tool. the main differences concern the introduction of the http/1 protocol  and various modifications on client requests  e.g.  user session  user think-time  embedded objects per web page  file sizes and popularity  that are basically inspired to the surge model.
　figures 1 shows the 1-percentile of page latency time of top static requests. this figure shows that there is no particular problem to satisfy the sla for static requests. this is also due to the fact that the most popular static documents are served from the cache of the web server system rather than from the disk. all qows-aware policies are able to achieve the sla target set to   whereas a qows-blind dispatching policy  such as wrr  is unable to satisfy the sla when the system load augments. low percentages of normal requests must be rejected to guarantee slas  figure 1 : less than 1% for the staticpart policy  less than 1% and 1% for the dynamicpart and switchadm policies  respectively.
　figures 1 shows the 1-percentile of the page latency time for the top dynamic requests. now  the slas are much more critical for the qows-enabled web cluster. from this figure we observe that the qows-aware policies are able to satisfy the sla until the offered load is below 1 clients per second. after that point  only the dynamicpart algorithm is able to guarantee the sla until the web cluster receives 1 clients per second. these results are achieved at the price of high percentages of dropped requests coming from normal clients  going from 1% for the dynamicpart to 1% for the staticpart  figure 1 .
　if we consider all four figures reporting experimental results  we have that the dynamicpart policy outperforms all others in terms of lowest latency time  lowest percentage of dropped requests and  most important for a qos study  complete satisfaction of slas for all workload conditions.

figure 1. the 1-percentile of latency time for top static requests for qows-aware and qows-blind algorithms.figure 1. percentage of rejected normal static requests for qows-aware algorithms.
	1	1	1
clients per second
figure1. the 1-percentile of latency time for top dynamic requests .	1	1	1
clients per second
