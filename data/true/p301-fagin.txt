we propose a novel approach to performing efficient similarity search and classification in high dimensional data. in this framework  the database elements are vectors in a euclidean space. given a query vector in the same space  the goal is to find elements of the database that are similar to the query. in our approach  a small number of independent  voters  rank the database elements based on similarity to the query. these rankings are then combined by a highly efficient aggregation algorithm. our methodology leads both to techniques for computing approximate nearest neighbors and to a conceptually rich alternative to nearest neighbors.
　one instantiation of our methodology is as follows. each voter projects all the vectors  database elements and the query  on a random line  different for each voter   and ranks the database elements based on the proximity of the projections to the projection of the query. the aggregation rule picks the database element that has the best median rank. this combination has several appealing features. on the theoretical side  we prove that with high probability  it produces a result that is a -factor approximation to the euclidean nearest neighbor. on the practical side  it turns out to be extremely efficient  often exploring no more than 1% of the data to obtain very high-quality results. this method is also database-friendly  in that it accesses data primarily in a pre-defined order without random accesses  and  unlike other methods for approximate nearest neighbors  requires almost no extra storage. also  we extend our approach to deal with the nearest neighbors.
　we conduct two sets of experiments to evaluate the efficacy of our methods. our experiments include two scenarios where nearest neighbors are typically employed-similarity search and classification problems. in both cases  we study the performance of our methods with respect to several evaluation criteria  and conclude that they are uniformly excellent  both in terms of quality of results and in terms of efficiency.
1. introduction
　the nearest neighbor problem is ubiquitous in many applied areas of computer science. informally  the problem is: given a
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1  june 1  1  san diego  ca.
copyright 1 acm 1-1-x/1 ...$1.
database of points in some metric space  and a query in the same space  find the point  or the points  in closest to . some prominent applications of nearest neighbors include similarity search in information retrieval  pattern classification  data analysis  etc. the popularity of the nearest neighbor problem is due to the fact that it is often quite easy and natural to map the features of real-life objects into vectors in a metric space; questions like similarity and classification then become nearest neighbor problems. since the mapping of objects into feature vectors is often a heuristic step  in many applications it suffices to find a point in the database that is approximately the nearest neighbor. these problems lead to fascinating computational questions; there is an extensive literature on efficiently computing nearest and approximately nearest neighbors. for some recent theoretical work  see  1  1  1 ; for recent theoretical/applied work  see  1  1  1  1  1  1 .
　in this paper  we propose a novel method for similarity search  classification problems  and other nearest-neighbor-search-based applications. our method is built on two basic paradigms  rank aggregation  and instance optimal algorithms . our method satisfies the following two demanding  even conflicting  criteria: it is a robust generalization of nearest neighbors  and it admits algorithms that are extremely efficient and database-friendly.
　the starting point for our work is the following simple idea. suppose we are conducting nearest neighbor searches with a database of points in the -dimensional space  where is the underlying set-reals    etc.   and are given a query . we may consider each coordinate of the -dimensional space as a  voter   and the database points as  candidates  in an election process. voter   for   ranks all the candidates based on how close they are to the query in the -th coordinate. this gives us ranked lists of the candidates  and our goal is to synthesize from these a single ordering of the candidates; we are typically interested in the top few candidates in this aggregate ordering.
　the rank aggregation problem is precisely the problem of how to aggregate the ranked lists produced by the coordinates. the history of this problem goes back at least two centuries  but its mathematical understanding took place in the last sixty years  and the underlying computational problems are still within the purview of active research  1  1  1 . the most important mathematical questions on rank aggregation are concerned with identifying robust mechanisms for aggregation; particularly noteworthy achievements in this field are the works of young  and young and levenglick   who showed that a proposal of kemeny  leads to an aggregation mechanism that possesses many desirable properties. for example  it satisfies the condorcet criterion  which says that if there is a candidate such that for every other candidate   a
majority of the voters prefers to   then should be the winner of the election. aggregation mechanisms that satisfy the condorcet criterion and its natural extensions are considered to yield robust results that cannot be  spammed  by a few bad voters .
　kemeny's proposal is the following: given candidates and permutations of these candidates  produce the permutation that minimizes    where denotes the kendall tau distance  that is  the number of pairs of candidates on which the rankings and disagree  one of them ranks ahead of   while the other ranks ahead of  . we will call this a
　kendall-optimal aggregation. unfortunately  computing a kendalloptimal aggregation of even 1 lists is np-complete   so one has to resort to approximation algorithms and heuristics.
　let us now explicate the connection between nearest neighbors and rank aggregation. as a simple but powerful motivating example  note that if the underlying space is endowed with the hamming metric  then each voter really produces a partial order; given a query   the -th voter partitions the database into two sets and   ranking all of ahead of .  the notions of kendall tau distance and kendall-optimal aggregation still remain meaningful  since they are based on comparing two candidates at a time.  it is not hard to see that in this case  the kendall-optimal aggregation of the partial orders produced by the voters precisely sorts the points in the database in order of their  hamming  distance to the query vector . considering also the fact that the nearest neighbor problems in several interesting metrics can be reduced to the case of the hamming metric  1  1  1   we note that the rank aggregation viewpoint is  in general  at least as powerful as nearest neighbors.  we will provide even more compelling evidence shortly. 
　on the other hand  we have taken a problem  the nearest neighbor problem  that can be solved by a straightforward algorithm in time and recast it as an np-complete problem. even some of the good approximation algorithms and heuristics for the aggregation problem  e.g.  see   take time at least . however  the confluence of two key factors rescues us from this dilemma. firstly  we are interested only in the top few elements in the aggregate ordering  and not in the complete ordering of all database points. secondly  in the context of finding top winners in the aggregation  a heuristic based on median ranks turns out to admit an extremely efficient implementation. we turn to this next.
1 median rank aggregation
　while computing kendall-optimal aggregations is unlikely to admit efficient algorithms  a polynomial-time computable ordering that is optimal in the footrule sense  details in section 1  yields a factor-1 approximation to a kendall-optimal ordering. moreover  footrule-optimal aggregation has the following nice heuristic  which we will call median rank aggregation: sort all the points in the database based on the median of the ranks they receive from the voters. this is a reasonable heuristic  since if the median ranks are all distinct  then this procedure actually produces a footruleoptimal aggregation . thus  we have reduced our problem  heuristically  to that of finding the database point with the best median rank  or the points with the top few median ranks .
　instead of viewing median rank aggregation only as a heuristic approximation to a kendall-optimal aggregation  we consider it to be a natural rank aggregation approach in its own right. as we shall show in section 1.1  median rank aggregation gives an optimal solution for a notion of distance similar to the footrule distance. moreover  median rank aggregation has two desirable qualities  which we will now elaborate on.
　database friendliness and instance optimal algorithms. a strong argument for using median rank aggregation is its database friendliness. specifically  we would like to propose a solution to the  approximate  nearest neighbor problem that has properties desirable in a database system. ideally  one would like to avoid methods that involve complex data structures  large storage requirements  or that make a large number of random accesses. for example  these considerations immediately rule out the theoretically provably good methods  1  1  1 ; even methods from the recent database literature  1  1  1  are encumbered with one or more of these problems. by contrast  median rank aggregation uses sorting as the only pre-processing step1  needs virtually no additional storage  and performs virtually no random accesses. by avoiding random accesses  our method does not need indices that can locate the value of a coordinate of an element.
　we now discuss an especially efficient approach to median rank aggregation. let us pre-sort the database points along each of the coordinates. given a query   we can easily locate the value   for in the -th sorted list  and place two  cursors  in this location. once the cursors have been placed  two for each   by moving one cursor  up  and one cursor  down ' we can now produce a stream that produces the ranked list of the th voter  one element at a time  and on demand1. that is  we think of the voters as operating in the following online fashion: the first time the -th voter is called  it will return the database element closest to in coordinate   the second time it will return the second closest element in coordinate   and so on. thus  effectively  we have an online version of the aggregation problem to solve.
