integration systems typically support only a restricted set of queries over the schema they export. the reason is that the participating information sources contribute limited content and limited access methods. in prior work  these limited access methods have often been specified using a set of parameterized views  with the understanding that the integration system accepts only queries which have an equivalent rewriting using the views. these queries are called feasible. infeasible queries are rejected without an explanatory feedback. to help a developer  who is building an integration application  avoid a frustrating trial-and-error cycle  we introduce the clide query formulation interface  which extends the qbe-like query builder of microsoft's sql server with a coloring scheme that guides the user toward formulating feasible queries. we provide guarantees that the suggested query edit actions are complete  i.e. each feasible query can be built by following only suggestions   rapidly convergent  the suggestions are tuned to lead to the closest feasible completions of the query  and suitably summarized  at each interaction step  only a minimal number of actions needed to preserve completeness are suggested . we present the algorithms  implementation and performance evaluation showing that clide is a viable on-line tool.
1.	introduction
　many information sources support only a limited set of queries over their schema  as a result of privacy constraints  1  1  or a result of limited access methods  1  1 . in both privacy and mediationoriented systems  a source specifies a set of queries that can be answered directly using views over its schema. a mediator extends the set of directly supported queries with a set of indirectly supported ones by appropriately rewriting the latter so that they are answered by filtering and combining the results of directly supported queries. if a submitted query is not supported the user simply receives a rejection  being forced into a trial-and-error query development loop. we propose that the user should be guided toward feasible  i.e.  supported  queries and we developed the clide interactive system for this purpose.
the clide  client guide  system is a graphical query for-
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1  june 1  1  chicago  illinois  usa.
copyright 1 acm 1-1/1 ...$1.
mulation interface that mimics the visual paradigm of microsoft's query builder  incorporated in ms access and ms sql server . microsoft's query builder  in turn  is based on the queryby-example  qbe   paradigm. clide guides the user toward formulating feasible conjunctive queries and indicates any action that will lead toward a non-feasible conjunctive query. in particular  clide provides compactly-presented guidance in the form of a color scheme  which in every step of the query formulation indicates which possible actions should  should not or may be taken in order to reach a feasible query. a flag indicates whether the current query is feasible or not. if it is  colors indicate how to reach another feasible query  which will be a syntactic extension of the current one. as usual  an action is the inclusion of a table in the from clause  the formulation of a selection condition in the where clause or a projection of a column in the select clause.
　we illustrate the use of clide and the color-driven interaction using an example from service-oriented architectures.

 
figure 1: service-oriented architecture
service-oriented architectures information systems offer limited access to their data by publishing views  web services or apis. for example  amazon's e-commerce service  provides a set of web services that allow one to query its catalog and product data  and google's web apis  export web services for developers to issue search requests and receive results as structured data.
　service-oriented architectures  aggregate a collection of such services in order to provide more sophisticated web services and to support web applications. figure 1 shows a simple instance of an architecture where the mediator enables a computer shopping portal  such as cnet.com  to have integrated query access to two sources. we assume that dell and cisco export a set of web services on their computer and router catalogs  respectively. since we want to be able to issue  distributed  queries  we associate schemas with dell and cisco and model the web services as parameterized
computers cid  cpu  ram  price 
netcards cid  rate  standard  interface  dell schema combycpu cpu  ★  computer *
select distinct com.*
from computers com where com.cpu=cpu v1 comnetbycpurate cpu  rate  ★  computer  netcard *
select distinct com.*  net.*
from computers com  netcards net
where com.cid=net.cid and com.cpu=cpu
and net.rate=rate v1 routers rate  standard  price  type  cisco schema routerswired   ★  router *
select distinct rou.*
from routers rou
where rou.type='wired' v1 routerswireless   ★  routers *
select distinct rou.*
from routers rou
where rou.type='wireless' v1  s1.computers.cid  s1.netcards.cid 	 column associations 
 s1.netcards.rate  s1.routers.rate   s1.netcards.standard  s1.routers.standard 
figure 1: source schemas and web services
views over those schemas 1. figure 1 illustrates part of their respective schema and the signatures of four web services they export.
　the dell schema describes computers that are characterized by their cid  cpu model  e.g.  p1   ram installed and price  and have a set of network cards installed. each network card has the cid of the computer it is installed in  accommodates a specific data rate  e.g.  1mbps   implements a standards  e.g.  ieee 1g  and communicates with a computer via a particular interface  e.g.  usb .the web service combycpu returns the computers of a given cpu.  we assume there is a computer type.  the service comnetbycpurate provides computers of a given cpu that have installed network cards of a given data rate. the cisco source describes routers that also accommodate a specific data rate  implement standards  have their own price and are of a particular type. the routerswired and routerswireless services return routers that are of either wired or wireless type respectively.
　in figure 1  a user builds the computer shopping portal by formulating queries against the source schemas  and deploys a mediator in order to execute queries against the exported web services during run-time. the mediator can answer the query  return all p1 computers with a 1mbps network card and the compatible wireless routers  by combining the answers of web service calls compnetbycpurate and routerswired. however  it cannot answer the query  return all computers with 1gb of ram . the reader is pointed to chapter 1 of  for similar examples. clide appropriately guides the user toward the formulation of feasible queries by employing the following coloring scheme:
  red color indicates actions that lead to unsupported queries  regardless of what is included next. for example  conditioning the type column of routers with a constant other than 'wired' and 'wireless' leads to unsupported queries.

1
 indeed  it is often the case that web services are based on parameterized queries over databases. however  for the purposes of mediation it is not necessary to assume that the dell and cisco schemas are known.
  yellow color indicates actions that are necessary for the formulation of a feasible query. for example  conditioning the cpu of computers will be yellow since all queries that the mediator can answer and involve the computers table require a given cpu.
  blue color indicates a set of actions where at least one of them is required to be taken in order to reach one of the next feasible queries. notice that one can choose among many blue options. for example  after the cpu of computers has been conditioned and a feasible query has been reached  one should condition either the ram or the price column  among other choices  in order to reach the next feasible query.
  white color indicates selection conditions  tables and projections whose participation in the query is optional.
　clideis based on a modular architecture consisting of the frontend and a back-end that enables the front-end's behavior by deciding the color of each action. the above coloring scheme is implemented by clide's front-end and is independent of the specification that has been used to describe the set of supported queries. multiple back-ends are possible  depending on the nature of the specification of the supported query set. for example  one could have a back-end for the p1p privacy-related supported query set specification of  or the specification of  that is related to queries supported as a result of wrapping web forms.
parameterized views one of the most common and  at the same time  most challenging back-ends relates to the case where the set of directly supported queries are described using parameterized views  a technique that has been used to describe content and access methods in the widely used global-as-view  gav  integration architectures   and also recently to describe privacy constraints in . going back to figure 1  the parameterized view v1 corresponds to the web service combycpu. notice that the parameterized view not only indicates the input  cpu  and output  computer  of the service  but also indicates how the input and output are semantically related with respect to the underlying database. typically the sources considered by the mediator can be too many to individually browse in order to formulate a feasible query. deciding whether a given query is feasible or not is a query rewriting problem: the mediator is given a query q over a database d and a set of parameterized views v1 ... vn and it searches for a plan  if any  that combines the views and computes q d . the plan is typically in the form of a query that runs on the views and often incorporates primitives that indicate the passing of information across sources and web services.
　several rewriting algorithms have been published; the reader is referred to the survey . however  these algorithms are not sufficient for clide's back-end since whenever there is no plan they only declare that the query cannot be answered. some algorithms return overestimate or underestimate approximations of the query result  thus addressing a different goal than the one in our setting where the developer needs to know the exact queries that can be issued and program accordingly. nevertheless  there are important technical connections between those algorithms and our work that are discussed in later sections.
1	contributions
formal guarantees on the interaction any good interface that guides the user toward some action must be comprehensive  complete  and  at the same time  avoid overloading the user with information at every step  1  1 . clide achieves both goals since it satisfies the following guarantees at every step of the interaction:
1. completeness: every feasible query can be built by following suggested actions only.
1. minimality: the minimal set of actions that preserves completeness is suggested.
1. rapid convergence: the shortest sequence of actions from a query to any feasible query consists of suggested actions.
　interaction sessions between the user and the clide front-end are formalized using an interaction graph  which models the queries as nodes and the actions that the user performs as edges. consequently  the color of each action is formally defined as a property of the set of paths that include the action and lead to feasible queries. then the above guarantees are formally expressed as graph properties.
back-end algorithms the challenge facing the clide back-end is that the coloring properties cannot be trivially turned into an algorithm since they require the enumeration of an infinite number of feasible queries. note that the number of queries is infinite for two reasons. first  there is an infinite number of constants that may be used. we tackle this problem by considering parameterized queries  similar to jdbc's prepared statements  where each one stands for infinitely many queries. still  the number of parameterized queries is infinite  because the size of the from clause is unlimited  which then leads to unlimited size select and where clauses.
　we describe a set of algorithms that find a finite set of closest feasible queries  related to the current query  and determine the coloring by inspecting it. for our purpose  we leverage prior algorithms and implementations for finding exact and maximally-contained rewritings  1  1  1 . however  we needed to significantly optimize and extend current implementations in order to achieve online performance and to ensure that the produced maximally-contained queries are syntactic extensions of the current query  hence enabling the color algorithm. we provide a set of experiments that illustrate the class of queries and views clide can handle  while maintaining on-line response.
clide demo we implemented the clide front-end and the back-end algorithms which are available as an on-line demonstration at http://www.clide.info.
paper outline section 1 provides definitions and notation conventions. section 1 discusses query building interfaces  focusing on clide-related issues  and introduces the interaction graph  which allows us to formally define their behavior. section 1 discusses the aspects of clide that pertain to interaction in the presence of a limited set of feasible queries. section 1 describes the algorithms of the clide back-end. section 1 describes the implementation and optimizations  which are experimentally evaluated in section 1. section 1 presents related work and discusses clide's applicability to other settings. section 1 concludes the paper.
1.	definitions and notations
　the clide front-end formulates queries from the set of conjunctive sql queries with equality predicates cq= under set semantics. the from clause consists of table atoms r r  where r is some table name and r an alias. the select clause consists of the sql keyword distinct and projection atoms r.x  where x is a column of r. the where clause is a conjunction of selection atoms and join atoms. constant selection atoms are of the form r.x=constant  where r is some alias and x some column  while parameterized selection atoms are of the form r.x=parameter. obviously  at most one selection atom for each alias-column pair can appear in the where clause. join atoms are of the form r.x=s.y. we define the empty query to have no table  join  selection or projection atom.
　column associations identify pairs of columns  within a source or across sources  whose join is meaningful. figure 1 illustrates the association of the cid columns of computers and netcards and the rate and standard columns of netcards and routers1. the user can configure clide to suggest either arbitrary joins or only joins between columns that are associated  in order to reduce the number of suggestions displayed to the user. in the latter case  the user still has the option to formulate joins between non-associated columns  but the clide front-end will not suggest them. for the rest of the presentation  we assume the user has configured clide to suggest joins between associated columns only. we denote this class of queries with cq=ca.
　the views that clide takes as input are from the set of parameterized conjunctive sql queries cq=p  where parameterized selection atoms of the form r.x=parameter appear in the where clause. we assume that all joins are between associated columns. cq=ca is a subset of cq=p.
　two queries q1 and q1 are syntactically isomorphic  denoted by q1 =゛ q1  if they are identical modulo table alias renaming. syntactic isomorphism is important since the users of query writing tools typically do not have control  or do not care to control  the exact table alias names.
　we denote the set of feasible queries by fq   cq=ca. as in   we define the feasible queries given a set of views v = v1 ... vk （ cq=p over a fixed schema d  to be the set of queries qf1 ... qfm （ cq=ca over d that have an equivalent cq= rewriting using v. in the absence of parameters a rewriting is simply a query that refers exclusively to the views. in the presence of parameters we need to also ensure that there is a viable order of passing parameter bindings across the views of the rewriting  1  1 . we capture this requirement as follows: first associate to each view a schema that includes both the columns that the view returns and the columns that participate in parameterized selections  even if they are not returned . then we associate with each view schema a binding pattern that annotates every column that participates in a parameterized selections as bound  which is denoted by a 'b' superscript  and every other column as free  denoted by an 'f' superscript. for example  we associate the following schema and binding pattern to v1 in figure 1:
 pricef 
a valid rewriting is a query that refers to the views only and there is an order v1 ... vn of the used views such that if a column x is bound in vi then either there is a selection atom vi.x=constant or a join atom vi.x=vj.y where j   i.
1.	query building interfaces
　the clide front-end is a qbe-like  graphical interface. it adopts microsoft's query builder interface  as the basis for the interactive query formulation  since users are very familiar with it. figure 1a shows a snapshot of microsoft's query builder  where the user formulates a query over the schemas of figure 1. the top pane displays the join of the computers table with the netcards table on cid and the projection of the ram and price columns of computers and of the interface column of netcards. the middle pane shows selections that set cpu equal to 'p1' and rate equal to '1mbps'  and the bottom pane displays the corresponding sql expression. the user can add to the top pane tables from the

1
 column associations can be explicitly declared by the mediator owner. they can also be derived from the pairs of type-compatible columns  from foreign-key constraints  the join atoms in the views  or any of the recently proposed schema matching techniques .

 b  clide's front-end expressing the query of figure 1a
	figure 1: qbe-like query building interfaces	 
list shown on the left. the user can also formulate joins  like the one on cid.
　figure 1b provides a snapshot of clide'sfront-end for the query of figure 1a. apart from the feasibility flag and the coloring  the correspondence with microsoft's query builder is straightforward: clide displays a table box for each table alias in the from clause. selections on columns are displayed in selection boxes. columns are projected using check boxes  called projection boxes. joins are displayed as solid lines  called join lines  connecting the respective column names. the list of available tables is shown in a separate pane. also shown is the sql statement that the interface graphically represents. the  last step  and  next step  buttons allow the user to navigate into the history of queries formulated during the interaction.
　the user builds cq=ca queries with the following visual actions:
1. table action: drag a table name from the table list and drop it in the main pane. the interface draws a new table box with a fresh table alias and adds a table atom to the from clause of the sql statement.
1. selection action: typing a constant in a selection box results to adding a selection atom to the where clause.
1. join action: dragging a column name and dropping it on another one results to a join line connecting the two column names and a new join atom in the where clause.
1. projection action: checking a projection box adds a projection atom to the select clause.
1. clide interaction in the presenceoflimitedaccessmethods
　when not all cq=ca queries against a database schema are feasible  clide guides the user toward formulating feasible queries by coloring the possible next actions in a way that indicates what has to be done  what may and what cannot be done. table actions are suggested by coloring the background of table names in the table list. selections and projections are suggested by coloring the background of their boxes. joins are suggested by coloring join lines.
　we illustrate the color scheme using the interaction session of figure 1  which refers to the running example of figure 1. the user wants to formulate a query that returns computers that meet various selection conditions  including conditions about network cards and routers - as long as those conditions are supported. figure 1 shows snapshots of the interaction session  where clide's color scheme suggests  at each interaction step  which actions lead to a feasible query.
required and optional actions consider the query that the user has formulated in snapshot 1. the interface indicates that this query is infeasible  see flag at top right  and that every feasible query that extends it must have a selection on cpu. the latter indication is given by coloring yellow  light gray on a b/w printout  the cpu selection box. the rest of the selection boxes and projection boxes are white suggesting that these actions are optional  i.e.  feasible queries can be formulated with or without these actions being performed.
　so the user performs the yellow selection on cpu by typing a constant in the selection box. this leads to the feasible query of snapshot 1. this query is feasible since the mediator can run view v1 with the parameter instantiated to 'p1' and then project out the cid and cpu columns.
required choice among multiple actions the user may terminate the interaction session and incorporate the query of snapshot 1 in her application or may continue to extend the query. the interface indicates that  in order to reach a next feasible query  at least one of the netcards  routers or  an additional  computers tables has to be included in the query  among other options. the indication is provided by coloring the corresponding names in the table listblue  medium gray . each given blue atom  say netcards  does not appear in all feasible queries that extend the current query. if it did appear in all  then it would be yellow  i.e.  required . non-obvious feasible queries snapshot 1 presents a complex case  where the interface's color scheme informs the user about non-obvious feasible queries. after the user introduces a netcards table  the interface suggests that one of the following extensions to the query is required: the join line between the cid's of computers and netcards is suggested since it leads to the formulation of view v1. it is blue since the user has more options: she can introduce a second copy of computers  say com1  which will lead toward the feasible query that joins networks with com1  selects on rate and takes a cartesian product with com1. if cartesian product queries are of no interest to the user  she can set an option to have clide ignore them. in such case the cid join would be a required  yellow  extension. for the remainder of the example  we assume that this option is set.
　the user has another pair of options at snapshot 1. she can perform the blue rate selection  which leads to the formulation of view v1. alternatively  she may introduce a routers table and join the rate columns of netcards and routers  thus

figure 1: snapshots of an interaction session
instantiating the rate parameter of v1 with constants provided by another table.
selection options in snapshot 1  the user has performed the sug- gested join and introduced a routers table. now the routers.type column needs to be bounded and the interface presents to the user a drop-down list that explains which constants may be chosen. she can either choose 'wired' or 'wireless'. the symbol * denotes any other constant and is colored red  dark gray  to indicate that no feasible query can be formulated if she chooses this option. note that the options of a drop-down list can have different colors. if there were only one constant that she could choose  then this option would be yellow. in the special case where any constant can be chosen  then no drop-down list is shown  as in the case of the cpu selection box in snapshot 1.
　the front-end can also be configured to hide all red actions  including columns with red selection and projection boxes. note that a red selection box implies a red projection box and vice versa. so the front-end can remove the column from the corresponding table box altogether.
　in the next steps  the user performs the suggested join  chooses the 'wireless' constant and checks several projection boxes. snapshot 1 shows the new query  which is feasible. the mediator plan that implements this query first accesses view v1  then for each rate returned accesses view v1 with its parameters instantiated to 'p1' and the given rate  and finally performs the necessary projections.
　the clide front-end displays only yellow and blue join lines. red and white join lines are typically too many and are not displayed. if the user wants to perform a join other than the ones suggested  she has to follow a trial-and-error procedure.
　note that unchecked projection boxes can be either blue  white or red. a projection box cannot be yellow  because if there is a feasible query that has the corresponding projection atom in the select clause  then the query formulated by removing this atom is also feasible.
　finally  if the user performs a red action  then all boxes  lines and items in the table list are colored red  indicating that the user has reached a dead end  i.e.  no feasible query can be formulated by performing more actions and it is necessary to backtrack  i.e.  undo actions.
1	specification of clide's color scheme
　interaction sessions between the user and the clide front-end are formalized by an interaction graph. the nodes of the interaction graph correspond to cq=ca queries and the edges to actions.
　definition 1.  interactiongraph  given a database schema d and a set of cq=p views v over d  an interaction graph is a rooted dag gi =  n s e  with labeled nodes n and labeled edges e such that:
  for every query q （ cq=ca over d there is exactly one node n （ n whose label q n  is syntactically isomorphic to q. we call n feasible if q n  is feasible.
  s is the root node and is labeled with the empty query.
  every edge is labeled with an action a which yields a query that is isomorphic to when applied to q n . a is either a table  a projection  a join  a specific selection of the form r.x=constant  or a generic selection of the form r.x=*. here * denotes any constant other than the ones that appear in specific selections and label edges originating from n.

　figure 1 shows part of an interaction graph for the schemas in figure 1  where nodes n1 to n1 correspond to the queries formulated in snapshots 1 to 1 of figure 1. notice that there are multiple interaction graphs that correspond to a given schema  since each node n can be relabeled with any of the queries that are syntactically isomorphic to q n   i.e.  with any query that uses other alias names. clide considers a single interaction graph by controlling the generation of aliases. by convention  the generated aliases follow the lexical pattern ti where t is the first three letters from the name of the table  for illustration purposes  and i is a number that is sequentially produced.
　figure 1 indicates feasible queries by green  shaded  nodes. the root s is indicated by a hollow node. the outgoing edges of a node n capture all possible actions that the user can perform on q n . these are the actions that the front-end colors and they are finitely many. even though there are infinitely many constants that can potentially generate infinitely many selections for a given column  they are aggregated by the * symbol. in figure 1  for example  the * in the selection com1.cpu=* labeling an outgoing edge of n1 aggregates all possible constants. the * in the selection rou1.type=* labeling an outgoing edge of n1 denotes all constants except 'wired' and 'wireless'  because corresponding selections label adjacent edges.
　for a query q n   the coloring rules are formally expressed as a coloring of the actions labeling outgoing edges of node n.
　definition 1.  colors  given an interaction graph gi =  n s e   a node n （ n and an outgoing edge e n ★a m   the action a is colored:
  yellow  required  if every path pi from n to a feasible node nf contains an edge labeled with a.
  blue  at least one required  if  i  a is not yellow   ii  at least one path pi from n to a feasible node nf contains an edge labeled with a  and  iii  there is no path from n to nf that contains a feasible node  excluding n and nf.
  red  forbidden  if there is no path from n to a feasible node that contains an edge labeled with a.
  white  optional  if not colored otherwise.

we say that actions colored yellow or blue are called suggested. the same action may have different color at various points in the interaction. for example  table action netcards net1 is white when it labels an outgoing edge of n1 and blue when it labels an outgoing edge of n1.
　clide assigns colors according to definition 1 and features the following characteristics of desirable behavior.
1. completeness of suggestions every feasible query can be formulated by starting from the empty query and at every interaction step picking only among blue and yellow actions.
1. minimality of suggestions at every step  only a minimal number of actions  which are needed to preserve completeness  are suggested as required. equivalently  for each blue or yellow action a  there is at least one feasible query toward which no progress can be made without picking a.
1. rapid convergence by following suggestions assume that the user is at node n of the interaction graph and consequently follows a path p consisting of yellow and blue edges until she reaches feasible query . it is guaranteed that there is no path p that is shorter than p and also leads from.
1.	the clide back-end
　the clide back-end is invoked every time the interaction arrives at a node n in the interaction graph. it takes as input the query q n   the schemas and the views exported by the sources  and the set of column associations. the back-end partitions the set of possible actions  which label outgoing edges of n  into sets of blue  red  white and yellow suggested actions. it also decides if q n  is feasible or not.
　the first challenge in determining the partition is that the color definitions make statements about all possible extensions of the current query  i.e.  all feasible nodes reachable from n. these correspond to an infinite set of infinitely long paths in the interaction graph. hence  the color definitions cannot be trivially translated into an algorithm.
　we show that at each interaction step  it is sufficient to consider only a representative subgraph of the interaction graph to color the possible actions either blue or yellow. this subgraph consists of n  the feasible nodes that are closest to n  and the paths connecting n to these feasible nodes. the closest feasible nodes are labeled with queries in fqc n  which is defined below.
　definition 1.  closest feasible queries fqc  given an interaction graph gi =  n s e  and a node n （ n  the set of closest feasible queries fqc n  are the ones that label feasible nodes nf reachable from n such that there is no path p from n to nf that contains a feasible node  excluding the endpoints of
　section 1 presents the computation of fqc n  when parameterized selection atoms do not appear in the views. we show that fqc n  is finite and present optimizations for computing it  which proved crucial to clide's usability. if parameterized selection atoms appear in the views  then fqc n  is infinite. section 1 shows that clide's back-end faces this additional challenge without compromising any of the formal guarantees by computing a finite representative set of seed queries sq n .
　the second challenge  section 1  that the back-end faces is to efficiently color the possible actions given the set of closest feasible queries. even though coloring an action yellow or blue is straightforward and inexpensive  coloring the remaining actions red

	figure 1: clide architecture	 
or white using a brute force algorithm leads to significant performance overhead.
　figure 1 shows the architecture of the clide system implementation. currently  the system parses the schemas  view definitions and column associations from corresponding text files. the closest feasible queries algorithm computes the set fqc n  and implements the algorithm of section 1. when parameterized selection atoms do not appear in the views  the color algorithm component inputs the set fqc n  and implements the algorithm of section 1. when parameterized selection atoms appear in the views  the color algorithm component inputs a set of seed queries sq n  produced by the parameters algorithm component described in section 1.
1	closest feasible queries algorithm
　the search for closest feasible queries faces an infinite search space  namely all possible extensions of the current query. we limit this space to a finite one  corresponding to nodes in the interaction graph that are within a bounded distance from n. then  we present an efficient method for enumerating fqc n  without exploring the whole search space.
maximally-contained feasible queries intuitively  as the user syntactically extends the current query with new tables  selections and joins  she creates queries which are contained in the initial one. it is therefore a natural starting point to search for the closest feasible queries among the contained and feasible ones. we can further focus on the maximally-contained  and feasible queries since they are the least constraining  semantically  and hence they have the least number of additional tables  selections and joins. as in   the set of maximally-contained feasible queries is formally defined as the set of queries such that
1. for each maximally-contained query q1  q1 is feasible and contained in  
1. for each maximally-contained query q1 and any feasible query contains q1  then is equivalent to q1  and
1. for each feasible query there exists a maximallycontained query q1 such that.
　among the maximally-contained feasible queries  we focus on the ones which are minimal syntactic extensions of q n   in the sense that dropping any table  selection or join compromises feasibility or containment in q n  or the property of syntactically extending q n . we denote this set as fqme n . section 1 describes how we extended one of the several maximally-contained rewriting algorithms proposed in the literature  to obtain fqme n .
　fqme n  is known to be finite if we restrict q n  and the views to conjunctive queries with constant selection atoms .
　lemma 1. all minimal feasible extensions of q n  which are maximally-contained are also closest feasible queries  fqme n   
fqc n  .	
　however  there are closest feasible queries that are not in fqme n   as the next example shows  and we will have to find them.
　example 1. assume that views v1 and v1 of figure 1 are replaced by the following views  respectively  which contain constant selections only.
select distinct com.*	
from computers com where com.cpu='p1'
select distinct com.*  net.*	
from computers com  network net
where com.cid=net.cid and com.cpu='p1' and net.rate='1mbps'
　if the current query is q n1  in figure 1  snapshot 1 in figure 1   then the only query in fqme n1  is q n1  given below.
select distinct com1.ram  com1.price	q n1 
from computers com1  computers com1  netcards net1
where com1.cid = net1.cid and com1.cpu='p1' and com1.cpu='p1' and net1.rate='1mbps'
　note that q n1  is also a closest feasible query to q n1   but it is not in fqme n1  since it is contained in q n1 .
select distinct com1.ram  com1.price	q n1 
from computers com1  netcards net1
where com1.cid = net1.cid and com1.cpu='p1' and net1.rate='1mbps'
　intuitively  one can extend q n1  with joins until the com1 alias  collapses  into com1  leading to a closer query  reachable from q n1  and clearly contained in q n1  due to the added joins. 
　even though fqme n  does not give us the set of closest feasible queries  we can use it to bound the search space for fqc n . theorem 1 below states that all queries in fqc n  correspond to nodes located within a bounded distance from n.
　theorem 1. given a node n in the interaction graph and the set fqme n   if pl is the longest path from n to a node labeled with a query in fqme n   then all nodes labeled with queries in fqc n  are reachable from n via a path p  where
　theorem 1 enables a brute force algorithm for computing fqc n :  i  compute fqme n    ii  compute the bounded distance |pl| as the length of the longest path from n to some query in fqme n    iii  enumerate the set of queries b n |pl|  reachable from q n  by systematically applying up to |pl| actions in all possible ways  and  iv  return all feasible queries from b n |pl| .
　this algorithm computes fqc n   but is highly inefficient. in the worst case  it enumerates all paths of length |pl|. the following observations allow us to prune this search dramatically  by starting from fqme n .
alias collapse rule we can compute fqc n  fqme n  starting from the queries in fqme n  and rewriting them using the alias collapse rule  which rewrites a query q into a query q as follows: pick a pair of table atoms sharing the same relation name  say r r1  r r1  and rename r1 with r1 in q  to obtain q.
　example 1. one can obtain the closest feasible query q n1  from query q n1  by collapsing the aliases com1 and com1. 
　notice that indiscriminate application of the collapse rule can lead to unsatisfiable queries. to see this  assume that q contains the selection conditions r1.x='1' and r1.x='1'. after collapsing r1 and r1  q contains the inconsistent selection conditions r1.x='1' and r1.x='1'. we apply the alias collapse rule only if they lead to satisfiable queries.
　lemma 1. for any q1 （ fqc n  fqme n   there exists q1 （ fqme n  such that q1 is obtained from q1 by repeatedly applying the alias collapse rule. 
　lemmas 1 and 1 lead to the following algorithm for computing fqc n .
algorithm quickfqc input: node n
output: fqc n 
begin
compute m := fqme n  using an algorithm for finding maximally-contained rewritings  extended to produce minimal syntactic extensions of q n 
letfor each// computeac :=qmfthe empty setq（cm ndo   f qme nr1  inr1acof some relation in:	qm do
for each pair of distinct aliases
let q := collapse r1 and r1 in qm
　　　ac := collapsetofeasible q ac  return m “ ac
end
procedure collapsetofeasible
input: query q  query set ac
output:all feasible queries obtainable from q by collapsing aliases begin
if q is unsatisfiable return the empty set  
if acq is feasible and not contained in any:= ac“{q}	r1 r1 of some relation inqi （ ac	q do for each pair of distinct aliases
	let	:= collapse r1 and r1 in q
   ac := collapsetofeasible return ac end
　theorem 1. quickfqc computes fqc n .	 1	color algorithm
　after computing the set of closest feasible queries fqc n   clide decides if the current query is feasible or not  and then colors all possible actions that the user can perform next. the current query is feasible if it is a closest feasible one  i.e.  q n  （ fqc n   and infeasible otherwise. we first present the algorithm for finding the yellow and blue actions when the current query is infeasible. we deal with the white and red actions  as well as the feasible case  next.
blue and yellow instead of working with the infinite interaction graph  we can restrict our attention to the finite close subgraph consisting of n  all closest feasible nodes labeled with the closest feasible queries in fqc n  and the paths between them. then we have:
lemma 1. for an infeasible current query q n   and for every
action a applicable to q n   a is colored yellow  blue  with respect to the interaction graph if and only if a is colored yellow  blue  with respect to the close subgraph of n.  at this point  it is easy and more efficient to color the actions without actually materializing the close subgraph. we color a join a yellow if it appears in all closest feasible queries  and blue if it appears in some. in the case of a table action t  we color it yellow  resp. blue  if in all  resp. some  closest feasible queries there exists a table atom t tj  such that t ti and t tj do not necessarily refer to the same alias  and t tj does not appear in the current query.
　specific selections  i.e.  selections of the form r.x=constant  are colored either yellow or blue the same way joins are colored. the front-end displays these actions in the corresponding selection box as options of a drop-down list. generic selections of the form r.x=* and projections cannot be colored blue or yellow when the current query is infeasible  because for each feasible query they participate in  there is another feasible query that can be formulated without performing them. conversely  when the current query is infeasible  performing a projection or a generic selection that does not appear in the views will not yield a feasible query1. white and red any remaining actions are either white or red. for each such action a  a brute force approach would add a to the current query  thus yielding query   and then test if f is empty. if so  a is colored red  otherwise white. this approach  although simple  requires the non-emptiness test of f  which is an expensive operation  as the experiments of section 1 demonstrate. hence  we need to devise more efficient techniques for coloring red and white actions.
　in the case of table actions we color red the ones that are not used in any view  and white the remaining ones  since a feasible query qf can lead to another feasible query that takes the cartesian product of qf and the view that contains the table in question.
　for the case of projections and selections  we attach a maximum projection list to every closest feasible query qf （ fqc n . a maximum projection list consists of all projections that can be added to qf  in addition to the ones already in the current query  without compromising feasibility. for example  if we add all possible projections to q n1  of example 1  while preserving feasibility  then we formulate the following query:
select distinct	
com1.cid  com1.cpu  com1.ram  com1.price
com1.cid  com1.cpu  com1.ram  com1.price
net1.cid  net1.rate  net1.standard  net1.interface
from computers com1  computers com1  netcards net1
where com1.cid = net1.cid and com1.cpu='p1' and com1.cpu='p1' and net1.rate='1mbps'
　hence  the maximum projection list of q n1  consists of all projections in except com1.ram and com1.price which appear in q n1 . in section 1 we show how we extended a maximallycontained rewriting algorithm to generate these lists in linear time.
　once we compute the maximum projection lists  we color a projection red if it does not appear in any list. generic selections are colored red if the projection r.x is red. these selections are also shown as options of the corresponding drop-down lists. in the special case where no specific selections exist  then no drop-down list is displayed and the selection box is colored according to the color of the generic selection.
　any remaining actions are colored white. note that specific selections can never be colored white or red. the clide front-end does not display white and red joins  so they are not a consideration. feasible current query if the current query is feasible  we use the same algorithm  but we color all non-red actions blue  as each one leads to a new feasible query  not obtainable via other actions.

1
 note that generic selections can be colored yellow or blue when parameterized selections appear in the views. please see section 1 for details.
1	parameters
　when parameterized selection atoms appear in the views  the algorithms in sections 1 and 1 need to be extended  because the set of closest feasible queries becomes infinite. the following example illustrates this point.
　example 1. assume the following employees and managers source schema. the exported parameterized view v1 returns the mid of an employee's manager  given the employee's eid. v1 returns the salary of a manager  given the manager's mid. note that the source schema is recursive  i.e.  an employee has a manager  but a manager is also an employee  who has a manager. one of the column associations we consider witnesses this recursion.
empls eid  mid 
mngrs mid  salary  schema emplsmngrs eid  ★  employee *
select distinct e1.*
from empls e1
where e1.eid=eid v1 mngrssalary mid  ★  manager *
select distinct m1.*
from mngrs m1
where m1.mid=mid v1  s1.empls.eid  s1.empls.mid 
 s1.empls.mid  s1.mngrs.mid  column associations 　the user wants to find out the salaries of an employee's managers and has currently formulated query q1:
select distinct m1.salary	q1
from mnrgs m1  empls e1 where m1.mid=e1.mid
　at this point  e1.eid has to be provided to reach a feasible query. therefore  the front-end makes two suggestions:  i  perform a selection on e1.eid  or  ii  introduce a second empls e1 table  so that parameters can be passed from e1.mid to e1.eid  based on the first column association . the suggested actions are both blue.
　option  i  will formulate the feasible query q1f which returns the salaries of e1.eid employee's immediate managers.
select distinct m1.salary	q1f
from mnrgs m1  empls e1
where m1.mid=e1.mid
and e1.eid=''a1''
　option  ii  leads toward a query that returns the salaries of managers that are two levels above an employee. more specifically  if the user introduces table a second table empls e1  then the frontend colors the join e1.eid=e1.mid yellow  which formulates q1:
select distinct m1.salary	q1
from mnrgs m1  empls e1  empls e1
where m1.mid=e1.mid and e1.eid=e1.mid
　for q1  the front-end makes the same kind of suggestions to the user as for q1  since e1.eid has to be provided now. a selection on e1.eid formulates the feasible query q1f which returns the salaries of managers that are two levels above that employee.
select distinct m1.salary	q1f
from mnrgs m1  empls e1  empls e1
where m1.mid=e1.mid and e1.eid=e1.mid
and e1.eid=''a1''
　it becomes evident that the user can build chains of empls aliases of an unbounded length  where each alias joins its eid with the next one's mid  before performing a constant selection on the eid of the last empls alias. these queries are infinitely many and are all closest feasible. for example  q1f and q1f are two such queries  and there is no sequence of actions that applied on q1f formulate q1f.	
　searching for closest feasible queries starting from the maximallycontained ones becomes problematic as it is known that the latter set is infinite in the presence of binding patterns . moreover  the coloring of actions cannot be done by enumerating all closest feasible queries.
　instead  clide identifies a finite set of parameterized seed queries sq n   where q n  is the current query. these are not necessarily feasible  but have the property that each path toward a closest feasible query must pass through some seed query first. in example 1  q1f is a feasible seed query of q1  while q1 is an infeasible one  which however must be constructed on the way to q1f. the algorithm suggests to the user a finite set of actions leading from q n  toward the seed queries sq n . this can be done by simply calling the color algorithm of section 1 on sq n  instead of fqc n . this approach does not compromise the guarantees of completeness  minimality of suggestions and rapid convergence.
　it is a priori non-obvious that the finite set sq n  even exists. however  it turns out that this is indeed the case  and moreover that sq n  can be computed as follows. start by ignoring the binding patterns of the views and computing the maximally-contained rewritings of q n  in terms of the views. under the original binding patterns  not all obtained rewritings are valid  and the values of their parameters must be provided. in each such rewriting  parameter values may be provided by  i  selections with a constant  or  ii  via a parameter-passing join with a view alias from within the rewriting or  iii  via a parameter-passing join with a new view alias. the considered parameter-passing joins must be compatible with the column associations. notice that there are only finitely many considered selections and parameter-passing joins. we obtain sq n  by systematically extending the rewritings according to possibilities  i    ii  and  iii   and unfolding the view definitions in all extended rewritings.
1.	implementation
　the current implementation of clide consists of the components that compute the closest feasible queries and color the actions  shown in figure 1. the component that handles parameterized selections in the views is under development.
　clideuses minicon  as the core of its maximally-contained rewriting component. even though an initial implementation was provided to us  we had to significantly optimize and extend it in order to enable clide's color algorithm and achieve on-line performance. figure 1 illustrates the anatomy of the maximally-contained rewriting component from figure 1.
views expansion the first challenge we faced was that minicon does not produce maximally-contained rewritings that are syntactic extensions of the current one. minicon initially produces a set of rewritings expressed using the views. once these rewritings are expanded so that they are expressed in terms of the source schemas  they are not syntactic extensions of the current query  because fresh aliases are introduced. for example  if the current query is q n1   snapshot 1 in figure 1   minicon produces the following rewriting query qr that combines:
select distinct.ram 	.price	qr
from

figure 1: minicon optimizations and extensions
　after expanding the views of qr  we obtain the following query qre  which is expressed in terms of the source schemas.
select distinct coma.ram  coma.price	qre
from computers coma  computers comb  netcards net
where comb.cid = net.cid and coma.cpu='p1' and comb.cpu='p1' and net.rate='1mbps'
　query qre is syntactically isomorphic to the closest feasible query q n1   but it is not a syntactic extension of q n1   since q n1  contains a table computers com1  while qre contains the tables computers coma and computers comb. it is not straightforward if com1 corresponds to coma or comb.
　we could find the correspondences between the tables of q n1  and the tables of qre by computing the containment mapping  from q n1  into qre. the containment mapping considers all atoms of the two queries in order to find the correct correspondences. for example  com1 of q n1  cannot be mapped into comb of qre  because the comb.ram and comb.price projections do not appear in the select clause  as is the case in q n1 . once we compute the containment mappings  we can turn the minicon rewriting queries into syntactic extensions of the current query by renaming the aliases of the former.
　we managed to avoid computing the containment mappings on top of minicon. we observed that while minicon searches for maximally-contained rewritings  it builds the containment mappings from the current query to the maximally-contained ones. so we extended minicon to log this information and output it along with the set of maximally-contained rewriting queries over the views  as shown at the bottom of figure 1.
　subsequently  we wrote a views expansion component  which uses the logged containment mappings to expand the views in every minicon maximally-contained rewriting so that the resulting queries are syntactic extensions of the current one.
　the views expansion component also generates the maximum projection lists used in the color algorithm of section 1. in section 1  we defined a maximum projection list to be the list of all possible projections that can be added to a query without compromising feasibility. it turns out that for each expanded query  the maximum projection list corresponds to all projections in the views that appear in the initial minicon rewriting. for example  the initial rewriting of q n1  is qr. we can safely add to qr all projections in views  without compromising feasibility  and obtain the following query:
select distinct	
	.cid 	.cpu 	.ram 	.price
	.cid 	.cpu .ram 	.price
	.cid .rate 	.standard 	.interface
from
　hence  the maximum projection list of q n1  consists of all projections inexcept .ram and .price which are mapped into from q n1 . the containment mappings are used here as well  so that the aliases in the maximum projection lists refer to aliases that appear in the current query. these lists are constructed in linear time.
redundant queries removal the views expansion component inputs maximally-contained queries  but not all syntactic extension queries it outputs are necessarily maximally-contained. it turns out that views expansion introduces redundancy across queries  i.e.  expanded queries might contain one another. for example  if the current query is q n1  in figure 1  snapshot 1 in figure 1   then
 minicon outputs two maximally-contained rewritings qr1 and qr1  over the viewswhich do not contain one another:
select distinct.ram 	.price	qr1
from
select distinct.ram 	.price	qr1
from
　the expansion of qr1 though contains the expansion of qr1  according to the definition of the viewsin example 1.
　in order to preserve the rapid convergence and minimality guarantees of clide  see section 1   we have to eliminate contained queries. this additional work is performed by the redundant queries removal component  which we built from scratch and tests if one query is contained in another. the query containment test amounts to finding containment mappings between queries and is in general np-complete in the query size. in practice  the constructed queries are small  and this test is very efficiently implemented . we compute the containment mappings from query q1 into query q1 by constructing a canonical database  for q1  candb q1  and running q1 over candb q1 . to efficiently evaluate q1  we employ standard algebraic optimization techniques: we construct an algebraic operator tree for q1  left deep join tree   in which selections and projections are pushed and joins are implemented as hash joins.
　the efficient implementation of the views expansion component proved crucial to the on-line response of clide  since query containment tests are the bottleneck for clide's performance  as section 1 demonstrates.
redundantactionsremoval the output of the redundant queries removal component is still not the set of minimal feasible extension queries fqme that we are looking for  because they are not necessarily minimal extensions of the current query. for example  if q is the current query shown below  then qe is the only feasible expansion query we get from minicon. qe is not a minimal expansion query though. query qme requires one action less than qe to reach an equivalent query that minimally extends the current one.
select distinct com1.ram  com1.price
from computers com1  computers com1qselect distinct com1.ram  com1.price
from computers com1  computers com1
where com1.cpu='p1' and com1.cpu='p1'qeselect distinct com1.ram  com1.price
from computers com1  computers com1
where com1.cpu='p1'qme　the redundant actions removal component finds fqme by systematically detecting two identical constants that refer to identical columns of two tables with identical names but distinct aliases  dropping one of them at a time  and testing for equivalence with the initial query. the same rule is applied on self-joins.
1.	experimental evaluation
　our experimental evaluation shows that clide is a viable online tool. the minicon algorithm was evaluated via extensive experiments in  to measure the time to find the maximally-contained rewritings of queries using views. the goal of our experiments was to show that the rest of the clide components do not add a prohibitive cost  and that the algorithms of sections 1 and 1  as well as our extensions and optimizations  efficient implementation of containment test  logging minicon's containment mappings  are crucial in obtaining quick response times.
the experimental configuration to study how clide scales with increasing complexity of the constructed query and with the number of views in the system  we used a synthetic experimental configuration  whose scaling parameters are k l m  as described below.
　the schema. in the literature  synthetic queries are usually generated in one of two extreme shapes: chain queries and star queries. for a more realistic setting  we chose a schema which allowed us to build queries of a chain-of-stars shape  and in which joins follow foreign-key constraints  the most common reason for joins . to this end  we picked a schema comprised of a relation a ka a  playing the role of a star center  which is linked  via foreign key constraints  to k relations {bi kb fb b }1＋i＋k  the star corners . each bi is in turn the center of another star whose l corners are given by the relations {ci j kc fc c }1＋j＋l. ka kb kc are respectively the key columns for a  the bi's and the ci j's. in each bi  fb is a foreign key referencing ka from a. in each ci j  fc is a foreign key referencing kb from bi.
　the views. the minicon experiments in  consider two extremes for view shapes  one very favorable  the other one leading to long rewriting time. the views in our configuration fall in the middle of this spectrum  and are more realistic. each view we picked covers one of the foreign-key-based joins suggested by the schema. moreover  we introduced selections with constants in these views  to force the interface to propose not only tables and joins  but also selections. for each i  we introduced m views {vin}1＋n＋m joining a with bi and imposing a selection comparing the b column with some constant cn. for each i j we introduced m views {vi jn }1＋n＋m joining bi with ci j and comparing the c column to the constant cn.
	vin: select x.a  y.kb  y.b	vi jn : select y.kb  y.b  z.c
	from a x  bi y	from bi y  ci j z
         where x.ka=y.fb and y.b=cn where y.kb=z.fc and z.c=cn there are k 〜m +k 〜l〜m views in the configuration. for an intuitive interpretation of our abstract configuration  let the bi tables stand for computer accessories  such as network cards  storage  keyboard  etc. for instance if b1 plays the role of the netcards table in figure 1 and a that of computers  then the view provides the computers compatible with a network card satisfying a selection condition with constant c1.
　the queries. we scripted a family of interactions in which the simulated user starts by performing an a table action and then follows only blue and yellow suggestions  continuing even after reaching feasible queries.
　after the initial a table action  clide suggests joins with the bi's. if any of these suggestions are taken  say by picking bp   clide suggests the corresponding selections on bp's column b  as a list of options c1 ... cm. it also suggests table actions leading to the join of a with some other bj or of bp with some cp o. when the simulated user picks a selection with cn it reaches a feasible query having a rewriting using vpn. when this feasible query is extended to join bp with some cp o  clide suggests  among others  selections comparing cp o's column c to some constant. picking

 # of joins  # of selections  in current query
figure 1: clide's response time
one of these  say cr  generates another feasible query  which has a rewriting that joins vpn with vp or .
the measurements the measurements were conducted on a dedicated workstation  pentium 1.1ghz  ms windows xp pro  1gb ram  using sun's jre-1.1. all measurements are elapsed times.
　we generated four configurations by fixing k = 1  l = 1 and varying m = 1 1  yielding respectively 1 1 and 1 views. figure 1 reports the time clide took to come up with the suggestions at each current query. query  n m  is a query reached after performing n table actions and joins  and m selections. on the horizontal axis  all odd-position queries are infeasible  while even-position queries are all feasible  being obtained by adding a relevant selection to their predecessor. for instance  feasible query  1  is obtained from infeasible query  1  by adding a selection action.
　notice that  while clide's response is good overall  scaling to large number of views  it is much better for feasible queries. this is an expected result  since clide needs to consider a single closest feasible query  i.e.  the one that the user has reached  as opposed to the number of closest feasible queries when the current query is infeasible. the bottleneck in clide's performance turns out to be the containment tests  which are a consequence of the views expansion. for instance  for query  1   there are 1 expanded queries of which only 1 are non-redundant. these queries are quite sophisticated  joining up to 1 views. to identify them  clide runs pairwise containment tests over the 1 redundant queries  then it minimizes the 1 queries invoking more containment tests. this work dominates the response time. 1 containment tests need 1 seconds out of the 1 seconds of the elapsed time. the reason clide scales to these query and view sizes is the efficient implementation of the containment test.
　note that when parameterized selections do not appear in the views  we could invoke minicon only when the user reaches a feasible query. we could exploit the fact that one interaction step along an edgechanges q n  only incrementally. if a was a yellow or blue action  f would be contained in fqc n  and we would not need to call minicon to compute f. instead  we could inspect the containment mappings from q n  into fqc n  and we could compute f by pruning those mappings that would not be consistent with action a and dropping from fqc n  all queries into which there would be no more containment mappings. this optimization would be in effect as long as the user would perform yellow and blue actions and for the periods of the interaction between feasible queries.
1.	discussion and related work
　alternative query formulation paradigms have been proposed in the literature   but the qbe paradigm is the one that users are mostly familiar with today. as an alternative to a visual query builder  one could try to exploit existing formalisms for compact descriptions of infinite sets of supported queries. these focus mainly on sets of binding patterns  1  1  1  1  and sets of parameterized queries described by the infinite unfoldings of recursive datalog programs  1  1 . however  these representations are meant for consumption by rewriting algorithms and not by humans: checking whether a given query is supported requires non-obvious rewriting algorithms  especially when the set of indirectly supported queries is enhanced via additional processing inside a mediator. this is a key obstacle to the practical utilization of current query rewriting algorithms for interactive query development  forcing the query writer into a trial-and-error loop.
　there are many scenarios which would benefit from clide's approach to query building. one example is the setting of   which is a special case of a service-oriented architecture with parameterized views restricted to identity views over individual tables. their algorithm infers binding patterns for queries against these views  and could conceptually be used by the user to reach a feasible query by providing appropriate bindings. however  the user queries may be adorned with exponentially many binding patterns  turning the visual inspection by the user into a cumbersome process. another obvious clide application is in data privacy enforcement.  1  1  allow data owners to identify the non-sensitive data they are willing to export by means of parameterized  virtual views against the proprietary data. data consumers formulate their queries against the proprietary database as well  but their queries are rejected  or return null values  if they are not feasible according to the virtual views.
　the implementation of the clide back-end described here requires as one building block an algorithm for finding maximallycontained rewritings. we picked minicon  because we had access to the code  but we could have swapped it with any other one . their applicability to our problem comes as a pleasant surprise  as the original goal of these algorithms is different: to provide an underestimate approximation of the query answer when the query is not feasible. other systems  automatically formulate an overestimate or underestimate of the submitted query. we believe that in many applications the user needs full control and understanding of what she can ask and which precise query is being answered.
1.	conclusions
　we presented the clide interactive system and its color scheme that leads the user toward feasible queries in a setting where the content and access methods of the sources are described by parameterized conjunctive views. we have provided guarantees of completeness  minimality of suggestions and rapid convergence. we formalized the interaction with the front-end using an interaction graph and reduced coloring properties to interaction graph properties that the back-end has to decide upon. we developed the frontend and the back-end for the case where only constant selections appear in the views. we implemented effective optimizations that enable on-line use of clide for a wide class of queries and views.
a clide demonstration is available at http://www.clide.info.
1.	acknowledgments
　the authors would like to thank yannis katsis  alan nash and michael j. carey for their valuable contribution. alin deutsch was supported by nsf career award iis-1. yannis papakonstantinou was supported by nsf itr1  the gordon and betty moore foundation  and the nsf award # ear-1  geon itr . michalis petropoulos was supported by nsf itr 1.
