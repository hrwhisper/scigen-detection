recent data stream systems such as telegraphcq have employed the well-known property of duality between data and queries. in these systems  query processing methods are classified into two dual categories - data-initiative and query-initiative - depending on whether query processing is initiated by selecting a data element or a query. although the duality property has been widely recognized  previous data stream systems do not fully take advantages of this property since they use the two dual methods independently: data-initiative methods only for continuous queries and query-initiative methods only for ad-hoc queries. we contend that continuous query processing can be better optimized by adopting an approach that integrates the two dual methods. our primary contribution is based on the observation that spatial join is a powerful tool for achieving this objective. in this paper  we first present a new viewpoint of transforming the continuous query processing problem to a multi-dimensional spatial join problem. we then present a continuous query processing algorithm based on spatial join  which we name spatial join cq. this algorithm processes continuous queries by finding the pairs of overlapping regions from a set of data elements and a set of queries  both defined as regions in the multi-dimensional space. the algorithm achieves the advantages of the two dual methods simultaneously. experimental results show that the proposed algorithm outperforms earlier algorithms by up to 1 times for simple selection continuous queries and by up to 1 times for sliding window join queries.
1. introduction
a data stream is a sequence of data elements that arrive orderly 1  1  1 . examples of data streams include sensor data or network packet data. the primary characteristics of data streams are that they arrive continuously  rapidly 
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1  june 1  1  chicago  illinois  usa.
copyright 1 acm 1-1/1 ...$1.
unboundedly  and in real-time 1  1 . due to these characteristics  it is not possible to control the order in which elements arrive nor to store the entire data elements. hence  queries over data streams are not one-time queries  which are executed only once against stored data. instead  queries over data streams are continuous queries that are registered in advance and run repeatedly over a period of time 1  1 .
there has been a lot of research effort on efficiently managing stream data and processing continuous queries; many data stream systems such as niagaracq  telegraphcq  aurora and stream have been developed. especially  psoup  the query processor of telegraphcq  has employed the well-known property of duality between data and queries to process ah-hoc queries and continuous queries. ad-hoc queries are processed by finding a set of data elements that satisfy the condition of a query figure 1 a  . in contrast  continuous queries are processed by finding a set of continuous queries whose condition is satisfied by a data element figure 1 b  . we call these two dual methods query-initiative and data-initiative  respectively.
¡¡find all data elements that satisfy the condition of a queryfind all queries whose condition is satisfied by a data element
                       a query a data element  a  query-initiative method.  b  data-initiative method.
figure 1: two dual methods for query processing.
although the duality property has been widely recognized  previous data stream systems do not fully take advantages of this property since they use the two dual methods independently: data-initiative methods only for continuous queries and query-initiative methods only for ad-hoc queries. thus  when processing continuous queries  the performance gain that could be obtained by query-initiative methods has been overlooked.
we contend that continuous query processing can be better optimized by adopting an approach that integrates these two dual methods. as shown in figure 1  our method finds all pairs of a query and a data element where the data element satisfies the condition of the query. that is  our method allows us to process multiple continuous queries against multiple data elements. compared with data-initiative methods  our method has more opportunities for optimization on the data set as well. in particular  it can share query executions against individual data elements  significantly improving the overall performance of query processing against multiple data elements. thus  the advantages of our method become more prominent when a large number of data elements have to be handled due to a high input rate.
find all pairs where the data element satisfies the condition of the query

figure 1: our method that integrates the two dual methods.
our major contribution is based on the observation that spatial join is a powerful tool for combining the two dual methods. spatial join is a spatial database operation that finds all pairs of objects satisfying a given spatial relationship i.e.  overlap as in this paper . we find out and exploit the similarities between our method and spatial join.
we first present a new viewpoint of transforming the continuous query processing problem to a multi-dimensional spatial join problem. for the transformation  we present a formalization of duality between data and queries  which we call the duality model. the duality model represents both a data element and a query as regions in the multi-dimensional space and defines query processing as a process of finding the pairs of overlapping regions from a set of data elements and a set of queries.
we then propose the continuous query processing algorithm based on spatial join  which we call spatial join cq. the algorithm achieves the effects of both of the two dual methods by using spatial join  which is a symmetric operation. to show progressive development of the algorithm  we first develop the algorithm for simple selection continuous queries  and then  extend it to accommodate sliding window join continuous queries. we demonstrate excellence of the algorithm by extensive experiments. as stated earlier  our algorithm becomes more effective - especially for batch processing  where we can take advantage of optimization on the data set as well.
the rest of this paper is organized as follows. section 1 introduces the forms of data streams and continuous queries that are dealt with in the paper. section 1 reviews prior work on continuous query processing methods. section 1 formalizes the duality model. section 1 presents the continuous query processing algorithm based on spatial join. section 1 extends the algorithm so as to accommodate sliding window join continuous queries. section 1 summarizes the results of performance evaluation. section 1 concludes the paper.
1. preliminaries
in this section  we discuss the forms of data streams  continuous queries  and the continuous query processing methods that we handle in the paper.
the form of data streams
most of existing data stream systems such as telegraphcq  aurora  and stream handle the relational tuples having a fixed schema for each data stream source. we handle the same form of input data streams.
for simplicity of explanation  we assume that the domain of all the attributes is a real number between 1 and 1. here  1 and 1 mean the minimum and maximum values of the domain  respectively. we make this assumption without loss of generality because any value can be transformed to a real number using a hash function. for example  in the case of a string value  the order-preserving hash functions proposed by fox et al. can be exploited.
a data element in a data stream has a timestamp  meaning the time when it arrived  in addition to attributes. it can be used to identify the order of data elements and to expire old data elements.
the form of continuous queries
most of existing data stream systems 1  1  1  handle selectproject-join  spj  queries against relational tuples.1 we handle the same form of continuous queries  which is shown in equation  1 .
	¦° projection attributes  ¦Ò selection predicate d  	 1 
here  d stands for the set of data stream sources. the selection predicate represents the condition of a query. the condition is represented as a disjunction of conjunctions  i.e.  in the disjunctive normal form dnf . we note that any query condition can be translated to a dnf. for a single data stream source  this condition consists of a boolean expression of simple predicates involving the operators    ¡Ý   =     and ¡Ü. for multiple data stream sources  this condition contains a join condition including an equi-join or a theta-join. the projectionattributes represents the list of the attributes returned as the query result.
for continuous queries  the concept of the sliding window 1  1  1  has been presented to restrict the range of data elements to be processed. this concept becomes necessary due to unboundedness of data streams. the sliding window is categorized into the time-based sliding window and the count-based sliding window. the former consists of the data elements that arrived within the given w time unit. the latter consists of the w data elements that most recently arrived.
strategies for continuous query processing
there are two strategies for continuous query processing: immediate processing and batch processing. the former processes continuous queries immediately after a data element arrives. the latter keeps data elements for some duration and processes continuous queries against the data elements kept. we support both strategies in this paper.

1
 in data streams  aggregation functions are usually processed by finding approximate results because of unboundedness of the input data 1  1 . it can be done in a postprocessing step after the spj queries are processed  and we will leave this issue as a further study.
immediate processing is hard to use in an environment where data elements are arriving at a very fast rate. in contrast  batch processing is adequate for such an environment since it can improve the performance by sharing query executions against individual data elements. we note that sliding window join can take advantages of batch processing since it is processed against sets of data elements contained in sliding windows. batch processing  however  is not suitable for realtime monitoring because of the delay in query processing.
1. related work
to process continuous queries  existing data stream systems such as niagaracq  telegraphcq  aurora  and stream adopt the data-initiative approach. that is  these systems find continuous queries whose conditions are satisfied by the data element that newly arrives. hence  in these systems  optimization is allowed only for the query set  but not for the data set. accordingly  the differences between telegraphcq and our method become remarkable when we process continuous queries over a large number of data elements.
golab et al. classifies optimization techniques employed in existing systems into query plan sharing 1  1  and query predicate indexing.
query plan sharing identifies the common operations among continuous queries registered and executes these common operations only once. hence  repeated execution can be avoided. this method is mainly used to share join  which is a very costly operation. figure 1 a  shows an example of query plan sharing between the queries q1 and q1. since the queries q1 and q1 have a common join operation r.x = s.y  they can share it to speed up continuous query processing.
q1 : select * from r  s where r.x = s.x and 1   r.y  1
q1 : select * from r  s where r.x = s.x and 1   r.y  = 1
	q1	q1

 a  query plan sharing 	 b  query predicate indexing between the queries q1 and q1.	on the attribute r.y.
figure 1: query optimization techniques for the data-initiative method.
query predicate indexing allows us to efficiently find continuous queries whose conditions are satisfied by a given data element. this can be done by indexing the ranges of an attribute value that makes a query predicate true. niagaracq and telegraphcq use a predicate index that is similar to the ibs tree for this purpose. the ibs tree is a balanced binary search tree  which is created for each attribute. its node stores a constant value appearing in the predicates as well as the identifiers of the predicates having that constant value. these identifers are categorized by the operators i.e.     ¡Ý  =     and ¡Ü  used in the predicates. figure 1 b  shows an example of predicate indexing on the attribute r.y of the queries q1 and q1. to find the predicates that become true  we traverse the ibs tree using the attribute value of a given data element. suppose a data element whose value for the attribute r.y is 1. in the node 1  the query q1 is selected because 1 is grater than 1. in the node 1  the query q1 is selected because 1 is less than 1. since q1 is selected in every node that stores it  q1's condition on r.y becomes true for r.y = 1.
this method has a weakness of having to retrieve the result for each ibs tree and merge those results since an ibs tree is created for each attribute. besides  it cannot index the predicates  such as join  that involve multiple attributes.
on the other hand  a method similar to spatial join cq has been independently developed in another area. sina  proposed in the area of spatial databases  has some similarities to our method  i.e.  it uses spatial join to process continuous queries over moving objects. our distinct contribution is proposing transformation of continuous query processing  which is not originally a spatial database operation  into spatial join. furthermore  sina deals primarily with simple range predicates  but does not deal with complex queries typically found in recent data stream systems  e.g.  conjunction or disjunction  of predicates and join involving multiple data stream sources. spatial join cq handles these complex queries easily.
1. the duality model
in this section  we present a formalization of duality between data and queries  which we call the duality model. section 1 presents the definition of a data element and a query in the duality model; section 1 query processing in this model.
1 the definition of a data element and a query
we define a data element and a query symmetrically. definitions 1 and 1 define a data element and a query as a point and a region in the multi-dimensional space  respectively. hereafter  since a point is a special form of a region  we call a point as a region unless there is confusion.
definition 1.  a data element in the duality model  suppose that a data element d =  v1 v1 ...  vn  has n attributes  and the domain of attri is domi  1 ¡Ü i ¡Ü n . a data element d is a point  v1 v1 ... vn  in the domain space dom1 ¡Ádom1 ¡Á... ¡Ádomn. that is  a data element d is a point in the n-dimensional space where an attribute becomes an axis with the coordinate value of the axis being the value of the attribute. denotes a set of data elements.

definition 1.  a query in the duality model  sup-
pose that the condition of a query q is  q attr1  attr1 ... attrn
   and the domain of attri is domi  1 ¡Ü i ¡Ü n . a query q is the region { v1 v1 ... vn  |  q v1 v1 ... vn   v1 ¡Ê domi ... vn ¡Ê domn} in the domain space dom1¡Ádom1¡Á ... ¡Á domn.1 that is  a query is a region where the points located in the region satisfy the condition of the query.
denotes a set of queries.	
example 1. figure 1 shows an example of data elements and queries in the duality model. the data elements d1  d1  and d1  which are tuples of the relation r x y   are represented as the points in the two-dimensional space consisting of x and y axes as shown in figure 1 a . for instance  d1 is the point whose value of x is 1 and value of y is 1. the queries q1 and q1 over the relation r x y  are represented as the regions in the two-dimensional space as shown in figure 1 b . for instance  q1 is the region whose interval of x is
 1  and that of y is  1 .	
data in r x y  :	queries :
q1 =   1¡Ür.x¡Ü1  and  1¡Ür.y¡Ü1 
	d1 =  1   d1 =  1   d1 =  1 	q1 =   1¡Ür.x¡Ü1  and  1¡Ür.y¡Ü1 
	r.y	r.y
1
1
1
1
1
1
r.xr.x
1 1 1 1	1 1 1 1 a  data elements in the multidimensional space b  queries in the multidimensional spacefigure 1: an example of data elements and queries in the duality model.
1 definition of query processing
in the duality model  query processing is defined as the process of finding the pairs from a set of data elements and a set of queries that overlap in the multi-dimensional space. lemma 1 shows the correctness.
lemma 1. given a set of data elements and a set of queries  a data element d ¡Ê satisfies the condition of a query q ¡Ê if and only if d overlaps with q in the multidimensional space.
proof: by definitions 1 and 1  the data element d and the query q are defined as the point  v  and the region { v1 v1 ... vn  |  q v1 v1 ... vn  = true}  respectively. if the point and the region overlap  it means that   ...  vn  becomes true according to definition 1.
thus  the data element d satisfies the condition of the query q.	
example 1. in figure 1  the data element d1 overlaps with the query q1. we note that the value  1  of d1 satisfies the condition  1 ¡Ü r.x ¡Ü 1  and  1 ¡Ü r.y ¡Ü 1  of q1. similarly  d1 overlaps with q1 satisfying the condition of q1. in contrast  d1 does not satisfy the condition of any queries because there is no query that overlaps with d1. 

1. a continuous query processing algorithmbasedonspatialjoin
in this section  we propose our continuous query processing algorithm spatial join cq. to show progressive development of the algorithm  we first develop the algorithm for simple selection continuous queries  and then  extend it to accommodate sliding window join continuous queries in section 1.
1 characteristics
our algorithm integrates two dual methods - data-initiative and query-initiative - into one algorithm. thus  it allows us to find multiple queries that overlap with multiple data elements simultaneously. to achieve this  our algorithm first accumulates data elements arriving from data stream sources into a data set  and then  processes continuous queries with the data set in batch mode. our algorithm performs immediate continuous query processing as a special case of batch processing where there exists only one data element in the data set. for batch processing  our algorithm first constructs mbr's minimum bounding rectangle  containing multiple adjacent data elements from the data set  and then  performs spatial join  which is a symmetric operation  between a set of mbr's and a set of queries. hereafter  we will refer to this mbr as the data cluster.  in immediate processing  a newly arriving data element itself becomes a data cluster.  the data cluster allows us to prevent queries that overlap with multiple data elements from being repeatedly accessed because adjacent data elements tend to share a large portion of overlapping queries.
the continuous query processing algorithm consists of three steps as in figure 1: index building  multi-dimensional spatial join  and refinement.
in the first step  we build indexes over the set of data elements and the set of queries. the data index stores points  which represent input data elements  in a simple one-dimensional index. the query index stores regions  which represent continuous queries  in a multi-dimensional index. here  if the shape of the region representing a query is complex i.e. is not a simple hyper-rectangle   the query index stores the mbr for the region instead. in sections 1 and 1  we explain the details of the data and query indexes.
in the second step  we find candidate result pairs by performing multi-dimensional spatial join with the data and query indexes. we adopt the transform-based spatial join algorithm proposed by song et al.. because the query index stores mbr's of queries  the results of the spatial join step could include false positives. in section 1  we explain the details of the spatial join step.
in the third step  we find the final result pairs by testing whether the data element in a candidate result pair indeed makes the the conditions of the query in the pair true.
1 the transform-based spatial join algorithm
spatial join
figure 1: the three steps of the continuous query processing algorithm based on spatial join.in this section  we briefly introduce the transform-based spatial join algorithm adopted in this paper. the algorithm transforms spatial objects with extents into points without extents using corner transformation  and then  performs spatial join. it shows performance comparable to or better than those of other original-space spatial join algorithms proposed in the reference  1  1 .
corner transformation transforms the mbr of a spatial object in the n-dimensional original space into a point in the 1n-dimensional transform space. in corner transformation  the coordinates of a point in the 1n-dimensional space are determined by the minimum and maximum values of the mbr on each of the n axes in the original space 1  1 . for example  a one-dimensional object whose minimum and maximum values on the x-axis are lx and rx  respectively  is transformed into the point  lx rx  in the two-dimensional transform space.
a query that finds spatial objects overlapping with a given region object in the original space is transformed into a query that finds point objects contained in a certain region in the transform space 1  1 . figure 1 shows relationships between a point and regions in the transform space. here  objects overlapping with the region r in the original space are transformed into points in the regions a  b  c  or d in the transform space. using these characteristics  the original-space spatial join operation that finds spatial objects overlapping with the region r can be processed by the operation that finds points in the union of the transformspace regions a  b  c  and d  which constitutes the shaded part in figure 1.
we use the notion of the spatial join window to process spatial join and formally define it in definition 1.
definition 1.  spatial join window   let transform spaces of indexes r and s to be joined be ts r  and ts s . the spatial join window sjw p  for a rectangular region p in ts r  is defined as the minimal region in ts s  where all the objects overlapping with the object in p can reside.

the method for finding sjw p  for the region p  which is the dark shaded region in figure 1  is as follows.1 to overlap with objects in p  a given object must overlap with the

1
 for simplicity of explanation  we only explain the sjw in the two-dimensional transform space. the sjw for the 1ndimensional transform space is described in detail in song et al..
r
1	lx	rx	1
 a  region r in the original space. b  spatial relationships to r in the transform space.figure 1: transform-space regions having various spatial relationships with the query region r in the original space. here  r  is the transformed point of r.
upper-left point of p  i.e.   q =  lx rx   because  q is the largest object that can exist in the region p. the minimal region that all objects overlapping with  q can exist in ts s  is  1 rx  ¡Á  lx 1  above the diagonal by lemma 1. that is  sjw p  is the light shaded region in figure 1. since no object can exist under the diagonal  for simplicity  we use sjw p  as  1 rx ¡Á  lx 1  including the striped region from now on.
rx

figure 1: spatial join window sjw .
lemma 1.  the minimal region  sjw p   that all objects overlapping with the original space object  q =  lx rx  can exist in ts s  is  1 rx  ¡Á  lx 1  above the diagonal.
proof: see song et al..	
as indicated by lemma 1  the two sjw's in ts s  for two adjacent regions in ts r  significantly overlap. an example is the sjw's of two adjacent regions p1 and p1 in figure 1. we call this property the overlapping property of sjw's. thus  we can speed up spatial join processing with a fewer number of i/o accesses by consecutively joining two adjacent regions pi and pj with their sjw's because objects in sjw pi  must have already been read into the buffer when joining pj with sjw pj   and vice versa. here  we assume that the buffer replacement strategy is lru.
	rx	rx
1.1
lxlx 1	1	1	1
 a  adjacent regions p1 and p1.  b  sjw p1  and sjw p1 .
figure 1: spatial join windows for adjacent regions.
1 building the data index
our algorithm uses the data index to accumulate data elements for batch processing and to read the data elements in a proximity order. reading them in a proximity order allows us to take advantage of the overlapping property of sjw p 's by constructing a data cluster p from adjacent data elements. the data index is destroyed after the batch is processed and is rebuilt for the next batch. the data index is not used in immediate processing.
for the data index  we adopt a one-dimensional index instead of a multi-dimensional index. this simple one-dimensional index provides sufficient capabilities for the data index  which is used only for accessing data elements in a proximity order.
we use a space filling curve 1  1  to arrange data elements in a proximity order. the space filling curve is a method of linearly ordering regions in the multi-dimensional space such that regions tend to be close to each other if they are proximate in the multi-dimensional space 1  1 . representative ones include the z-ordering and the hilbert ordering shown in figures 1 a  and  b .1 in this paper  we use the hilbert ordering because it changes the value of only one axis at a time  producing high proximity. we build a binary search tree to index data elements in the proximity order determined by the hilbert ordering.

	 a  z-ordering.	 b  hilbert ordering.
figure 1: representative space filling curves.

1
 these space filling curves can be used in three or higherdimensional space by recursively applying the curve to each dimension 1  1 .
1 building the query index
our algorithm uses the query index for efficient retrieval of the queries contained in sjw p  from the query space for a given region p in the data space. multi-dimensional structures such as the r-tree  quad tree  buddy tree  and mlgf 1  1  can be used as the query index.
inserting a query into the query index is done as follows. the query is represented as a region by definition 1  and the shape of the region is approximated as an mbr. the mbr is transformed into a point using corner transformation  and then  is inserted into the multi-dimensional index. as stated in the footnote of definition 1  disjunctive queries are represented as a collection of multiple regions. in this case  the procedure described above is applied to individual regions except that these regions belong to the same query.
example 1. figure 1 shows an example of indexing queries represented as regions. the query q has three conditions: two attributes of data  x and y  have a range  1 1   and x is greater than y. the query q is represented as a triangular region rq. because such a region cannot be indexed directly  the region is approximated to mbrq. the mbrq is transformed into a point  1  1  1  1  in the four-dimensional space  which is subsequently inserted into the multi-dimensional index. 

figure 1: an example of query indexing.
our method of building the query index is capable of efficiently handling large regions since we transform a region with extents into a point with no extents before indexing. a query becomes a large region in the original space especially when its condition has an open interval; it includes an entire domain of an attribute in the original space when there is no condition on that attribute. these large regions tend to significantly overlap with one another. if these large regions are directly indexed in the multi-dimensional index such as the r-tree  a large portion of the nodes overlap with each other  thus making the index size bigger and the query performance worse. in contrast  we do not suffer from this problem because we index a point in our method.
even though the performance of multi-dimensional indexes decreases as the number of dimensions increases  called the dimensionality curse   this problem is not significant in our algorithm. the reason is twofold: the query index deals with only the attributes that appear in a query  but the number of those attributes is known to be typically one or two  and rarely more than five. besides  we can apply existing methods  such as the pyramid-technique  of min-
imizing the dimensionality curse for exceptional cases e.g.  when the number of attributes appearing in a query is more than ten .

input: a newly arriving data element or a newly registered query 
output: data element-query pairs that satisfy conditions algorithm: 
/* nbatch data is the number of data elements in a batch */ 
/* ndc is the number of data elements in a data cluster */ 
/* for immediate processing  nbatch data = 1; ndc = 1 */ 
1:  if a query is newly registered then 
	1: 	insert the query into the query index  as described in section 1 ; 
1:  end if 
1:  if a data element newly arrives then 
1:    insert the data element into the data index  as described in section 1 ; 
1:    if the number of data elements in the data index is nbatch data  then 
1:        repeat by  nbatch data / ndc  times 
1:  construct a data cluster dc containing ndc data elements read in   in proximity hilbert  order using the data index;        for immediate processing  dc consists of only one newly arriving data element  1: retrieve the queries contained in sjw dc  using the query index; 1:  find data element-query pairs  from dc and sjw dc     that satisfy the overlapping condition  lemma 1 ; 1:             refine the data element-query pairs by checking whether the data element   	makes the conditions of the query true; 
1:        end repeat 
1:        delete all data elements from the data index; 
1:     end if 
1:  end if 

figure 1: the continuous query processing algorithm spatial join cq. 1 multi-dimensional spatial join
in the multi-dimensional spatial join step  the algorithm constructs a region p by reading data elements in a proximity order and retrieves the queries contained in sjw p . the former operation exploits the data index; the latter the query index. then  the algorithm finds the overlapping pairs from data elements in p and queries in sjw p .
the region p corresponds to the data cluster stated before. the data cluster is an mbr containing a fixed number of data elements  where data elements are retrieved in a proximity order. the algorithm needs to control the size of the data cluster to prevent its size from becoming overly large or small. if the size becomes too large  so does the sjw of the data cluster  thus making a large portion of the query index to be accessed. if the size becomes too small  the performance gain that could be obtained by batch processing is diminished. hence  the size of the data cluster is an important parameter for tuning the performance of continuous query processing. it is difficult to determine the optimal size of the data cluster by analytical prediction since it varies depending on many parameters such as the numbers or distributions of data elements and queries. hence  in this paper  we find the optimal size through experiments in section 1  leaving the analytical solution as a future study.
figure 1 shows our algorithm for processing continuous queries. we call it spatial join cq. in the first step lines 1¡«1  and the second step lines 1¡«1   we create the query index and the data index as described in sections 1 and 1  respectively. in the third step lines 1¡«1   we perform spatial join to process continuous queries. for batch processing  we perform spatial join when nbatch data data elements have been accumulated; for immediate processing  when one data element arrives. spatial join is processed times as follows  for immediate processing  nbatch data = 1 and ndc = 1 . first  ndc data elements are read in in the proximity order by using the data index  and a data cluster is created lines 1¡«1 . second  the queries contained in the sjw of the data cluster are retrieved by using the query index line 1 . third  the overlapping pairs are found from the data elements and the queries line 1 . after spatial join is done  the algorithm refines the result pairs and obtains the final results line 1 . finally  the algorithm destroys the data index line 1 . the data index is rebuilt with the next batch of data elements that newly arrive.
example 1. figure 1 shows an example of the continuous query processing done in the batch mode. in the data space of figure 1  we have six data elements consisting of only one attribute x. each data cluster is created with three data elements. in the query space of figure 1  data cluster1 is joined with the queries q1  q1  and q1  and data cluster1 with the queries q1  q1  and q1. 
1. extensionofspatialjoincqfor sliding window joins
in this section  we extend the algorithm presented in section 1 so as to accommodate sliding window join continuous queries.
we first explain sliding window join as done by kang et al.. figure 1 shows sliding window join processing be-
1
figure 1: an example of the data element-query spatial join using the data cluster.
tween the data streams a and b. figure 1 a  shows the join processing steps when the data element d1 newly arrives from the data stream a:  1  checking whether the join condition is satisfied between the data element d1 and the data elements contained in the sliding window of the data stream b probe ;  1  inserting the data element d1 into the sliding window of the data stream a insert ; and  1  removing the data elements whose timestamps exceeded the sliding window range from the sliding window of the data stream a invalidate . figure 1 b  shows the join processing steps when the data element d1 newly arrives from the data stream b. the steps are symmetric with those in figure
1 a .
	¢Ú insert ¢Û invalidate	sliding window a
data data
stream astream a
data data
stream bstream b
	sliding window b	¢Ú insert ¢Û invalidate
 a  a data element d1 arrives 	 b  a data element d1 arrives from the data stream a.	from the data stream b.
figure 1: sliding window join.
to adapt our algorithm to sliding window join  we need to extend the three methods: 1  indexing data elements  1  indexing queries  and 1  multi-dimensional spatial join. the first should be extended so as to maintain only data elements within the sliding window range  the second to index the join conditions as well as the sliding window conditions  and the third to check these conditions.
extension of the data indexing method
the data index uses a doubly linked list as well as a binary search tree to maintain data elements that are within the sliding window range. the data index also stores timestamp values indicating the arrival time of data elements. when a data element arrives from a data stream  it is inserted into the binary search tree  and then  linked at the head of the doubly linked list. if the timestamp of a data element exceeds the range of the sliding window  it is eliminated from the tail of the doubly linked list and from the binary search tree.
extension of the query indexing method
when the join condition is equi-join  it is represented as a diagonal in a two-dimensional plane. in figure 1 a   the query q has an euqi-join condition  r.x = s.x  between two data stream sources r and s. it is represented as a diagonal between  1  1  and  1  1  in the plane of r.x ¡Á r.y. if the join condition is a theta-join instead of an equi-join  the query is represented as a triangular region either above or below the diagonal. if the region is approximated as an mbr  the mbr becomes the entire region in the plane. if such a badly approximated mbr were used to index a query  search efficiency of the query index would become worse. for example  in figure 1 a   the mbr of the query q is represented as the entire plane of r.x ¡Á s.x.

 a  mbr of the join 	 b  mbr using the query 
	condition.	decomposition method.
figure 1: an example of indexing join condition.
in order to resolve the problem  we exploit the object decomposition method. the object decomposition method divides a query region into an arbitrary number of pieces and constructs an mbr for each piece. for example  in figure 1 b   the query q is split into four pieces through the axis r.x  and then  each mbr is stored in the query index. by applying the object decomposition method  we can index join conditions more accurately.
the query index stores the sliding window range as a range condition for an axis in the multi-dimensional space. in the multi-dimensional spatial join step  the axis for the sliding window range in the query index spatial joins with the axis of the timestamp in the data index. by using this method  the query index allows us to store continuous queries having different sizes of sliding windows together and to process these continuous queries as a single spatial join.
this way  the query index can store not only selection conditions but also join conditions. this is a very desirable property in the sense that  when both of selection and join conditions are specified in a query  we can process them simultaneously using one spatial join. in contrast  it has been pointed out as a problem that the ibs tree is inherently incapable of indexing join conditions since it is created on each attribute.
extension of multi-dimensional spatial join
as stated before  sliding window join is processed between a data element newly arriving from a data stream and the set of the data elements contained in the sliding window of the other data stream. thus  sliding window join can be regarded as a kind of batch processing. we refer to the pair of data elements as joinable data pair and formally define it in definition 1.
definition 1.  joinable data pairs  consider two data stream sources dsi and dsj. the set of joinable data pairs dsi dsj when the data element di arrived from dsi is defined as follows. here  sw dsj  means a set of data elements contained in the sliding window of dsj
	dsi dsj = {di} ¡Á sw dsj 	
our sliding window join algorithm proceeds as follows. first  the algorithm computes dsi dsj upon arrival of a data element di from the data stream source dsi. while computing dsi dsj  data elements in sw dsj  are retrieved in the proximity order using the data index. next  the algorithm constructs data clusters with a fixed number of joinable data pairs. finally  the algorithm finds query results by doing spatial join between the set of data clusters and the set of queries as stated in section 1. overall  the algorithm for join queries is analogous to the algorithm in figure 1 except that a data cluster is constructed with joinable data pairs instead of data elements.
the sliding window join algorithm can be used also for multiway join queries. for multi-way join queries  we compute ds1 ... dsn and perform spatial join between ds1 ... dsn and the query index. however  | ds1 ... dsn| tends to proliferate because of the cartesian product among ds1 ... dsn. efficient processing of multi-way join is left as the topic of a future paper.
1. performance evaluation
in this section  we present the results of performance evaluation. we describe the experimental data and continuous queries in section 1 and present the results of the experiments in sections 1  1  and 1.
1 experimental data and queries
we compare the performance of our algorithm with those of existing algorithms: the predicate indexing method using the ibs tree and the query plan sharing method. these methods are commonly used in recent data stream systems such as telegraphcq  niagaracq  and stream. table 1 summarizes the algorithms used in the experiments. we first compare the performances of processing simple selection queries  and then  those of processing sliding window join queries.
table 1: algorithms compared in the experiments.
simple selection query processing
sj-batchspatial join cq  batch processing sj-immediatespatial join cq  immediate processing ibscontinuous query processing using the ibs treesliding window join query processing
sj-joinspatial join cq  extended for join ibs-jsprocessing first join conditions using the query plan sharing method  and then  processing simple selection conditions using the ibs treefor the experimental results  we measure the elapsed time for processing a query. the elapsed time is an important measure in a data stream environment since it determines the number of input data elements that can be processed in a unit time. for fair comparison  we include the time for creating the data index in the elapsed time for the spatial join cq algorithm.
experiments are performed using one data stream source for simple selection queries and two data stream sources for sliding window join queries. we use synthetic continuous queries consisting of randomly generated conditions except when we need to use specific queries. a simple selection query is a conjunction of selection conditions over randomly chosen attributes. a selection condition is expressed as constant1 op1 attribute op1 constant1. here  attribute means the name of an attribute; constant1 and constant1 are values randomly selected from  1  1 ; and op1 and op1 are binary comparison operators randomly selected from ¡Ü and  . besides  a selection condition forms a left open interval  right open interval  or closed interval with a uniform probability. a sliding window join query involves join conditions - attribute1 op attribute1 - as well as selection conditions. here  attribute1 and attribute1 mean join attributes of data stream sources  and op a binary comparison operator randomly selected from    ¡Ý  =     and ¡Ü. in addition  we set the sizes of all the sliding windows to be the same. for data elements  we generate and use synthetic data whose attribute values are randomly selected from  1  1 .
we use the multilevel grid file mlgf  1  1  for the query index. for fair comparison  our algorithm reads the mlgf into main-memory in advance because the other algorithms compared are main-memory based. we use the hilbert ordering to arrange data elements in the proximity order in the data index.
all the experiments have been conducted on a pc with a 1ghz pentium1 processor and 1gbytes of main memory running windows/xp.
we now summarize in table 1 the notation to be used throughout section 1.
table 1: summary of notation.
symbolsdefinitionsnquerynumber of registered continuous queriesnattrnumber of attributes in a data stream1rprednumber of attributes appearing in the predicates of a query / nattrnbatchdatanumber of data elements in one batch processed together by sj-batchndcnumber of data elements in a data clustersizeswthe size of the sliding window
 in the number of data elements 1 optimal value of ndc
we first find the optimal value of ndc by experiments. ndc is an important parameter for tuning the performance of sj-batch. the optimal size varies depending on nbatch data  nquery  nattr as well as distributions of data and queries.
we vary ndc and choose the optimal value of ndc that makes the elapsed time minimized. an interesting result is that the differences in the elapsed time are very small around the optimal value of ndc. for example  the elapsed time

1
¡¡in our experiments  we assume that all attributes in data streams can appear in query predicates. thus  nattr means the number of attributes stored in the query index. increases only by 1% as ndc is varied from 1 to 1 when the optimal value of ndc is 1. this result indicates that we do not need to know the exact optimal value of ndc  rendering determination of ndc easy.
table 1 summarizes the optimal ndc's obtained by experiments when nbatch data is varied from 1 to 1 and nquery is fixed to 1. using these optimal ndc's  we measure the elapsed time per a data element. we use these optimal ndc's also in our subsequent experiments.
table 1: summary of the optimal values of ndc and the elapsed times  nquery = 1 .
nbatch data 1 1 1 1 1 nattr = 1 optimal ndc 1 1 1 1 1 elapsed time /data elements  ms  1 1 1 1 1 nattr = 1 optimal ndc 1 1 1 1 1 elapsed time /data elements  ms  1 1 1 1 1  
from table 1  we note that the optimal ndc gradually increases and the elapsed time decreases as nbatch data increases  i.e.  when batch processing is performed with more data elements accumulated. the reason why the optimal ndc increases is that the algorithm can construct a data cluster with more data elements located in proximity since the density of points representing data elements in the multidimensional space becomes higher as nbatch data increases. the reason why the elapsed time decreases is that the algorithm gets more benefit of batch processing since more data elements can be processed with a single probe into the query index as ndc increases. thus  for batch processing  it is more profitable to process continuous queries with more data elements accumulated.
1 simple selection continuous queries
effects of nquery and nattr
figure 1 shows the elapsed time for simple selection continuous queries as nquery is varied. for sj-batch  we set nbatch data = 1 representatively and use ndc = 1 when nattr = 1 and ndc = 1 when nattr = 1. the results indicate that sj-batch performs the best  sj-immediate the next  and ibs the worst. the reason why sj-immediate outperforms ibs is mainly due to different ways of using indexes. ibs searches multiple ibs trees  one for each attribute in the query condition  and merges the results. in contrast  sj-immediate accesses only one multi-dimensional query index and does not need to merge the results. the reason why sj-batch shows the best performance is that it reduces the number of accesses to the query index by virtue of the data cluster. moreover  sj-batch minimizes the number of i/o's for searching the query index by using the overlapping property of the sjws.
in figure 1 a   sj-immediate outperforms ibs by 1 times when nquery=1 and by 1 times when nquery=1. similarly  sj-batch outperforms ibs by 1 and 1 times  respectively. in figure 1 b   sj-immediate outperforms ibs by 1 times when nquery=1 and by 1 times when nquery=1. similarly  sj-batch outperforms ibs by 1 and 1 times  respectively. these results indicate that the performance advantage of our algorithms over ibs improves as the number of registered queries  nquery  increases. we also observe that the number of attributes does not significantly affect the performance advantage of our algorithms.

	 a  nattr = 1.	 b  nattr = 1.
figure 1: elapsed time for selection query processing as nquery is varied  nbatchdata = 1 .
effects of rpred
figure 1 shows the elapsed time for simple selection continuous queries as rpred is varied. these results indicate that the elapsed time for ibs increases as rpred does because the depth of the ibs tree is proportional to logrpred . in contrast  the performances of sj-batch and sj-immediate improve as rpred increases. the reason is that the depth of our query index i.e.  the mlgf  is not affected by rpred but only by nquery since a query is stored as one region in the mlgf regardless of the number of predicates specified in a query. moreover  in sj-batch and sj-immediate  the efficiency of searching the query index is enhanced as the number of predicates increases because the size of the region representing a query becomes smaller.
 sj-immediate	 sj-batch	 ibs
rpred
figure 1: elapsed time for selection query processing as rpred is varied  nattr=1  nquery=1 .
effects of distribution of data elements
in all the experiments stated above  we assume uniform distribution of input data elements. now  we show some results for skewed distribution where the values of most input data elements are confined to a specific narrow range. an example of skewed distribution is a data stream from a room temperature sensor: typically  room temperature does not change rapidly. we define the skewness rskew of input data elements as the ratio of the number of data elements that fall into a specific range to that of total data elements. for simplicity  we consider a specific range whose size is 1% of the size of the entire domain. figure 1 shows the performance variation as skewness is varied. the elapsed times for sj-immediate and ibs are shown to be insensitive to data distribution. in contrast  the elapsed time for sj-batch decrease as skewness increases  showing improvement by up to 1 times compared with that for uniform distribution. the reason for the improvement is that a data cluster can be constructed with a larger number of data elements since the density of data elements in the specific range becomes higher. we find out that  by experiments  the optimal ndc indeed increases from 1 to 1 as skewness does from 1% to 1%. therefore  the advantages of sj-batch get more marked for skewed distributions.

sj-batchsj-immediateibsfigure	1:	comparison	of	elapsed	time	as
rskew is varied  nattr=1  nbatch query=1  nbatchdata=1 .
1 sliding window join continuous queries
effects of nquery and sizesw
figure 1 shows the elapsed time for sliding window join continuous queries against two data stream sources as nquery is varied. in sj-join  we divide a region representing a join condition into four regions using the object decomposition method as explained in section 1. these results indicate that sj-join outperforms ibs-js by a large margin for a reason similar to that of figure 1 showing that sj-batch outperforms ibs. furthermore  this margin becomes larger as sizesw increases. the reason is that the elapsed time for ibs-js increases proportionally to sizesw  while sj-join reduces the frequency of accessing the query index by virtue of a larger data cluster sizesw corresponds to nbatch data in table 1 . in figure 1  sj-join outperforms ibs-js by up to 1 times when sizesw = 1  1 times when sizesw = 1  and 1 times when sizesw = 1.
in summary  the experimental results show that our algorithm outperforms earlier optimization methods for both kinds of continuous queries: simple selection and sliding window join. furthermore  our algorithm has a desirable property that the performance advantage becomes larger as
 1  nquery   1  sizesw   1  rpred  or  1  rskew increase.
1. conclusions
in this paper  we have developed a framework for efficiently processing continuous queries based on spatial join. the contributions of this paper are summarized as follows.
first  we have presented a new viewpoint of transforming the continuous query processing problem to a multi-dimensional spatial join problem. the main advantage of this transformation is to integrate the two dual methods: data-initiative and query-initiative. hence  we have shown that spatial join is a powerful tool for processing continuous queries. the transformation takes advantage of the well-known property of duality between data and queries. we have formalized the duality property as the duality model.
second  we have proposed a continuous query processing algorithm based on spatial join  named spatial join cq. the algorithm processes continuous queries by performing spatial join  which is a symmetric operation  between a set of data elements and a set of queries. by virtue of this symmetric processing  the algorithm achieves the advantages of both of the two dual methods  rendering continuous query processing more effective.
third  we have verified excellence of the proposed algorithm by extensive experiments. the results show that our algorithm for simple selection continuous queries outperforms earlier methods by up to 1 times in batch processing and by up to 1 times in immediate processing. our algorithm for sliding window join continuous queries outperforms earlier methods by up to 1 times. moreover  our algorithm has a desirable property that the performance advantage becomes more marked as the number of registered continuous queries  the size of sliding windows  the ratio of attributes having predicates  or the skewness of input data elements increase.
overall  these results indicate that our approach provides a new insight into continuous query processing that can significantly improve the performance. as further studies  we need to improve our algorithm to efficiently process multiway sliding window join continuous queries and to develop a method of automatically selecting the optimal size of the data cluster.
acknowledgements
this work was supported by the ministry of science and technology most /korea science and engineering foundation kosef  through the advanced information technology research center aitrc .
