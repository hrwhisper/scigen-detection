pattern discovery in sequences is an important problem in many applications  especially in computational biology and text mining. however  due to the noisy nature of data  the traditional sequential pattern model may fail to reflect the underlying characteristics of sequence data in these applications. there are two challenges: first  the mutation noise exists in the data  and therefore symbols may be misrepresented by other symbols; secondly  the order of symbols in sequences could be permutated. to address the above problems  in this paper we propose a new sequential pattern model called mutable permutation patterns. since the apriori property does not hold for our permutation pattern model  a novel permu-pattern algorithm is devised to mine frequent mutable permutation patterns from sequence databases. a reachability property is identified to prune the candidate set. last but not least  we apply the permutation pattern model to a real genome dataset to discover gene clusters  which shows the effectiveness of the model. a large amount of synthetic data is also utilized to demonstrate the efficiency of the permu-pattern algorithm.
categories and subject descriptors
i.1  design methodology 
general terms
algorithms
keywords
sequential pattern  permutation pattern  proximity pattern
1. introduction
　mining ordering information from sequence data is an important data mining task. sequential pattern mining  1  1  1  1  1  can be regarded as mining frequent segments of total orders from sequences. however  due to noise in databases  the order of symbols in sequences may be permutated. thus discovered sequential patterns may not reveal the real characteristics of data. for example  in genomes of different organisms  genes may relocate during evolution  1  1 . on the other hand  symbols in sequences could be
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
kdd'1  august 1  1  las vegas  nevada  usa. copyright 1 acm 1-1-1/1 ...$1.
misrepresented by other symbols due to the presence of the symbol mutation noise. in some applications different symbols may be considered the same due to their similarity. for example  in text mining  a set of synonymous words is a group of distinct symbols that should be treated as the same. orthologous genes   which are different genes in various genomes with the same biological functionality  also form such groups in a biological context. this kind of mutation noise can conceal frequent sequential pattern discovery.
　in this paper  we study the problem of discovering a new type of pattern  called mutable permutation patterns  in noisy environments. the model of mutable permutation patterns addresses the above problems of sequential patterns in noisy environments. in these environments  the order of symbols in a pattern could be altered in sequences  and some symbols are interchangeable with other symbols. member symbols of a mutable permutation pattern can appear in any order in sequences while keeping physical proximity. these patterns are of great importance in many applications. two example applications are:
  biological sequence analysis: in genome analysis it is desirable to find related genes which function together in genomes of different species. orthologous genes are evolved from the same ancestor  and they will change in different species during evolution without changing their biological functionalities. furthermore  some genes may change their positions in the genome with the following condition. if a group of genes are closely located together in one genome  they are closely located in another for many species  1  1 . the proximity is defined by the gap between two consecutive genes. thus finding physically clustered genes is an effective way to generate candidates for functionally related gene groups  which are of great importance in genome analysis. in this context  the traditional sequential pattern model will fail to find these patterns since it only considers the total order of genes.   text mining: semantic patterns in text documents are useful for summarizing texts and extracting the meaning of raw texts. however the traditional sequential pattern model may not be directly applied on text documents due to the existence of synonyms and the variety of sentence structures. for example  one sentence can be phrased in either active form or passive form  but the keywords  such as subjects and objects  are always bounded in a sentence. it is desirable to find a pattern consisting of words that frequently occur in proximity.
　we assume that the input sequence data set is in the form   s1  g1 s1  g1 ... sn   where si is the symbols and gi is the gap between two consecutive symbols. as described in above examples  this form of data set may appear in text and bio-sequence domains. for instance  a genome sequence can be in this form where si is a gene and gi is the gap between two consecutive genes in the genome as shown in . if a group of genes forms a team for a certain biological function  these genes may be close to each other in a genome. since the number of genes participating in the biological function may vary from a few to more than a couple hundred  the total portion of the genome that this group of genes spans may not be bounded. however  the gap between any two genes in this group is within a certain threshold  e.g.  1 base pairs according to . by discovering the group of genes that always cluster together across several genomes  we may be able to identify the set of genes that participate in a biological process. also  text can be represented in this form where si is a keyword and gi is the gap between two keywords. in this paper  we focus on the following type of applications:  1  the order of the symbols may not be important   1  but the gap between two symbols is important. there exist other applications where the order is important and/or the gap is not important. we will not investigate these problems in this paper.
　due to the mutation noise and permutation in these sequence data  the traditional sequential pattern model may not work. however  a key observation on sequences in these applications is that: although the order of pattern symbols might be permutated  the positions of pattern members still remain close in those sequences where the pattern occurs. for example  in genomes  especially prokaryote genomes  functionally related genes tend to be physically clustered  i.e.  they appear proximate in genomes  1  1 . for another example  genes in one operon are controlled as a single unit and they work together. in text documents  certain words may co-appear in many sentences  while their order slightly changes. for example  one news article may say  google bought youtube   while another article says  youtube was acquired by google . then {google  {buy  acquire}  youtube} represents a common pattern between these two documents  although they do not appear in the same order in two articles  and one article uses  buy  while the other uses  acquire  which is a synonym of  buy . this type of pattern is useful in text clustering and classification.
　based on the above observation  the mutable permutation pattern model is proposed in this paper. to represent the mutation of sequence symbols  each position in a pattern is a mutable set. a mutable set can be one single symbol or a set of symbols that are mutually interchangeable. in text mining  these mutable sets can be obtained from a dictionary such as wordnet . for example  {gas  gasoline} could be a mutable set. in genome analysis  mutable sets can be computed by sequence similarity .
　since in our problem the order of symbols is permutated  we loosen the definition of patterns to allow symbols in a pattern to occur in any order in sequences  as long as they occur in close enough proximity. the mutable permutation pattern  or permutation pattern for short  is a pattern whose member symbols could appear in any order in sequences  as long as they keep physical proximity. the advantage of the permutation pattern model over the traditional sequential model is that the permutation pattern model can capture not only the total order of symbols but also the permutated order of symbols.
　this problem is not a simple association ruleapriori-based algorithms mining problem because of the proximity constraints applied on the patterns. due to the loose definition of mutable permutation patterns  the apriori property for the sequential patterns does not hold. this is further explained in a later section. therefore  the apriori-based algorithms cannot be directly applied to mining permutation patterns. we invented a novel permu-pattern algorithm to discover frequent permutation patterns from large sequence databases. instead of using the apriori property  a reachability property is identified to prune the candidate set for frequent permutation patterns. the permu-pattern algorithm is not a level-wised apriori algorithm since it does not grow from short patterns to longer patterns and does not utilize the apriori property. the advantage of the reachability property and the permu-pattern algorithm comes from their pruning power which can reduce the size of candidate set significantly.
　the remainder of this paper is organized as follows. a brief survey of related work is given in section 1. the model of mutable permutation patterns is proposed in section 1. section 1 describes the permu-pattern algorithm in details. the experimental results are presented in section 1. then we discusse the settings and possible improvements of our model in section 1. finally  section 1 draws the conclusion.
1. related works
　sequential pattern mining  1  1  1  1  1  1  has been an active research area in the data mining community for years. the problem was first introduced by the authors of   and two algorithms  aprioriall and apriorisome were proposed in . gsp  was another apriori-based algorithm for sequential pattern mining which integrated a time-constraint and taxonomies. although  introduced a time-constraint and knowledge of taxonomies  the apriori property still holds  which was different from the problem in our paper. prefixspan described an algorithm to mine sequential patterns by prefix-projected pattern growth. spade  was an algorithm proposed to find frequent sequences using efficient lattice search techniques and simple joins. in   the authors outlined a more general formulation of sequential patterns  and developed a modification of the gsp algorithm  to discover universal sequential patterns. recently  introduced a parallel algorithm to mine closed sequential patterns on a distributed memory system. however  all the above works require that the database is clean and neither mutation noise nor permutation exists  which is very different from the problem in this paper. the model proposed in  took into account the mutation among sequence symbols  but it still did not consider the permutation noise in sequences.
　mining sequential patterns with constraints has received much attention in different angles.  proposed regular expressions as constraints for sequential pattern mining and developed a family of spirit algorithms.  systematically studied the problem of pushing various constraints into sequential pattern mining. in addition  an efficient algorithm  prefix-growth  was developed to mine sequential patterns with prefix-monotone constraints. in   the frecpo algorithm was proposed to mine frequent closed partial orders from large sequence datasets. however  the problem of mining sequential patterns in our paper is more complex than these proposed works: first the proximity constraint must be observed; second  the existence of mutation noise and permutation makes their models insufficient to capture the intrinsic characteristics of data. on the other hand  sequential pattern mining for biological sequences has been explored by authors of . a new sequential pattern model was proposed to treat a pattern as a list of segments. a scalable algorithm was devised for mining these patterns from general biological sequences. but their model is still unable to handle mutation noise and permutation noise in biological sequences  and thus fails to generate more meaningful results.
　given k permutations of n elements  in   the authors defined a common interval as a k-tuple of intervals of these permutations consisting of the same set of elements. it presented an algorithm that finds in a family of k permutations of n elements all k common intervals. the authors of  introduced a similarity measure for permutations  based on the concept of conserved intervals. related genes often appear in each other's neighborhoods on the genome  however the order of the genes may not be the same.  addressed the problem of automatically discovering such gene clusters. in   the authors presented a gene cluster model based on common intervals that includes the notion of paralogous genes and regions of internal duplication.  presented a new tool for presentation and detection of gene clusters in multiple genome  using pq trees. however  none of these directly solved the problem of discovering mutated permutation sequential patterns.
1. problem definition
　in this paper  we are interested in discovering patterns from a sequence database in which both the permutation noise and the symbol mutation noise exist. we assume that a sequence is an ordered list of symbols along with their positions in the sequence  which can be represented as {s1 g1 s1 g1 ... gl 1  sl}  where si are symbols at the sequence  and gi are the gaps between symbols si and si+1. a sequence database is therefore a set of such sequences. how we transform sequences in different applications is discussed in a later section.
　in addition  we assume that there is a symbol similarity matrix indicating which symbols are similar. symbols with high similarity are likely to mutate in sequences. this similarity matrix can be obtained in different ways for different applications. for example  in text mining  the word similarity matrix can be constructed from dictionaries or lexical databases such as wordnet . in biological sequence analysis  the gene similarity matrix can be constructed by sequence similarity via blast  or other tools. currently  the cog database  with a large number of orthorlogs  mutation sets of genes  is publicly available. to handle this mutation noise in sequences  we define the mutable symbol set in our model as follows:
　definition 1. a mutable symbol set  or mutable set for short  is a non-empty set of mutually mutable and exclusive symbols.
　once the symbol similarity matrix is obtained  the mutable symbol sets can be easily derived by setting a similarity threshold. a mutable symbol set can consist of a single symbol or a set of symbols. the mutable set {police  cop} means that the words police and cop are synonyms and thus interchangeable. if a mutable set contains only one symbol  it means that this symbol is not mutable to any other symbol. for example  the mutable set {politics} indicates that the word politics has no synonyms. one symbol could belong to multiple mutable sets  e.g.  a word could have different meanings.
　in the traditional sequential pattern model  a sequence is said to support a pattern only when the total order defined by the pattern is contained by the total order defined by the sequence. however  in the problem studied in this paper  we are interested in finding groups of symbols appearing in close proximity to each other in many sequences. the exact order is not important since the order of symbols in sequences can be permutated by noise. to address this problem  the concept of mutable permutation pattern is introduced in our model. the mutable symbol set serves as the basic building block of mutable permutation patterns.
　definition 1. a mutable order-permutation pattern  or permutation pattern for short  is a collection of mutable symbol sets and in the format pp = {msi|1 ＋ i ＋ m}  where msi are mutable sets. the number of mutable sets in a permutation pattern  m  is called the length of the permutation pattern. an unordered symbol set {si|1 ＋ i ＋ m} is called an unordered instance of pp if si （ msi for every i 1 ＋ i ＋ m . an ordered symbol set  si|1 ＋ i ＋ m  is called an ordered instance of pp if si （ msi for every i 1 ＋ i ＋ m .
　example 1: pp = {{s1} {s1 s1} {s1}} is a permutation pattern  which contains three mutable sets: {s1}  {s1 s1} and {s1}.
pp has two unordered instances: ipp1 = {s1 s1 s1} and ipp1 = {s1 s1 s1}.  s1 s1 s1  is an ordered instance of pp  because it is a permutation of ipp1. pp along with all unordered instances and ordered instances of pp are illustrated in figure 1. we use {} to represent an unordered instance and     to represent an ordered instance.
　here we use mutable sets other than symbols as building blocks of the permutation pattern due to: 1. in certain context  symbols across sequences only appear in the form of mutable sets. individual symbols will not appear in multiple sequences. for example  in genomes  genes across species are all different  but orthologous gene groups exist among species. 1. in some context  individual symbols are not frequent while their mutable sets are. for example  a word in a document may not be frequent while its synonyms are frequent across multiple documents.

figure 1: example permutation pattern
　definition 1. a sequence s=  s1 g1 s1 g1 ... gl 1  sl  supports a mutable permutation pattern pp = {msi|1 ＋ i ＋ m} if
and only if there exist integers j1 j1  ... jm  such that
  a subsequence of s  ssub =  sj1  sj1  ...   sjm   is an ordered instance of pp.
  for every  where tgap is a pre-defined value called the gap threshold.
　we call a pattern a frequent permutation pattern if at least tsup sequences in a sequence database support this pattern. tsup is called the support threshold.
　that is to say  if in a sequence there exist m positions  where m is the length of a permutation pattern  the symbols at these positions in the sequence form an ordered instance of the permutation pattern  meanwhile in this sequence the distance between any two consecutive symbols of these m symbols is no larger than the gap threshold tgap  then this sequence is said to support the permutation pattern. here the proximity constraint is imposed on the gap between two consecutive pattern members  rather than the gap between the first and last pattern members. this is because the number of members in a pattern is always unknown. applying the proximity constraint on successive pattern members allows us to find longer patterns which are often more interesting.
　example 1: given a permutation pattern pp = {{s1}  {s1 s1}  {s1}} and tgap = 1  then sequence s1 = {s1  1  s1  1  s1  1  s1} supports pp  because s1 contains an ordered instance of pp:  s1 s1 s1  as a subsequence  and the gaps between s1 and s1  s1 and s1 are both below 1. however sequence s1 =  s1  1  s1  1  s1  1  s1  does not support pp because the distance between s1 and s1 is 1  which is larger than tgap.
　definition 1. a mutable permutation pattern pp1 is a superpattern of another permutation pattern pp1 if the mutable sets in pp1 are super-sets of the mutable sets in pp1.
　example 1: permutation pattern pp = {{s1}  {s1 s1}  {s1}} is a super-pattern of pattern pp1 = {{s1}  {s1}}  but is not a superpattern of pattern {{s1}  {s1 s1}  {s1}}.
　definition 1. a mutable permutation pattern pp is called a maximal frequent permutation pattern if pp is frequent as defined in definition 1 and any of its super-patterns is not frequent.
　problem statement: given a support threshold tsup and a gap threshold tgap  we want to find all maximal frequent mutable permutation patterns in a sequence database.
1. the permu-pattern algorithm
　in this section  we propose the permu-pattern algorithm to solve the problem of finding maximal frequent mutable permutation patterns. as we mentioned earlier  the apriori property for frequent sequential patterns and association rule mining does not hold for the permutation patterns. for example  given a sequence database s1 =  a 1 c 1 b  and s1 =  b 1 c 1 a . if the support threshold tsup = 1 and the gap threshold tgap = 1  then {a b} is not a frequent mutable permutation pattern due to the fact that the gaps  distance  in two sequences are both larger than tgap. however  its superset {a b c} is a frequent permutation pattern because c appears in between a and b in every sequence and the gaps between them are below the gap threshold. therefore  instead of using apriori-based algorithms  we need to develop a new algorithm to discover the frequent permutation patterns.
　in theory  any combination of mutable sets can be a candidate for frequent permutation patterns. if we enumerate all candidate patterns by combining any mutable sets  a set enumeration tree can be built. then we can systematically search the set enumeration tree for frequent permutation pattern. however in the set enumeration tree the number of candidates grows exponentially with the number of the mutable sets. thus  the exhaustive search of the set enumeration tree is not efficient or even not possible when the number of mutable sets is large. therefore  we device a novel technique to prune the candidates. at a high level  the pruning process removes candidates that is definitely not frequent. the following observations can help us to prune the candidates for a frequent pattern.
1. in a frequent permutation pattern  every single mutable set hasto be frequent. if a mutable set contains more than one symbol  each symbol could be infrequent  but the aggregated frequency of the mutable set has to be above the support threshold.
1. if a frequent permutation pattern occurs in a sequence  for anytwo mutable sets of this pattern  there are two cases:  1  the gap is no larger than the gap threshold;  1  there are other mutable sets of this pattern that appear in-between these two mutable sets  and any two consecutive mutable sets of these in between mutable sets satisfy the gap constraint. for example  in the above example  mutable set c appears in between a and b in two sequences. although the gaps between a and b are always larger than the gap threshold  a and b still can be in a frequent permutation pattern: {a b c}.
　based on these observations  a reachability property is identified to facilitate the discovery of permutation patterns by pruning the candidate set. only two scans of the database are needed to store information of the database in a data structure called  reachable cases . all pruning and verification processes are conducted on this data structure.

figure 1: flowchart of the algorithm
　the flowchart of the permu-pattern algorithm is given in figure 1. three main phases of the permu-pattern algorithm are explained in details with a running example. the example sequence database is as below:
s1 =  s1  s1  s1  s1  s1  s1  s1 =  s1  s1  s1  s1  s1  s1 
s1 =  s1  s1  s1  s1  s1  s1 
　{s1 s1} is a mutable set and every other symbol is in a mutable set containing only the symbol itself. the support threshold tsup is set to 1 and tgap is 1.
1 scanning for frequent mutable sets and reachable cases
　in the first phase of our algorithm  two scans of database are conducted. with the first scan  the frequency of every mutable set in the sequence database is collected. if a symbol belongs to multiple mutable sets  its occurrence counts for all of them. infrequent mutable sets  which will not participate in a frequent permutation pattern  can be pruned after the first scan.
　running example: after the first scan of the example database  the support of each mutable set is collected as in table 1.
　since {s1} only occurs in one sequences s1 and the tsup is 1  {s1} can be pruned as an infrequent mutable set. now mutable sets {s1}  {s1}  {s1  s1}  {s1} and {s1} are kept and may serve as members of frequent permutation patterns.
{s1}{s1}{s1  s1}{s1}{s1}{s1}111table 1: support of each mutable set
　next we define the terms of  reachable  and  reachable case  based on the given gap threshold tgap.
　definition 1. in a sequence s =  s1  g1  s1  ...  gl 1  sn   symbols si and sj  1 ＋ i   j ＋ n  are said to be reachable  if one of the following two cases happens:
  which means the gap between si and sj is no larger than tgap. we say si and sj are directly reachable.
  si and sj are not directly reachable but there exist integers m1  m1 ... mp  1 ＋ i   m1   m1 ...   mp   j ＋ n  such that for every q  1 ＋ q   p   symbols smq and smq+1 are directly reachable. meanwhile symbols si and sm1 are directly reachable  and symbols smp and sj are directly reachable. symbols sm1  sm1 ... smp are called the intermediate set of si and sj. we also say si and sj are reachable through sm1  sm1 ... smp.
　two mutable sets ms1 and ms1 are said to be reachable in a sequence if there exist s1  s1 （ ms1   s1  s1 （ ms1   and s1  s1 are reachable in this sequence.
　a reachable case is thus a case in which two mutable sets are reachable through some mutable sets in certain sequence. the reachable case  the two end mutable sets  their intermediate set and the sequence id in which it occurs will be recorded.
　the second scan of the sequence database records all reachable cases in all sequences. the pseudo-code of scanning database for reachable cases is given in algorithm 1:

algorithm 1 scan for reachable cases
input: the gap threshold: tgap and a set of sequences: seqs output: a set of reachable cases: globalcases
1: globalcases ○ empty
1: for s （ seqs do
1:	tempcases ○ empty
1:	last symbol ○ null
1:	for1: 1:	gap ○ k=symbol 	 1 gk
if symbol is in an infrequent ms or gap   tgap then1: 1:elsetempcases ○ empty1:for1:
1:
1:gap ○	 	 1 gk if
create a new case by extending case1:add new case to globalcases1:add new case to tempcases1:end if1:end for1:create a new case for symbol and last symbol1:add new case to tempcases1:add new case to globalcases1:end if1:	last symbol ○ symbol
1:	end for
1: end for
1: return globalcases　runningexample: let us use sequence s1 in the example database as an example  s1 =  s1  1  s1  1  s1  1  s1  1  s1  1  s1 . if tgap is 1  then s1 and s1 are reachable directly  since the distance between them is 1. due to the same reason s1 and s1 are reachable as well. meanwhile this makes s1 and s1 satisfy the second case of definition 1; thus s1 and s1 are reachable through s1. in addition  s1 and s1 also directly reachable since their distance is 1  satisfying the first case of definition 1. however  s1 and s1 are not reachable because their distance is larger than tgap. figure 1 shows all reachable cases in this sequence.
	s1:    s1	s1	s1	s1	 s1	s1
	1	1	1	
t gap = 1    1 reachable cases: s1     s1
         s1
s1     s1     s1
         s1
s1     s1
s1     s1
	s1     s1
figure 1: reachable cases in a sequence
　for each pair of mutable sets  we only record any intermediate set once and its associated sequence ids where the reachable case occurs. this saves the memory space to store the duplicate intermediate sets. for instance  {s1} and {s1} are reachable directly in all three sequences. the empty set {} is recorded as an intermediate set of pair {s1} and {s1}  and {s1 s1 s1} is recorded as the sequence ids in which it occurs. meanwhile  in sequence s1  symbols {s1} and {s1} are also reachable through {s1}. thus {s1} is recorded as an intermediate set and {s1} is the sequence id. all reachable cases recorded are illustrated in table 1 in a tabular form. note that infrequent mutable sets pruned in the first scan will not appear in any reachable case  thus reducing the number of reachable cases.
1 pruning
　at this phase  we prune the set of reachable cases. first we give the definition of  instance sequence   then the observations stated earlier can be expressed using the definition of  reachable  and  instance sequence .
　definition 1. if a sequence supports a frequent permutation pattern  we call this sequence an instance sequence of the permutation pattern.
　in an instance sequence of a frequent permutation pattern  any two mutable sets of the pattern are reachable either directly or through the mutable sets of this frequent permutation pattern.
　based on this observation  a reachability property for frequent permutation patterns can be identified as follows:
　property 1. any pair of mutable sets from a frequent permutation pattern  say pp  have to be reachable in at least tsup number of sequences. and in every instance sequence of pp  any pair of mutable sets from pp are reachable using only other mutable sets from pp as the intermediate set.
　proof. the proof comes directly from the definitions of reachable and permutation patterns. assume two mutable sets msi and msj are in a frequent permutation pattern  say pp. according to the definition of frequent permutation patterns  pp occurs in at least tsup sequences. a permutation pattern's occurrence in a sequence implies that in this sequence  msi and msj are reachable either directly or through some mutable sets from pp. therefore  in these tsup sequences  msi and msj are reachable through mutable sets in pp only. 
　armed with the reachability property  we can prune the set of candidate patterns as follows. first we can identify some mutable set pairs that are reachable in less than tsup sequences using any mutable set as intermediate sets  then these mutable set pairs cannot be in a frequent permutation pattern. this pruning is based on the first portion of the reachability property. moreover  we can use these pruned pairs to further prune the remaining possible pairs. the following lemma is derived to support this pruning step.
　lemma 1. if in one sequence  two mutable sets from a frequent permutation pattern  e.g. pp  are only reachable through certain mutable set which does not belong to pp  then this sequence cannot be an instance sequence of the permutation pattern pp.
　proof. we prove it by contradiction. in one sequence  two mutable sets ms1 and ms1 in pp are only reachable through ms1 and ms1 does not belong to pp. assume that this sequence is an instance sequence of pp. according to the reachability property  in an instance sequence of a frequent permutation pattern  any two mutable sets of the frequent permutation pattern should be reachable using only other mutable sets in pp as intermediate sets. however  ms1 and ms1 in pp are only reachable through ms1. thus ms1 is a mutable set in pp. contradiction found. 
　the above lemma  which is easy to derive from the reachability property  can be used to prune the number of instance sequences for a candidate pattern. the intuition behind this pruning is: in order to confirm two mutable sets ms1  ms1 are in an frequent permutation pattern pp  we need to identify at least tsup instance sequences of pp. if we know another mutable set ms1 cannot be in a frequent permutation pattern with ms1  and in some sequence ms1 is only reachable to ms1 through ms1  then this sequence cannot be an instance sequence of pp according to the above lemma.
　after pruning the reachable cases  two mutable sets may become reachable in fewer sequences. this may help us to further identify pairs of mutable sets that have no chance at forming a frequent permutation pattern. after identifying these pairs  we conduct the pruning of the reachable cases again since more pairs are known to be unable to form a frequent permutation pattern. this two-way pruning is iteratively conducted until no mutable set pairs can be pruned or no reachable cases can be pruned  as illustrated in the algorithm flowchart  figure 1 .
{s1}{s1  s1}{s1}{s1}{s1}{}: s1  s1  s1null{}: s1  s1null{s1}: s1{s1}null{}: s1null{s1}: s1{s1  s1}{s1}: s1{}: s1  s1 {s1}: s1{}: s1  s1{s1}{}: s1  s1table 1: all reachable cases
　running example: first we prune mutable set pairs that are not reachable in enough sequences. according to table 1  {s1} and {s1} are not reachable in any sequence  thus they cannot be in a frequent permutation pattern. for the same reason  the pairs  {s1}  {s1  s1}    {s1}  {s1  s1}  and  {s1}  {s1}  cannot be in any frequent permutation pattern. in addition  {s1} and {s1} are only reachable in two sequences  which is less than tsup. therefore  {s1} and {s1} cannot form a frequent permutation pattern either. the pairs  {s1}  {s1}    {s1  s1}  {s1}  and  {s1}  {s1}  are also pruned through the same reasoning.
　next we use the mutable set pairs pruned in last round to prune reachable cases. first we look at the upper-left cell  which records the reachable cases between {s1} and {s1}. we already know that {s1} and {s1} cannot be in a frequent permutation pattern  thus the second row of this cell  which indicates {s1} and {s1} are reachable through {s1} in sequence s1  can be pruned. then we examine the reachable cases between {s1  s1} and {s1}. now they are reachable in three sequences  however  we know that {s1} and {s1} cannot be in a frequent permutation pattern  thus the reachable case in which {s1  s1} and {s1} are reachable through {s1} can be pruned. after this pruning  {s1  s1} and {s1} are only reachable in two sequences  which is below the support threshold. therefore  all reachable cases for the pair {s1  s1} and {s1} can be pruned. till now no reachable cases or mutable set pairs can be pruned.
1 final verification
　in the last verification step  for each remaining reachable case  we sort the mutable set labels by their lexical order. by sorting mutable set labels  we can transform the different permutations of a pattern into a single unique representation. for example  the case that mutable set ms1 is reachable to ms1 through ms1 and the case that ms1 is reachable to ms1 through ms1 are both transformed to the same list ms1ms1ms1. now we count the number of sequences that each list occurs in by traversing all reachable cases. if a list of mutable sets occurs in tsup sequences  then these mutable sets form a frequent permutation pattern.
   running example: after the pruning in the third step  the following reachable cases are kept:
case 1: {s1} and {s1} are reachable directly in s1 case 1: {s1} and {s1} are reachable directly in s1 case 1: {s1} and {s1} are reachable directly in s1
　after sorting all mutable set labels in each case  we only have one sorted list  {s1}  {s1} . we know that this list occurs in three sequences by a traversal of all reachable cases. this means that {{s1}  {s1}} qualifies as a frequent permutation pattern.
1 data structure for reachable cases
　to facilitate the pruning process  instead of using a linear list to store all reachable cases  we use a multiple-level hash table. the first level is the starting mutable set of a reachable case  the second level is the ending mutable set  and the third level records the intermediate sets for each reachable case. the hash table at the third level could be pointed by multiple second level pointers  since we only store each intermediate set once. an illustrative hash map is shown in figure 1  which records two reachable cases of ms1 and ms1  one is through ms1 and ms1 and the other is through ms1  ms1 and ms1.
ms1 ms1 ms1 ...

	ms1 ms1	ms1 ms1 ms1
figure 1: hash table for reachable cases
　by this data structure  after pruning a pair of mutable sets that cannot participate in the same frequent pattern  rather than scanning all reachable cases again  we can quickly index the reachable cases that contain either one of the pruned mutable set pair. only these reachable cases might be pruned due to the removal of the pair. therefore  after pruning any pair  only a small portion of the reachable case set is examined  and the support of each pair is updated simultaneously  which makes the pruning step rather efficient.
1 correctness and complexity analysisof algorithm
　in this subsection  we analyze the correctness and complexity of our algorithm. due to space limitations  we omit the formal correctness and complexity proof of our algorithm. interested readers should refer to  for the formal proof. we will outline the proof as following. first  we prove that our proposed algorithm will not miss any frequent permutation pattern. note that there are actually two types of pruning conducted iteratively during the pruning process. one is to prune the mutable set pairs that cannot be in a frequent pattern segment  the other one is to prune the sequences that cannot be an instance sequence of a frequent pattern segment. we then prove that the two types of pruning will not prune any frequent permutation pattern.
　for the first pruning  we prune mutable set pairs that are not reachable in at least tsup sequences. according to the reachability property  in all instance sequences of a frequent permutation pattern  any pair of mutable sets in this pattern segment is reachable. therefore  the mutable set pairs we pruned cannot be in any frequent permutation pattern  which indicates that this pruning preserves all mutable set pairs in all frequent permutation patterns. for the latter pruning  to decide whether a mutable set pair is in a frequent permutation pattern  we prune reachable cases in which this mutable set pair is only reachable through some mutable set that is known not to be in a frequent pattern segment with either one of the mutable set pairs. according to lemma 1  any such reachable case cannot be an occurrence of a frequent permutation pattern containing the mutable set pair. thus we do not prune any instance sequence of any frequent permutation pattern containing this mutable set pair. if this mutable set pair is in a frequent permutation pattern  we still can identify all instance sequences after this pruning. thus we will not miss any frequent permutation patterns.
　in the worst case  the pruning may not reduce the number of candidate patterns significantly. thus  in theory  the worst case time complexity still could be exponential with respect to the length of a sequence. however  in many real data sets  the pruning process reduces a large number of candidate patterns. for the real data sets used in the next section  our algorithm prunes more than 1% candidate patterns.
1. experimental results
　in this paper we implemented the permu-pattern algorithm in c++ using stl standard template libraries . all experiments were run on a linux pc with a 1 ghz pentium-1 processor and 1gb main memory. we use both real and synthetical data to analyze the performance of the permu-pattern algorithm.
　first  to illustrate the usefulness of the permutation pattern model  we use the permu-pattern algorithm to discover gene clusters from genomes of different species. a gene cluster is a frequent permutation pattern whose members are genes in genomes. the discovered gene clusters are interpreted by biologists to show that the permutation pattern model can reveal important biological themes hidden in genomes  thus the permu-pattern model is of great use in comparative genome analysis.
　second  we use different synthetic datasets to evaluate the performance of our permu-pattern algorithm. two other approaches are compared with our permu-pattern algorithm. the first approach is the π pattern discovery algorithm .the other method is adapted from the set enumeration tree search . first the sequence database is scanned for dense segments  which are sequence segments in which the first and last symbol are reachable. then we enumerate all candidate patterns formed by symbols in these segments. a set enumeration tree can be built and searched for frequent permutation pattern. the size of the set enumeration tree is bounded since the maximal number of symbols in a candidate pattern can not exceed the maximal size of a dense segment.
1 effectiveness of the permutation pattern model
　in this section  we present the experimental results on the genome dataset to demonstrate the usefulness of the permutation pattern model. 1 genome sequences of 1 species are downloaded from the ncbi  national center for biotechnology information  website. each genome contains thousands of genes along with their positions at the genome. genes are classified into cluster of orthologous groups  cog   which are delineated by comparing protein sequences from completely sequenced genomes. genes within a cog are considered as mutable  thus the cogs form the mutable sets. genes that are not in any cog are considered non-mutable. the average number of genes in these 1 genomes is 1  and there are 1 cluster of orthologous groups containing more than one gene.
　in this experiment  the gap threshold tgap is set to 1 . when the support threshold tsup is set to 1  1 maximal frequent gene clusters can be discovered in less than 1 seconds. table 1 is a summary of experimental results on different support thresholds.
tsup11# of patterns11max. length11ave. length111discovery time1 s1 s1 stable 1: results on genome dataset
　to show the usefulness of the permutation pattern model  we analyze the results by interpreting the biological meanings of discovered patterns gene clusters . roughly speaking the discovered gene clusters represent several biological themes:
  subunits of multi-unit proteins  e.g. ribosomal complex  transcription factors   which form physical complexes.   operon components  which form a physical complex or a biochemical network
  signal transduction components  which form loose complexes on cell membrane or biochemical networks.
  de novo amino acid synthesis
　on the other hand  we compare the results of our model against the traditional sequential pattern model. since the order of genes is permuted during evolution in genomes of different organisms  our permutation pattern model is able to identify more and longer patterns. table 1 shows that the average and maximal lengths of discovered permutation patterns are larger than those of the traditional sequential patterns.
　in addition  when the support threshold is set to 1  the sequential pattern model missed 1 patterns  1%  found by the permutation pattern model  1 out of which are linked to various biological themes. in addition  1% of the discovered sequential patterns are also found by the permutation pattern model  but with greater
tsup11average lengthpermu-pattern111sequential111maximum
lengthpermu-pattern11sequential11table 1: pattern length comparison
lengths. a large portion of patterns missed by the traditional sequential pattern model actually have important biological meanings. for example 
  one gene cluster {cog1 cog1 cog1 cog1 cog1 cog1} reflects a sub-unit of a ribosomal protein. this gene cluster was discovered by the permu-pattern model  but was found by the traditional sequential pattern model. cogs in this gene cluster appear in different order in every genome  while still keeping proximity.
  the other gene cluster {cog1 cog1 cog1 cog1 cog1 cog1 cog1 cog1 }  which is discovered by the permu-pattern model  forms an atp synthase chain. membrane-bound atp synthases  f1-atpases  of bacteria serve two important physiological functions. the atp synthase of escherichia coli  which has been the most intensively studied one  is composed of eight different subunits  five of which belong to f1  subunits alpha  beta  gamma  delta  and epsilon  1:1:1   and three to f1  subunits a  b  and c  1:1 +/- 1  . our permu-pattern model successfully discovered all eight sub-units. however only shorter segments of this gene cluster  e.g. {cog1  cog1  cog1}  were discovered by the sequential pattern model.
1 efficiency of the algorithm
　to further analyze the efficiency of our permutation pattern discovery algorithm  two alternative methods are compared to our permupattern algorithm. the efficiency of the set enumeration tree method is highly dependent on the length of the dense segments in the sequences. if the dense segments are long and contain many different symbols  the set enumeration tree could be very large. this could render the search for frequent sets very inefficient.
　first we compare the performance of the permu-pattern algorithm on the real genome data set against the two other methods. table 1 shows the execution time for three algorithms to mine frequent permutation patterns from 1 genomes under different settings of the support threshold. the permu-pattern are faster than the other two algorithms in every scenario.
tsup11permu-pattern1 s1 s1 sπ pattern1 s1 s1 sset-enumeration1 s1 s1 stable 1: efficiency on genome dataset
　next we utilize a large set of synthetic data to further analyze the scalability of our algorithm. a sequence generator is written in perl to generate sequences of various scales. first an arbitrary gap threshold tgap is defined  then the synthetic data is generated according to the following parameters: the average number of symbols in a sequence l  and the number of sequences s  and the number of mutable sets m.
　a series of experiments were conducted on synthetic data to compare the performance  efficiency  of the permu-pattern algorithm against the two other alternative methods. in these experiments  the default parameters are as below: the average number of symbols in a sequence l is 1  the number of sequences s is 1  and the number of mutable sets m is 1. we also set the support threshold to 1% of the total number of sequences. the experimental results show that the permu-pattern algorithms outperforms other approaches by a wide margin.

                             figure 1: scalability on l  the figure 1: scalability on tsup  average number of symbols in a the support threshold sequence
　first we evaluate the performance with respect to the support threshold tsup. figure 1 shows the average execution time of three algorithms with respect to tsup. although the response time of the permu-pattern algorithm and the set-enumeration algorithm both reduce linearly with the increase of tsup  the response time of the permu-pattern algorithm drops at a faster pace than that of the setenumeration approach for the following reason. with the increase of tsup  more mutable sets will be pruned during the first scan of sequence database  and fewer reachable cases will be recorded for further pruning. thus the permu-pattern algorithm is much more scalable than the set-enumeration algorithm as tsup decreases.
　the second aspect that we investigate is the scalability with the average number of symbols in a sequence l. with the increase of l  more dense segments could be discovered for the set-enumeration algorithm  which makes both algorithms be inefficient. the empirical results from figure 1 have shown that the time complexity of the permu-pattern algorithm is linearly proportional to l  while the execution time of the two other algorithms increase at much faster rates.
　third  we study the effects of the number of sequences s on the mining results. as seen in figure 1  s has similar effects on three algorithms as the average length of sequences l. the permu-pattern clearly benefits from the pruning power of the reachability property.

figure 1: scalability on s  figure 1: scalability on m  the number of sequences the number of mutable sets
last  we examine the response time with varying numbers of mu-
table sets m. the increase of the number of mutable sets has a similar effect on all three algorithms since a similar approach is used to handle the mutable noise in these algorithms. however  in every case the permu-pattern algorithm outperforms the two other.
1. discussion
　in this section  we discuss the settings of the permu-pattern model in different contexts and some possible improvements to the model. first  there is some difference in the setting with respect to the gap between sequence symbols. in biological sequences  the gap between two genes can be computed by counting the number of base pairs from the end of first gene and the start of second gene. by ignoring the length of genes  we can transform genome sequences into the format defined in section 1. in text mining  the gap between two words can be defined as the number of words between them. a situation in which gaps between two successive words are below the gap threshold can be avoided through the following methods: 1. removing stopwords from the documents when transforming a document into a sequence  while still counting the stopwords as gaps; and 1. treating certain types of punctuation as large gaps. for example  a period can be treated as a gap larger than the gap threshold.
　the settings of two parameters: tgap and tsup can be decided by the application domain. for example  in genome analysis  the gap threshold can be set to 1 base pairs  which is indicated by  to define the term  close  between genes. in text mining  the gap distance can be set to the average length of a sentence. the support threshold tsup is usually set by a domain expert to define what is considered significant in a specific domain. for instance  in genome analysis  tsup is often set to 1% of the total number of genomes.
　the discovered permutation patterns can be ranked based on their significance or the degree of their mutation and permutation. when the mutable sets are built from the symbol similarity matrix  the centers of each mutable set can be selected. the centers of mutable sets can be considered as non-permuted true  symbols. numerical scores computed from the distance between other symbols and the non-permutated symbols can serve as a permutation measure when computing the support of a mutable set. for example  in mutable sets {s1 s1 s1}  if s1 is the non-permutated symbol  then we can compute the distance between s1 and all other symbols in the mutable sets  represented for instance as {1.1.1}. if s1 appears in a sequence  the permutation score 1 can be used to compute a permutation support of the mutable set. the discovered patterns can be ranked according the mutation and permutation in those patterns.
1. conclusion
　in many applications  such as bioinformatics and text mining  sequence databases often contain different types of noise. the existence of the symbol mutation noise and the permutation noise makes the traditional sequential pattern model inadequate to capture useful patterns in these data. in this paper  we are interested in finding a new type of patterns  called mutable permutation patterns  in such noisy environments. the mutable permutation pattern model is proposed to capture the characteristics in sequential data. a reachability property is identified for the permutation pattern  based on which  a novel permu-pattern algorithm is devised to efficiently mine the permutation patterns. we applied our model on the genome dataset of 1 species to discover gene clusters. the results show that the discovered gene clusters represent various important biological themes  which proves the practical importance of the permutation pattern model. lastly  a large set of synthetic data is used to demonstrate that our permu-pattern algorithm outperforms other alternative approaches by a wide margin.
1. acknowledgement
　this work was partially supported by the grants from nsf-1  nsf-1  and the case presidential research initiative award.
