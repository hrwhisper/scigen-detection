in applications such as paleontology and medical genetics the 1 data has an underlying unknown order  the ages of the fossil sites  the locations of markers in the genome . the order might be total or partial: for example  two sites in different parts of the globe might be ecologically incomparable  or the ordering of certain markers might be different in different subgroups of the data. we consider the following problem. given a table over a set of 1 variables  find a partial order for the rows minimizing a score function and being as specific as possible. the score function can be  e.g.  the number of changes from 1 to 1 in a column  for paleontology  or the likelihood of the marker sequence  for genomic data . our solution for this task first constructs small totally ordered fragments of the partial order  then finds good orientations for the fragments  and finally uses a simple and efficient heuristic method for finding a partial order that corresponds well with the collection of fragments. we describe the method  discuss its properties  and give empirical results on paleontological data demonstrating the usefulness of the method. in the application the use of the method highlighted some previously unknown properties of the data and pointed out probable errors in the data.
categories and subject descriptors
h.1  information systems : data mining
general terms
algorithms
keywords
partial order  hidden ordering  consecutive ones property
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
kdd'1  august 1  1  chicago  illinois  usa.
copyright 1 acm 1-1-x/1 ...$1.
mannila cs.helsinki.fi
1. introduction
모the prototypical examples of data mining include the analysis of large masses of 1 data. the typical assumption for such data is that there is no underlying order or partial order for the attributes  variables  columns  or for the observations  rows . this assumption is at least approximately true in many applications  such as market basket analysis  where it is difficult to assume that the variables  items people buy  would have any clear ordering. likewise  for market basket data the order of the rows might not be very significant.
모however  in many other applications the concept of an underlying ordering of the rows or columns  or both  is extremely important. consider the problem of paleontological data modeling. in such data the columns correspond to species or genera. each row corresponds to a site  i.e.  a collection of fossil remains collected from the same location and the same layer in rock. that is  a site is a  very incomplete  snapshot of the set of species that lived at a certain location at approximately the same time. the ages or evolutionary stages of the sites  rows  form a natural ordering for the sites. this order need not be a total order  as two sites of approximately the same age but widely separated in space might not be comparable. the ages of the sites are only rarely known  and the problem of seriation is to find good estimates for the ages or ordering of the sites  1  1  1  1 . for the columns  the species or genera  there is also a natural partial ordering  the evolutionary ordering in which the species arise.
모how could one find the ordering of the sites from the observed presence or absence of genera  in a good ordering species evolve and become extinct  indicating that the occurrences of the species form an interval in the ordering; as we will see  this basic property can be used in finding good orderings. the ordering can be done  e.g.  by using a spectral method  1  1  1  1 . the weakness in these methods is that they produce a total order  regardless of whether the data supports it or not. the method presented in this papers finds the partial order shown in figure 1  which yields much more information about the true evolutionary relationships between the sites and the genera.
모the problem described above is not limited to paleontological applications. similar situations occur also in genome analysis  i.e.  the problem of finding genes that predispose to some specific disease. in this case the rows of the data correspond to markers  i.e.  base pairs in the genome where there is variation between individuals  and columns correspond to individuals. the value at position j of row i tells what is the nucleotide in the genome of person j at the position of the genome corresponding to row i. since typically only two nucleotides occur at a marker  the data can be coded with 1s and 1s. for such data  the ordering of the markers corresponds to the location of the points of variation in the genome. while the locations are fairly often well known  there are situations in which the order is uncertain. for example  part  e.g.  1 %  of the population can have large    1 m base pairs  regions of the genome inverted; this implies that there is no global total order among the markers.
모what data could one use to find the ordering among the rows from such genetic data  the underlying processes producing the variation are mutations and recombinations  and they lead to higher  absolute values of  correlation between markers that are close to each other. this information can be used to obtain good orderings. for this type of data  the question of finding a good partial order comes close to finding a good dependency graph for the variables.
모the two applications described above have the following characteristics in common. first  there is a notion of an underlying partial order among the rows. second  finding the best ordering for the whole set of data is difficult. third  given a small subset of rows  we can find the best ordering for the subset.
모in this paper we give a method for finding good partial orders p from 1 data. the method proceeds in stages. it first constructs a collection of fragments of order  i.e.  small collections of rows for which there is a clear total ordering. this task is done by selecting random subsets of  say  1 rows and testing all the permutations.
모second  we orient the fragments. as the methods for evaluating the quality of an ordering are typically symmetric with respect to ordering p and the reverse ordering pr = {  b a  |  a b  뫍 p }  we next have to divide the set of fragments into two subsets  one corresponding to p and the other to pr. the division is done by using a graph partitioning method: we consider the graph having the fragments as vertices. the weight of an edge between two fragments indicates how many pairs of rows are ordered in the same way in the fragments. we use a simple local search method for finding a reasonably good bisection of the graph.
모the third step in our method is the construction of a partial order from the fragments from one of the classes produced by the previous step. for this we apply a simple greedy algorithm that looks again at all pairs of rows from the data. for each pair  a b  we compute the number of fragments in which a and b occur and a precedes b or b precedes a. if the number of times a precedes b is clearly higher than the number of times b precedes a  then we have evidence for  a b  뫍 p. all such pairs cannot necessarily be added to the partial order  as the order might become cyclic; a greedy approach is used to select the most useful pair to be added.
모we demonstrate the usefulness of our method by applying it to paleontological data. the resulting partial orders provide a very clear overview of the underlying structure of the data set  and the details of the result correspond well with the known eras of the last 1 million years. furthermore  some aspects of the results point out probable errors in the seriation data in existing literature; thus the method for finding partial orders yields useful scientific information. the rest of this paper is organized as follows. we start in section 1 by discussing the motivation for searching for partial orders. we also describe the paleontological application in some more detail  and formally present the problem and describe some simplistic and infeasible methods for solving it. the next three sections describe the three parts of the solution. first  in section 1  we consider the problem of generating small totally ordered subsets of rows. second  in section 1 we consider the question of orienting the fragments by graph partitioning. third  we describe the construction of the partial order from the totally ordered fragments in section 1. empirical results are given in section 1. section 1 is a short conclusion.
1. total and partial orders
모in this section we consider the motivation for finding partial orders from 1 data. let r be the set of attributes  variables  of our 1 dataset. let m be a set of 1 rows over the attributes r. the value at column a of row t is denoted by t a . in our main application the data sets typically have hundreds or thousands of rows; thus quadratic or cubic time is acceptable.
모a partial order on m is a binary relation p such that  t t  뫍 p for all rows t 뫍 m  reflexivity   if  t u  뫍 p then  u t  뫍/ p  symmetry   and if  t u  뫍 p and  u v  뫍 p  then  t v  뫍 p  transitivity . the partial order is trivial  if  t u  뫍 p only if t = u  and p is a total order  if for all u and v either  u v  뫍 p or  v u  뫍 p. partial orders are typically drawn as directed acyclic graphs  where the edges deducible by transitivity are omitted  i.e.  one draws only the edges in the transitive reduction of p . the size of a partial order is the number of ordered pairs it contains and is denoted by |p|.
모as an example  consider paleontological data. recall that the columns correspond to species or genera  and each row corresponds to a site. in a good ordering species evolve and become extinct  indicating that the occurrences of the species form an interval in the ordering. thus  the ordering of the sites below on the left is biologically not as natural as the one on the right.
1	1	1
1	1	1
	1	1	1
1	1	1
1	1	1
on the left side  there are several cases in which a species is first present  then absent  and then present again; for example  in the first column there are two zeros between the ones. such zeros are known as lazarus events. the left matrix has four lazarus events. on the right side  there are none.
모given a total order t on the row set m  the lazarus count of m with respect to t is defined as
.
모that is  the lazarus count of a 1 dataset under a certain ordering of the rows is the number of zeros in the data that are between the first and last ones in their column.
모the question of determining whether for some total order t we have l m|t  = 1  finding an ordering of the rows of a 1 matrix with no lazarus events  is the problem of determining whether a binary matrix has the consecutive ones property. a binary matrix with the rows m is said to have the consecutive ones property if there exists a permutation 뷇 of the rows  such that in 뷇 m  the ones are aligned to consecutive rows on every column. a well known application of this problem is physical mapping of chromosomes   while matrix envelope reduction  is a related problem.
모in the case where l m|t  = 1 for some total order t  the order t can be determined in linear time  1  1 . in practice  however  the data m has l m|t    1 for all total orders t. the reason is that the data contains noise in form of false positives  false ones  and false negatives  false zeros ; especially false zeros  cases where a genus is not observed when it was actually present  are abundant: their number can be about as high as the number of true ones.
모a number of methods  1  1  1  have been proposed for finding good ordering. in general the objective of these algorithms is to find a single total order of the rows that is optimal according to the used criteria. a typical approach is to minimize the number of lazarus events by some means. however  in many cases determining a strict total order is not useful. the available data may be insufficient to yield a precise order on the rows. as an example  consider the following simple matrix with one lazarus event:
1:11:11:11:11:11no permutation would yield a completely error-free ordering  thus this matrix does not have the consecutive ones property. but it is not hard to see that there are two other permutations of the rows that result in one lazarus event as well  namely:
1:111:11:111:11:11and1:11:111:11:111:11every other permutation except the reversals of these three have a higher lazarus count. if we consider the indices of the matrix rows  let the first one correspond to the order  1 1 1 . then the second one is given by  1 1 1  and the third one by  1 1 1 . forcing a total order on the rows of the above matrix by minimizing the lazarus count is thus bound to contain some randomness  since all three orders and their reversals are in fact equally good. for example  spectral ordering  gives  1 1 1  as a solution. there is no reason to prefer this over the two others if the only criteria is number of lazarus events.
모instead of selecting one of the orderings  we can gather all common features of the three orders together and based on these construct a partial order on m. in this example it is relatively easy to see merely by looking at the orders that in each case row 1 precedes and row 1 follows every other row. the order changes only with respect to the three middle rows. restricting our attention to these  we see that in every case row 1 precedes row 1. in this case there are no more common features to be found. these features together form the partial order which is depicted in figure 1 as a directed acyclic graph.
모note that we did not consider the reversals of the three orders when constructing the partial order even though they result in only one lazarus event as well. in general it is not possible to know the correct direction of the order based on the consecutive ones property alone. when constructing the partial order from a set of total orders we must make sure that at least a sufficient number of the orders  point to the same direction . we will address problems caused by this in section 1.

figure 1: a directed acyclic graph that represents the partial order on the rows  their indices  of the example matrix. if there is no path between two nodes then their mutual order is undetermined.
모thus it makes sense to search for partial orders instead of total orders. consider now a partial order p among the rows a 1 matrix with the row set m. the number of lazarus events in m with respect to p can be defined in exactly the same way as for the case of a total order:
.
that is  we count the number of zeros t a  in the data such that there are rows u and v before and after t with respect to the partial order p such that u a  = v a  = 1.
모our problem can now be posed as follows: given the data m  find a partial order p such that l m|p  is small. however  this formulation is incomplete: we can easily make l m|p  to be 1 by having p to be the trivial partial order. thus  our task is to find a partial order p minimizing the quantity
l m|p  + 붸 p 
where 붸 p  is some function of p that is small for total orders and becomes larger as p approaches the trivial partial order. the choice of the function 붸 is an interesting question. some possible choices for 붸 p  are the logarithm of the number of linear extensions of p  computing this  however  is p-complete    or the size of p  which for n rows varies between n for the trivial partial order and n n+1 /1 for a total order.
모finding the optimal partial order p from scratch is  however  quite difficult. there are several reasons for this. one is that individual elements of the partial order p do not have an immediate effect on l m|p ; whether a 1 in the data contributes to l m|p  depends on at least two elements of p. the second reason is that it is not easy to construct a good set of operations that would allow one to do heuristic search over the set of all partial orders. in  the approach used was limited to constructing series-parallel partial orders  and still the set of operations is more complex than one would wish.
모for these reasons we did not develop an algorithm that would directly aim at a search over the set of all partial orders. rather  we construct the partial order by first collecting information about the precedence relationships between rows. we construct a set of fragments  total orders over small subsets of the data  and use the fragments to obtain good partial orders. the quality of the solutions is still evaluated by using  among others  the quantity l m|p .
1. computing fragments
모in the first stage of our algorithm we compute a set of small total orders from the data. given the data m  a fragment f of size k is a totally ordered subset of the rows of m:
f =  u1 u1 ... uk  
where ui is a row of m. such fragments of order were considered in   where an algorithm for discovering fragments from unordered data is presented. the approach is similar to the apriori algorithm  for discovering frequent itemsets. however  generating longer fragments with the method is cumbersome because computation of fragments of length n requires the computation of all fragments of length n 1 first. to obtain enough information about the order we need fragments containing at least 1 rows  as the notion of a lazarus event does not make sense for subsets of 1 rows. in practice the methods work far better when they operate on fragments of  say  1 rows. if there is an underlying total order in the data  there are such fragments  and the algorithm of  would compute all of them; this is clearly infeasible even for moderate values of n.
모the solution we use for generating fragments is simple. we randomly select a subset m containing k rows from the dataset m  and evaluate   for all k! total orders t on m. a fragment is created by a total order t together with the set m when

where 뷃 is the maximum number of lazarus events allowed. one m will thus result in a number of different fragments depending on 뷃. for any 뷃 we will always get an even number of fragments. if we get the fragment f =  u1 u1 ... uk  we will obtain its reversal fr =  uk uk 1 ... u1  as well  since they both have the same lazarus count. should the total number of fragments produced by a subset m be very high  the rows in m fail to provide useful information about the underlying order of the complete dataset. for example  if the sites in m have no common genera  all the k! permutations are equally good with a lazarus count of zero. to prevent massive amounts of such useless fragments being generated  we output the set of fragments produced by m only if it contains at most two  reversals excluded  fragments; otherwise no fragments are produced. this procedure is repeated until the desired number of fragments is obtained.
모the complexity of this step is o k!kd  per fragment  where k is the number of rows in the fragment and d = |r| is the dimension of the data. in practice the running time is influenced by 뷃 as well. when 뷃 is set too low fragments are formed less frequently  or possibly not at all   which results in slower sampling.
1. orienting the fragments
모as stated in the previous sections  using the lazarus count to determine good orderings for the rows has a small drawback. for every discovered fragment f we also find its reversal fr. this problem may occur also with other types of data when the criterion used for sampling fragments is invariant with respect to the direction of the underlying order p. the next task is to divide the set of fragments into two classes  one corresponding to p and the other to the reverse of p. we call this problem orienting the fragments.
모our solution is based on graph partitioning. given a set s of fragments  let g be a weighted graph having as vertices the fragments f 뫍 s. for a fragment f =  u1 u1 ... uk   denote t f  = { ui uj |1 뫞 i   j 뫞 k}  i.e.  the set of pairs of entries occurring in f in their order. two vertices  fragments  f1 and f1 with are connected in g by an edge if they share at least two elements and order them in the same way  i.e.  if . the weight w f1 f1  of edge  f1 f1  is given by |c|. this weight is essentially a measure of similarity between two fragments that simply counts the number of their common orderings. we define w f f  = 1 for all f. obviously there is no edge between f and fr in g. our objective is to partition the vertices of g to sets v1 and v1 so that f and fr end up in different sets  and that fragments in the same set are oriented to the same direction. as a cost function we use the sum
	 	 1 
of weights of edges crossing the boundary of v1 and v1.
모a straightforward way of doing the graph partitioning would be to use some spectral techniques  as in  1  1  1 . an alternative is to use simple local search methods  and in these one can use some specific information about the fragments  f and fr should end up in different sets vi . in our experiments we used a local search technique. the algorithm starts by assigning for each f 뫍 s one of f and fr at random to v1 and the other to v1. then local moves swap f and fr until no improvement can be achieved. this way a fragment and its reversal remain in separate sets at every step.
모the method works extremely well in practice. constructing g can be done in time o |s|1  where k is the length of a fragment.
1. determining the partial order
모the previous sections described the discovery of good fragments of order and the orientation of the orders. the final step in the algorithm is to produce a partial order p  given a set v1 of total orders that are oriented in the same direction.
모in this section we consider the general problem of determining a partial order p that describes the set of total orders in the best possible way. the same problem is addressed in  and more recently in . the approach of  is computationally demanding and restricted on a certain class of partial orders  the series-parallel ones. the method of  is intended for discovering several small partial orders from a set of sequences instead of only one that describes all or most of the set. for our purpose a simple approach is sufficient.
모given a collection v1 of fragments  consider two rows u and v from the data m. let f u v  denote the number of times u and v occur in the same fragment with u preceding v  i.e. 
.
suppose f u v  뫘 f v u . in such a case the data gives no reason to prefer either of the orderings and neither  u v  or  v u  should not be included to p. on the other hand  if f u v  is considerably larger than f v u  the data has more evidence of the order  u v  and we should include  u v  to p. we define the score function
	 	 1 
where   is a positive real valued parameter that determines how much more evidence we must have for f u v  in order to prefer it over f v u .
모our method of discovering p is based on maximizing this function. each pair  u v  with
  u v  = f u v     1 +   f v u    1
is a potential candidate for inclusion into the partial order p. it is not hard to show that in fact all such pairs  u v  are candidates for inclusion for which holds. however  all such pairs cannot be blindly added to p  as the transitivity requirement might lead to violation of the antisymmetry conditions. we use a simple greedy approach  by adding the pairs  u v  in descending order of   u v  and discarding the pairs that lead to violations of antisymmetry  cycles . to make the check for antisymmetry fast we maintain the transitive closure of p at all times. the complexity of the method is o n1  per added pair in p; as there are o n1  potential pairs  u v   the running time is o n1 . in practice the method works much faster.
1. experimental results
모we tested the method on a paleontological dataset stemming from . recall that in a 1 matrix the rows correspond to fossil discovery sites and columns to different genera. the number of sites and genera were 1 and 1  respectively. average number of genera at a site was 1 with a minimum of 1 and a maximum of 1  standard deviation 1 . the data has lots of false zeros  because there are several natural reasons why a species or genus is not found even though the species actually occurred at the site. the probability of a false zero is estimated to be roughly 1. in addition  a small fraction of the ones are incorrect due to human error  approximately 1 percent .
모the sites have been classified to 1 temporal classes  the mn classes  based on their approximate age. the mn numbers increase as the sites get more recent with the youngest ones in class 1. it should be emphasized that the classification of sites to mn classes is a difficult task  and the criteria are known to vary  see  e.g.   1  1  . one of our goals is to look for sites whose classification should be reevaluated.
모still  a comparison with the mn system is an important evaluation criterion for our method. we denote the partial order our algorithm gives by p. clearly the mn classes define a partial order on the sites as well; we call it pmn.
the completeness of the partial order

	1	1	1
the fraction of pairs ordered in the same way by p and p
mn

figure 1: upper panel: the completeness 붺 of the resulting partial order for different values of 뷃 and   as a function of the number of sampled fragments. lower panel: the compatibility of p with respect to pmn for different values of 뷃 and   as a function of the number of sampled fragments.
given p it is interesting to see how well it correlates with pmn  that is  how many of the pairwise orderings present in p are compatible with the mn numbers. denote the mn number of site u by umn. similarly  one can look at the pairs of sites for which p makes no judgment  and check how many are unordered or near to each other in pmn as well. more precisely  let
 
and
with either x = 1 or x = 1. thus c are measures of similarity between p and pmn when ordered and unordered
모

figure 1: the discovered partial order for the sites presented in three parts  n = 1  l = 1  뷃 = 1 and   = 1 . the ordering progresses from top to down and left to right. the number in brackets next to the name of a site is the mn class of the site. the original order is connected but has been split to pieces for presentational purposes; nodes in the bottom and top are repeated for ease of understanding. the image was generated with the tred and dot utilities provided by the graphviz graph visualization software . see also www.graphviz.org.
모
the number of pairs ordered in the same way by p and p
mn

figure 1: the number of pairs ordered in p and pmn versus the number of pairs unordered in p and pmn.
elements are considered. should it happen that p orders the sites the  wrong  way  recent to old   we simply use the reverse pr. note that c + 몬c + dx + d몬x = |t| 
where t is some total order on the sites. the fraction c+|td|x can be considered a measure of compatibility of p with respect to pmn. another informative property of p is its completeness 붺  defined as |p|/|t|.
모to evaluate the method's sensitivity with respect to the length of a fragment l  total number of sampled fragments n  the value of   and 뷃  we computed p varying the parameter values as follows: n 뫍 {1 1 1}  l 뫍 {1}    뫍 {1} and 뷃 뫍 {1}.
모the results are shown in table 1 and figures 1  1  1 and 1. the values of 붺  c  d1 and l m|p  are provided as well for pmn. obviously pmn is compatible with itself  hence the high values of c and d1. the low lazarus count of pmn is largely explained by its low completeness. all partial orders found by the algorithm are more specific than pmn.
모a number of observations can be made from figure 1. first of all  the number of fragments has in practice only a minor effect both on the completeness 붺 and on the compatibility of p and pmn. thus  a high coverage of the sites is achieved already with a low fragment count. the completeness increases slightly as n increases when   = 1; for larger   the effect is less clear. more obvious is the effect of   itself on 붺. this is to be expected as the number of candidate pairs for inclusion to p must decrease for larger  . increasing 뷃 from 1 to 1 seems to cause a slight decrease in the completeness.
모figure 1 plots c on the horizontal and d1 on the vertical axis. clearly c and d1 exhibit a inversely proportional relationship  that is  as the number of ordered pairs in common to p and pmn increases  the number of common unordered elements decreases.
l m|p  is minimized when p is the trivial partial order
completeness of p vs. the lazarus count

붺
figure 1: the lazarus count versus the completeness 붺 of the partial order p.
with 붺 = 1. conversely  l m|t  is maximized for some total order t. l m|p  might be maximized for some partial order as well  but completing p to a total order can not decrease the lazarus count. it follows that l m|p  increases as 붺 does. figure 1 is in accordance with this proposition. the lazarus count of the total order given by spectral ordering is 1; most of the resulting partial orders have a smaller lazarus count  indicating that the partial orders tend to omit precedence relations that cause lazarus events. also partial orders with a high completeness  붺   1  tend to perform well in terms of l m|p : this supports our claim that the partial orders describe relevant orderings of the data.
모the probability prob  u v  뫍 pmn| u v  뫍 p  is given by c/ c + 몬c . it determines the probability of a pair  u v  뫍 p being correct with respect to pmn. figure 1 indicates a reasonably strong correlation with this probability and l m|p . orders resulting in less lazarus events are also more  correct  and vice versa.
모the results show that the algorithm produces partial orders that are in quite good agreement with the partial order given by the mn system. the correspondence is by no means full; there are interesting variations between the orderings.
모one partial order generated by our method was also qualitatively analyzed. the analysis was based on the visual description of the partial order given in figure 1. of every site is given its name and previously known mn class  in brackets . the visualized graph is the transitive reduction of the original one and has been split to three parts for ease of presentation. note that only the arrows are significant  the nodes are positioned to minimize edge crossings. thus  even though e.g. sandelzhausen is placed right next to ino몮n몮u i  see left part of figure 1  one should not consider these two more similar than sandelzhausen and st몮atzling  for instance. constructing the transitive reduction for the visualization can in practice be very slow.
모the overall pattern generated is in remarkable agreement with current understanding of the evolutionary history of
fraction of correct pairs in p vs. the lazarus count

mn
figure 1: the lazarus count versus the the fraction of correct pairs in p with respect to pmn.
european land mammal faunas  1  1 . for example  the first cluster  wintershof-west to artesilla  comprises early miocene localities.  the one apparent exception  the site hambach 1c  has a faunal list entirely compatible with an mn 1 age.  as another example  the partial order shows clearly the transition to the late miocene  defined by the entry of the horse genus hipparion from north america. the ordering of these sites shows an interesting pattern. three hipparion-localities  massenhausen  wissberg and rudabanya  cluster with last middle miocene localities  most likely owing to their high content of relictual faunal elements . otherwise the early  mn 1  late miocene localities form a homogeneous group  hostalets de pierola superior/esselborn/can ponsic to charmoille .
모similar comments can be made on the whole of the partial order. altogether the order shows a very good correspondence between the previously known ages of the sites  and approximately 1 mn classes of sites will be re-evaluated on the basis of the partial order.
모while the worst-case running times of the algorithm are quite large  they run reasonably fast in practice. the bottleneck of the process is the sampling of fragments  which is largely affected by the fragment length l  the maximal lazarus count 뷃 and obviously the size of r  number of genera in our case . decreasing 뷃 or increasing l or |r| makes the sampling slower  because the probability of a random set of l rows having a permutation with a lazarus count less than 뷃 clearly decreases as l increases and/or 뷃 decreases.
1. concluding remarks
모we have described a method for discovering a partial order from 1 data. the approach first constructs short total orders  fragments  from the data  then orients them  and finally uses the precedence information in the patterns to form the partial order. we have applied the method to paleontological data  and the results yield novel information about several fossil sites.
	n	l	뷃	 	붺	c	d1	l m|p 
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
	1	1	1	1	1
1	1	1	1	1	1	1.1	1 1	1	1	1	1
1	1	1	1	1	1	1.1	1 1	1	1	1	1
 1	1	1	1	1	1	1.1	1 1	1	1	1	1
1	1	1	1	1	1	1.1	1 1	1	1	1	1
1	1	1	1	1
mn system  pmn 	1	1	1

table 1: results of experiments. n: the number of fragments; l: the length of a fragment; 뷃: the maximum number of lazarus events allowed per fragment;  : the parameter of equation 1; c d1: see discussion above; l m|p : the lazarus count of the partial order p.
모as mentioned in the introduction  the approach can also be used for other types of data. the crucial features of the data are the following. first  there is a notion of an underlying partial order among the rows. second  finding the best ordering for the whole set of data should be difficult. third  given a small subset of rows  we can find the best ordering for the subset. we have made preliminary experiments on marker data from medical genetics  and the method yields promising results also there. for that application  the question of finding a good partial order resembles the problem of finding a good dependency graph for the variables.
모the proposed method contains interesting topics for further research. determining good criteria for accepting a set of fragments produced by the subset m is crucial for the performance of the sampling. how 뷃 should be set clearly depends on l and the size of r  but also on the estimated number of false zeros in the data. this dependence should be investigated further  not only because it affects the running time of sampling  but also because it has an effect on the quality of the fragments. unsuitable values of 뷃 can cause certain rows  sites  to have a higher frequency than others in the produced fragments.
모the problem of fragment orientation is not restricted to a case where the fragments are generated by minimizing the lazarus count. suppose we construct fragments by using a likelihood function that is based on pairwise similarities of the observations. if the similarity measure is symmetric  the likelihoods of fragments f and fr are the same.
모perhaps the most interesting open question is what type of an algorithm could be used to find a partial order p minimizing
l m|p  + 붸 p 
for some suitable chosen functions 붸 describing the complexity of the partial order. as mentioned in section 1  this problem seems fairly difficult: the space of potential partial orders is large and it seems difficult to do even local search in it. we are currently pursuing two approaches to this problem: one is based on the idea of using mcmc techniques over the set of partial or total orders. the other is based on randomized algorithms .
