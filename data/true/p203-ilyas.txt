ranking is an important property that needs to be fully supported by current relational query engines. recently  several rank-join query operators have been proposed based on rank aggregation algorithms. rank-join operators progressively rank the join results while performing the join operation. the new operators have a direct impact on traditional query processing and optimization.
모we introduce a rank-aware query optimization framework that fully integrates rank-join operators into relational query engines. the framework is based on extending the system r dynamic programming algorithm in both enumeration and pruning. we define ranking as an interesting property that triggers the generation of rank-aware query plans. unlike traditional join operators  optimizing for rank-join operators depends on estimating the input cardinality of these operators. we introduce a probabilistic model for estimating the input cardinality  and hence the cost of a rank-join operator. to our knowledge  this paper is the first effort in estimating the needed input size for optimal rank aggregation algorithms. costing ranking plans  although challenging  is key to the full integration of rank-join operators in real-world query processing engines. we experimentally evaluate our framework by modifying the query optimizer of an open-source database management system. the experiments show the validity of our framework and the accuracy of the proposed estimation model.
1. introduction
모emerging applications that depend on ranking queries warrant efficient support of ranking queries in real-world database management systems. supporting ranking queries gives database systems the ability to efficiently answer information retrieval  ir  queries. for many years  combining the advantages of both worlds  databases and information retrieval systems  has been the goal of many researchers. database systems provide efficient handling of data with

 this work was supported in part by the national science foundation under grants iis-1  eia-1  iis-1  ccr-1  and by the army research office under grant daad1-1.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  or republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1  june 1  1  paris  france.
copyright 1 acm 1-1/1...$1.
solid integrity and consistency guarantees. on the other hand  ir provides mechanisms for effective retrieval and fuzzy ranking that are more appealing to the user.
모one approach toward integrating databases and ir is to introduce ir-style queries as a challenging type of database queries. the new challenge requires several changes that vary from introducing new query language constructs to augmenting the query processing and optimization engines with new query operators. it may also introduce new indexing techniques and other data management challenges. a ranking query  also known as top-k query  is an important type of query that allows for supporting ir-style applications on top of database systems.
모in contrast to traditional join queries  the answer to a top-k join query is an ordered set of join results according to some provided function that combines the orders of each input. the following query  query q1  is an example of a
모top-k join query expressed in sql1.
q1: with rankedabc as   select a.c1 as x  b.c1 as y  rank   over
 order by  1*a.c1.1*b.c1   as rank
from a b c
where a.c1 = b.c1 and b.c1 = c.c1 
select x y rank
from rankedabc
           where rank  =1; where a  b and c are three relations and a.c1 b.c1 b.c1 and c.c1 are attributes of these relations. the only way to produce ranked results on the expression
1*a.c1.1*b.c1 in q1 is by using a sort operator on top of the join.
모efficient processing of ranking queries gained the attention of many researchers and database vendors. for example  strategies for answering top-k selection queries over relational databases have been introduced in  and were prototyped on top of microsoft sql server. in   top-k selection queries are mapped to range queries with an adaptable range parameter to produce the top-k results. we further discuss related work on optimizing this implementation of top-k queries in section 1. other techniques that maintain materialized views or special indexes to enhance the peresponse time of top-k queries are introduced in  1  1  1 .
모although these techniques enhance the database system performance in answering top-k queries  they are implemented either at the application level or outside the core query engine. hence  processing and optimizing top-k queries lose the benefit of true integration with other basic database query types. a more promising approach is to devise new core query operators that are rank-aware and that

figure 1:	estimated i/o cost for two ranking
plans.
can be easily integrated in current query engines. backed with many algorithms for rank aggregation  1  1  1  1  1   the new query operators combine both algorithmic efficiency  and optimality  and system practicality. rank-join operators  introduced in  1  1  1   progressively rank the join results according to a given scoring function. the join operation has an early out condition that stops the operation once the top-ranked join results can be reported. top-k join query evaluation was also introduced in  in querying xml data for the special case of left-outer joins.
1 motivation
모for the new rank operators to be practically useful they must be integrated in real-world query optimizers. top-k
모queries often involve other query operations such as join 
모selection and grouping. a key challenge is how to choose a
모query execution plan that uses the new rank-join operators most efficiently.
모an observation that motivates the need for integrating rank-join operators in query optimizers  is that a rank-join operator may not always be the best way to produce the required ranked results. in fact  depending on many parameters  for example  the join selectivity  the available access paths and the memory size  a traditional join-then-sort plan may be a better way to produce the ranked results.
모figure 1 gives the estimated i/o cost of two plans: a
모sort plan and a rank-join plan  for various values of the join selectivity. the sort plan is a traditional plan that joins two inputs and sorts the results on the given scoring function  while the rank-join plan uses a rank-join operator that progressively produces the join results ranked on the scoring function. the figure shows that for low values of the join selectivity  the traditional sort-plan is cheaper than the rank-join plan. on the other hand  for higher selectivity values  the rank-join plan is cheaper.
모the previous example highlights the need to optimize topk queries by integrating rank-join operators in query optimization. this approach  although appealing and intuitive  is hindered by the following challenges:
  how to generate plans that make use of rank-join operators   what will be the plan property that triggers the generation of such plans  
  how to estimate the cost of a rank-join query operator   what will be the value of k when pushed all the way down in the query pipeline   what is the effect of other operators in the plan on the cost estimation  
모another way to phrase the first set of questions is how to make the query optimizer  aware  of the newly available ranking operators and their unique properties. throwing these operators as yet another join implementation would not work without defining new physical properties that guarantee the best use of these operators.
모unlike traditional query operators  it is hard to estimate the cost of rank-join operators because of their  early out  feature; whenever the top k results are reported  the execution stops without consuming all the inputs. the  early out  feature poses many challenges in costing rank-join operators.
모in this paper  we show how to generate the rank-join plan as an alternative execution plan to answer top-k queries. we also show how we came up with the cost estimation of the rank-join plan used in figure 1  for effective query optimization.
1 contribution
모in this paper  we introduce a framework that extends traditional query optimization to be  rank-aware . we can summarize our contributions as follows:
  we extend the notion of interesting properties in query optimization to include interesting rank expressions. the extension triggers the generation of a space of rank-aware query execution plans. the new generated plans make use of the proposed rank-join operators and integrate them with other traditional query operators.
  we tackle the challenge of pruning rank-aware execution plans based on cost. since a rank-join plan can stop at any time once the top-k answers are produced  the input cardinality of the operators  and hence the cost  can vary significantly and in many cases depends on the query itself. we provide an efficient probabilistic model for estimating the minimum input size  depth  needed by rank-join operators. we use the estimation in pruning the generated plans.
  we experimentally validate our probabilistic estimation of the input cardinality of rank-join operators. we show how we use the model to prune the space of generated plans and ultimately  in choosing the overall query execution plan.
모the work introduced in this paper completes the picture of a full integration between ir-style rank aggregation algorithms and current relational query processing. we believe that this integration is the first in a series of extensions and modifications to current database management systems to efficiently support ir-style queries.
모the remainder of the paper is organized as follows. section 1 gives the necessary background on rank aggregation algorithms  rank-join operators and cost-based query optimization. we show how to extend traditional query optimization to be rank-aware in section 1. moreover  in section 1  we show how to treat ranking as an interesting physical property and its impact on plan enumeration. in section 1  we introduce a novel probabilistic model for estimating the input size  depth  of rank-join operators and hence estimating the cost and space complexity of these operators.
in section 1  we experimentally verify the proposed estimation model and show the accuracy of estimating the input size and the maximum buffer size needed by rank-join operators. we discuss related work in section 1 and conclude in section 1 by a summary and final remarks.
1. background
모for the paper to be self-contained  we give an overview of relevant techniques we rely on in this work. first  we briefly overview rank aggregation methods as an efficient approach to evaluate top-k queries. we highlight the underlying concept of most rank aggregation algorithms proposed in the literature. second  we overview rank-join operators  an efficient implementation of rank aggregation algorithms in terms of physical join operators. third  we give an overview of cost-based optimization as a practical optimization method used by current real-world database systems. specifically  we briefly describe the dynamic programming optimization framework introduced in system r  as the basic optimization technique. we would like to emphasize that the ideas introduced in this paper can be applied to other cost-based optimization frameworks. choosing the dynamic programming technique is merely for demonstrating the applicability of our approach.
1 rank aggregation
모rank aggregation is an efficient way to produce a global rank from multiple input rankings. the problem goes back to at least a couple of centuries in effort to come up with a  robust  voting technique  1  1 . rank aggregation can be achieved through various techniques. the simplest technique is positional ranking or borda's method   since it is easy to compute in linear time and enjoys some nice properties such as consistency . in a nut-shell  rank aggregation algorithms view the database as multiple lists. each list contains a ranking of some objects; each object in a list is assigned a score that determines its rank within the list. the goal is to be more efficient than the na몮 ve approach of joining the lists together  and then sorting the output list on the combined score. to get a total ranking  a rank aggregation algorithm incrementally maintains a temporary state that contains all  seen  object scores. the algorithm retrieves objects from the lists  along with their scores  until the algorithm has  enough  information to decide on the top ranked objects  and then terminates. the reader is referred to  1  1  1  1  1  1  1  1  1  1  for more details on the various proposed algorithms.
모in general  the proposed rank aggregation algorithms can be classified according to two major criteria. the first classification is based on the type of access available on the input lists. each ranked input can support sorted access and/or random access. sorted access enables object retrieval in a descending order of their scores. random access enables probing or querying an input to retrieve a score of a given object. for example  the nra algorithm introduced in  assumes only sorted access on the ranked inputs  while the ta algorithm  introduced also in   assumes the availability of both random access and sorted access on all inputs. on the other hand  the algorithms introduced in  1  1  assume that at least one source has sorted access capability while other sources can have only random access  probing  available.
the second classification of rank aggregation algorithms
is based on the assumptions on the underlying ranked objects. in the first category  all inputs contain the same set of objects ranked on different criteria. hence  all the inputs can be viewed as one list of objects  where each object has a set of score attributes. the output is the same set of objects ranked on a combination  aggregation  of these score attributes. we refer to this problem as top-k selection. most of the proposed algorithms belong to this category  e.g.   1  1  1  1  1 . in the second category of algorithms  e.g.   1  1   each input contains a different set of objects. a  join  condition among objects in different inputs joins them together in one output join result. each join result has a combined score computed from the scores of participating objects. the goal is to produce the top-k join results. we refer to this problem as top-k join.
1 rank-join query operators
모to support rank aggregation algorithms in a database system  we have the choice of implementing these algorithms at the application level as user-defined functions or to implement them as core query operators  rank-join operators . although the latter approach requires more effort in changing the core implementation of the query engine  it supports ranking as a basic database functionality. the authors in  1  1   show the benefit of having rank-aware query operators that can be smoothly integrated with other operators in query execution plans. in general  rank-join query operators are physical join operators that  besides joining the inputs  they produce the join results ranked according to a provided scoring function.
모rank-join operators require the following:  1  the inputs  or at least one of them  are ranked and each input tuple has an associated score   1  the input may not be materialized  but a getnext interface on the input should retrieve the next tuple in a descending order of the associated scores  and  1  there is a monotone scoring function  say f  that computes a total score of the join result by applying f on the scores of the tuples from each input.
모rank-join operators are almost non-blocking. the next ranked join result is usually produced in a pipelined fashion without the need to exhaust all the inputs. on the other hand  a rank-join operator may need to exhaust part of the inputs before being able to report the next ranked join result.
모it is proved that rank-join operators can achieve a huge benefit over the traditional join-then-sort approach to answer top-k join queries especially for small values of k.
모for clarity of the presentation  we give a brief overview on two possible rank-join implementations: nested-loops rankjoin  nrjn  and hash rank-join  hrjn . for any rank-join operator  the operator is initialized by specifying the two inputs  the join condition  and the combining function.
모hrjn can be viewed as a variant of the symmetrical hash join algorithm  1  1  or the hash ripple join algorithm . hrjn maintains an internal state that consists of three structures. the first two structures are two hash tables  i.e.  one for each input. the hash tables hold input tuples seen so far and are used in order to compute the valid join results. the third structure is a priority queue that holds the valid join combinations ordered on their combined score. at the core of hrjn is the rank aggregation algorithm. the algorithm maintains a threshold value that gives an upper-bound of the scores of all join combinations not yet seen. to compute the threshold  the algorithm remembers and maintains the two top scores and the two bottom scores  last scores seen  of its inputs. a join result is reported as the next top-k answer if the join result has a combined score greater than or equal the threshold value. otherwise  the algorithm continues by reading tuples from the left and right inputs and performs a symmetric hash join to generate new join results. in each step  the algorithm decides which input to poll depending on different strategies  e.g.  depending on the score distribution of each input .
모nrjn is similar to hrjn except that it follows a nestedloops strategy to generate valid join results. nrjn internal states contains only a priority queue of all seen join combinations. similar to hrjn  nrjn maintains a threshold that upper-bounds the scores of all unseen join results.
모the depth of a rank-join operator is defined as the number of input tuples needed to produce top-k join results. we will elaborate more on integrating rank-join operators in query optimization in the following sections.
1 cost-based query optimization
모the optimizer is the component in the query processing engine that transforms a parsed input query into an efficient query execution plan. the execution plan is then passed to the run-time engine for evaluation. the task of a query optimizer is to find the best execution plan for a given query. this task is usually accomplished by examining a large space of possible execution plans and comparing these plans according to their  estimated  execution cost. to estimate the cost of an execution plan  the optimizer adopts a cost model that takes several inputs  such as the estimated input size and the estimated selectivity of the individual operations  and estimates the total execution cost of the query. most of the different generated plans come from different organizations of the join operations. in general  the larger the space of possible plan  the higher the chance that the optimizer will get a better execution plan.
plan enumeration using dynamic programming
since the join operation is implemented in most systems as a diadic  1-way  operator  the optimizer must generate plans that transform an n-way join into a sequence of 1-way joins using binary join operators. the two most important tasks of an optimizer are to find the optimal join sequence as well as the optimal join method for each binary join. dynamic programming  dp  was first used for join enumeration in system r . the essence of the dp approach is based on the assumption that the cost model satisfies the principle of optimality  i.e.  the subplans of an optimal plan must be optimal themselves. therefore  in order to obtain an optimal plan for a query joining n tables  it suffices to consider only the optimal plans for all pairs of non-overlapping m tables and n   m tables  for m = 1 ... n   1.
모to avoid generating redundant plans  dp maintains a memory-resident structure  referred to as memo  following the terminology used in   for holding non-pruned plans. each memo entry corresponds to a subset of the tables  and applicable predicates  in the query. the algorithm runs in a bottom-up fashion by first generating plans for single tables. then it enumerates joins of two tables  then three tables  etc.  until all n tables are joined. for each join it considers  the algorithm generates join plans and incorporates them into the plan list of the correspond-
select a.c1
from a b c where a.c1 = b.c1   and b.c1 = c.c1 ;select a.c1
from a b c where a.c1 = b.c1    and b.c1 = c.c1 
order by a.c1 ;
both queries have 1 joins
 a b      b c       a bc      ab c 
	 a 	 b 
figure 1: number of joins vs. number of plans.
ing memo entry. plans with larger table sets are built from plans with smaller table sets. the algorithm prunes a higher cost plan if there is a cheaper plan with the same or more general properties for the same memo entry. finally  the cheapest plan joining n tables is returned.
plan properties such properties are extensions of the important concept of interesting orders  introduced in system r. suppose that we have two plans generated for table r  one produces results ordered on r.a  call it p1  and the other does not produce any ordering  call it p1 . also suppose that p1 is more expensive than p1. normally  p1 should be pruned by p1. however  if table r can later be joined with table s on attribute a  p1 can actually make the sort-merge join between the two tables cheaper than p1 since it doesn't have to sort r. to avoid pruning p1  system r identifies orders of tuples that are potentially beneficial to subsequent operations for that query  hence the name interesting orders   and compares two plans only if they represent the same expression and have the same interesting order. in figure 1 a   we show a 1-way join query and the plans kept in the corresponding memo structure. for each memo entry  a list of plans is stored  each carrying a different order property that is still interesting. we use dc to represent a  don't care  property value  which corresponds to  no order . the cheapest plan with a dc property value is also stored in each memo entry if this plan is cheaper than any other plan with interesting orders. modifying the query to that in figure 1 b   by adding an orderby clause  increases the number of interesting order properties that need to be kept in all memo entries containing a. by comparing figure 1 a  with figure 1 b   we can see that the number of generated join plans changes  even though the join graph is still the same. the idea of interesting orders was later generalized to multiple physical properties in  1  1  and is used extensively in modern optimizers. intuitively  a physical property is a characteristic of a plan that is not shared by all plans for the same logical expression  corresponding to a memo entry   but can impact the cost of subsequent operations.
모
1. rank-aware optimization
모having described an efficient implementation of the rank aggregation algorithms in terms of new rank-join query operators  we now describe how to extend the traditional query optimization-one that uses dynamic programming a la - to handle the new rank-join operators. integrating the new rank-join operators in the query optimizer includes two major tasks: 1  enlarging the space of possible plans to include those plans that use rank-join operators as a possible join alternative  and  1  providing a costing mechanism for the new operators to help the optimizer prune expensive plans in favor of more general cheaper plans.
모in this section  we elaborate on the first task while in the following section we provide an efficient costing mechanism for rank-join operators. enlarging the plan space is achieved by extending the enumeration algorithm to produce new execution plans. the extension must conform to the enumeration mechanism of other traditional plans. in this work  we choose the dp enumeration technique  described in section 1. the dp enumeration is one of the most important and widely used enumeration techniques in commercial database systems. current systems use different flavors of the original dp algorithm that involve heuristics to limit the enumeration space and can vary in the way the algorithm is applied  e.g.  bottom-up versus top-down . in this paper  we stick to the bottom-up dp as originally described in . our approach is equally applicable to other enumeration algorithms.
1 ranking as an interesting property
모as described in section 1  interesting orders are those orders that can be beneficial to later operations. practically  interesting orders are collected from:  1  columns in equality predicates in the join condition  as orders on these columns make upcoming sort-merge operations much cheaper by avoiding the sort   1  columns in the groupby clause to avoid sorting in implementing sort-based grouping  and  1  columns in the orderby clause since they must be enforced on the final answers. current optimizers usually enforce interesting orders in an eager fashion. in the eager policy  the optimizer generates plans that produce the interesting order even if they do not exist naturally  e.g.  through the existence of an index .
모in the following example  we describe a top-k query using current sql constructs by specifying the ranking function in the orderby clause.
q1:
with rankedabc as  
select a.c1 as x  b.c1 as y  c.c1 as z  rank   over
 order by  1*a.c1.1*b.c1.1*c.c1   as rank
from a b c
where a.c1 = b.c1 and b.c1 = c.c1 
select x y z rank
from rankedabc
모where rank  =1; where a  b and c are three relations and a.c1  a.c1  b.c1  b.c1  c.c1 and c.c1 are attributes of these relations. following the concept of interesting orders  the optimizer considers orders on a.c1  b.c1  b.c1 and c.c1 as interesting orders  because of the join  and eagerly enforces the existence of plans that access a  b and c ordered on a.c1  b.c1  b.c1 and c.c1  respectively. this enforcement can be done by gluing a sort operator on top of the table scan or
interesting order expressionsreasona.c1rank-joina.c1joinb.c1join and rank-joinb.c1joinc.c1rank-joinc.c1join1*a.c1.1*b.c1rank-join1*b.c1.1*c.c1rank-join1*a.c1.1*c.c1rank-join1*a.c1.1*b.c1.1*c.c1orderbytable 1: interesting order expressions in query q1.
by using an available index that produces the required order. currently  orders on a.c1 or c.c1 are  not interesting  since they are not beneficial to other operations such as a sort-merge join or a sort. the reason being that a sort on the expression  1*a.c1.1*b.c1.1*c.c1  cannot benefit from ordering the input on a.c1 or c.c1 individually.
모having the new rank-aware physical join operators  orderings on the individual scores  for each input relation  become interesting in themselves. in the previous example  an ordering on a.c1 is interesting because it can serve as input to a rank-join operator. hence  we extend the notion of interesting orders to include those attributes that appear in the ranking function.
모definition 1. an interesting order expression is ordering the intermediate results on an expression of database columns that can be beneficial to later query operations.
모in the previous example  we can identify some interesting order expressions according to the previous definition. we summarize these orders in table 1. like an ordinary interesting order  an interesting order expression retires when it is used by some operation and is no longer useful for later operations. in the previous example  an order on a.c1 is no longer useful after a rank-join between table a and b.
1 extending the enumeration space
모in this section  we show how to extend the enumeration space to generate rank-aware query execution plans. rankaware plans will integrate the rank-join operators  described in section 1  into general execution plans. the idea is to devise a set of rules that generate rank-aware join choices at each step of the dp enumeration algorithm. for example  on the table access level  since interesting orders now contain ranking score attributes  the optimizer will enforce the generation of table and index access paths that satisfy these orders. in enumerating plans at higher levels  join plans   these ordered access paths will make it feasible to use rank-join operators as join choices.
모for a query with n input relations  t1 to tn  assume there exists a ranking function f s1 s1 ... sn   where si is score expression on relation ti. for two sets of input relations  l and r  we extend the space of plans that join l and r to include rank-join plans by adapting the following:
  join eligibility l and r are rank-join-eligible if all the following apply:
1. there is a join condition that relates at least one input relation in l to an input relation in r.
1. f can be expressed as f f1 sl  f1 sr  f1 so    where f1  f1 and f1 are three scoring functions  sl are score expressions on the relations in

figure 1: enumerating rank-aware query plans.
l  sr are the score expressions on the relations in r  and so are the score expressions on the rest of the input relations.
1. there is at least one plan that accesses l and/or r ordered on sl and/or sr  respectively.
  join choices rank-join can have several implementations as physical join operators. in section 1  we presented the hash rank-join operators  hrjn  and the nested-loops rank-join operator  nrjn . for each rank-join between l and r  plans can be generated for each join implementation. for example  an hrjn plan is generated if there exist plans that access both l and r sorted on sl and sr  respectively. on the other hand  an nrjn plan is generated if there exists at least one plan that accesses l or r sorted on sl or
sr  respectively.
  join order for symmetric rank-join operators  e.g.  hrjn   there is no distinction between outer and inner relations. for the nested-loops implementation  a different plan can be generated by switching the inner and the outer relations. l  r  can serve as inner to an nrjn operator if there exists a plan that accesses l  r  sorted on sl  sr .
모for example  for query q1 in section 1  new plans are generated by enforcing the interesting order expressions listed in table 1 and using all join choices available including the rank-join operators. as in traditional dp enumeration  generated plans are pruned according to their cost and properties. for each class of properties  the cheapest plan is kept. figure 1 gives the memo structure of the retained subplans when optimizing q1. each oval in the figure represents the best plan with a specific order property. figure 1  a  gives the memo structure for the traditional application of the dp enumeration without the proposed extension. for example  we keep two plans for table a; the cheapest plan that does not have any order property  dc  and the cheapest plan that produces results ordered on a.c1 as an interesting order. figure 1  b  shows the newly generated classes of plans that preserve the required ranking. for each interesting order expression  the cheapest plan that produces that order is retained. for example  in generating plans that join tables a and b  we keep the cheapest plan that produces results ordered on 1*a.c1 + 1*b.c1.

figure 1: example rank-join plan.
1 pruning plans
모a subplan p1 is pruned in favor of subplan p1 if and only if p1 has both higher cost and weaker properties than p1. in section 1  we discussed extending the interesting order property to generate rank-aware plans. a key property of top-k queries is that users are interested only in the first k results and not in a total ranking of all query results. this property directly impacts the optimization of top-k queries by optimizing for the first k results. traditionally  most realworld database systems offer the feature of first-n-rowsoptimization. users can turn on this feature when desiring fast response time to receive results as soon as they are generated. this feature translates into respecting the  pipelining  of a plan as a physical plan property. for example  for two plans p1 and p1 with the same physical properties  if p1 is a pipelined plan  e.g.  nested-loops join plan  and p1 is a non-pipelined plan  e.g.  sort-merge join plan   p1 cannot be pruned in favor of p1  even if p1 is cheaper than p1.
모in real-world query optimizers  the cost model for different query operators is quite complex and depends on many parameters. parameters include cardinality of the inputs  available buffers  type of access paths  e.g.  a clustered index  and many other system parameters. although cost models can be very complex  a key ingredient of accurate estimation is the accuracy of estimating the size of intermediate results.
모in traditional join operators  the input cardinalities are independent of the operator itself and only depend on the input subplan. moreover  the output cardinality depends only on the size of the inputs and the selectivity of the logical operation. on the other hand  since a rank-join operator does not consume all of its inputs  the actual input size depends on the operator itself and how the operator decides that it has seen  enough  information from the inputs to generate the top k results. hence  the input cardinality depends on the number of ranked join results requested from that operator. thus  the cost of a rank-join operator depends on the following:
  the number of required results k and how k is propagated in the pipeline. for example  figure 1 gives a real similarity query that uses two rank-join operators to combine the ranking based on three features  referred to as a   b and c. to get 1 requested results  i.e.  k = 1   the top operator has to retrieve 1 tuples from each of its inputs. thus  the number of required results from the child operator is 1 in which it has to retrieve 1 tuples from its inputs. notice that while k = 1 in the top rank-join operator  k = 1 in the child rank-join operator that joins a and b. in other words  in a pipeline of rank-join operators  the input depth of a rank-join operator is the required number

모모figure 1: two enumerated plans. of ranked results from the child rank-join operator.
  the number of tuples from inputs that contain enough information for the operator to report the required number of answers  k. in the previous example  the top operator needs 1 tuples from both inputs to report 1 rankings  while the child operator needed 1 tuples from both inputs to report the required 1 partial rankings.
  the selectivity of the join operation. the selectivity of the join affects the number of tuples propagated from the inputs to higher operators through the join operation. hence  the join selectivity affects the number of input tuples required by the rank-join operator to produce ranked results.
모there are two ways to produce plans that join two sets of input relations  l and r  and produce ranked results:  1  by using rank-join operators to join l and r subplans  or  1  by gluing a sort operator on the cheapest join plan that joins l and r without preserving the required order. one challenge is in comparing two plans when one or both of them are rank-join plans. for example  in the two plans depicted in figure 1  both plans produce the same order property. plan  b  may or may not be pipelined depending on the subplans of l and r. in all cases  the cost of the two plans need to compared to decide on pruning. while the current traditional cost model can give an estimate total cost of plan  a   it is hard to estimate the cost of plan  b  because of its strong dependency on the number of required ranked results  k. thus  to estimate the cost of plan  b   we need to estimate the propagation of the value of k in the pipeline  refer to figure 1 . in section 1  we give a probabilistic model to estimate the depths  dl and dr in figure 1  b   required by a rank-join operator to generate top k ranked results. the estimate for the depths is parameterized by k and by the selectivity of the join operation. it is important to note that the cost of plan  a  is  almost  independent of the number of output tuples pulled from the plan since it is a blocking sort plan. in plan  b   the number of required output tuples determines how many tuples will be retrieved from the inputs and that greatly affects the plan cost.
plan pruning according to our enumeration mechanism  at any level  there will be only one plan similar to plan  a  of figure 1  by gluing a sort on the cheapest non-ranking plan . at the same time  they may be many plans similar to plan  b  of figure 1  e.g.  by changing the type of the rank-join operator or the join order .
모for all rank-join plans  the cost of the plan depends on k and the join selectivity s. since these two parameters are the same for all plans  the pruning among these plans follows the same mechanism as in traditional cost based pruning. for example  pruning a rank-join plan in favor of another rank-join plan depends on the input cardinality of the relations  the cost of the join method  the access paths  and the statistics available on the input scores.
모we assume the availability of an estimate of the join selectivity  which is the same for both sort-plans and rank-join plans. a challenging question is how to compare between the cost of a rank-join plan and the cost of a sort plan  e.g.  plans  a  and  b  in figure 1  when the number of required ranked results is unknown. note that the number of results  k  is known only for the final complete plan. because subplans are built in a bottom-up fashion  the propagation of the final k value to a specific subplan depends on the location of that subplan in the complete evaluation plan.
모we introduce a mechanism for comparing the two plans in figure 1 using the estimated total cost of plan  a  and the estimated cost of plan  b   parametrized by k. section 1 describes how to obtain the parametrized cost of plan  b . for plan  a   we can safely assume that costa k  = totalcosta where costa k  is the cost to report k results from plan  a   and totalcosta is the cost to report all join results of plan  a . this assumption follows directly from plan  a  being a blocking sort plan. let k  be that value of k at which the cost of the two plans are equal. hence  costa k   = costb k   = totalcosta. the output cardinality of plan  a   call it na  can be estimated as the product of the cardinalities of all inputs multiplied by the estimated join selectivity. since k cannot be more than na  we compare k  with na. let kmin be the minimum value of k for any rank-join subplan. a reasonable value for kmin would be the value specified in the query as the total number of required answers. consider the following cases:
  k    na: plan  b  is always cheaper than plan  a . hence plan  a  should be pruned in favor of plan  b .
  k    na and k    kmin: since for any subplan  k 뫟 kmin  we know that we will require more that k  output results from plan  b . in that case plan  a  is cheaper. depending on the nature of plan  b  we decide on pruning:
- if plan  b  is a pipelined plan  e.g.  a left deep tree of rank-join operators   then we cannot prune plan  b  in favor of plan  a  since it has more properties  the pipelining property.
- if plan  b  is not a pipelined tree  then plan  b  is pruned in favor of plan  a .
  k    na and k    k: we keep both plans since depending on k  plan  a  may be cheaper than plan  b  and hence cannot be pruned.
모as an example  we show how the value of k affects the cost of rank-join plans and hence the plan pruning decisions. we compare two plans that produce ranked join results of two inputs. the first plan is a sort plan similar to that in figure 1 a   while the second plan is a rank-join plan similar to that in figure 1 b . the sort plan sorts the join results of an index nested-loops join operator while the rank-join plan uses hrjn as its rank-join operator. the estimated cost formula for the sort plan uses the traditional cost formulas for external sorting and index nested-loops join  while the estimated cost of rank-join plan is based on our model

figure 1: the effect of k on the rank-join cost.
to estimate the input cardinality  as will be shown in section 1 . both cost estimates use the same values of input relations cardinalities  total memory size  buffer size  and input tuple sizes. figure 1 compares the estimate of the costs of the two plans for different values of k. while the sort plan cost can be estimated to be independent of k  the cost of the rank-join plan increases with increasing the value of k. in this example  k  = 1.
1. estimating input cardinality of rank-join operators
모in this section  we give a probabilistic model to estimate the input cardinality  depth  of rank-join operators. the estimate is parameterized with k  the number of required answers from the  sub plan  and s  the selectivity of the join operation. we describe the main idea of the estimation procedure by first considering the simple case of two ranked relations. then  we generalize to the case of a hierarchy of rank-join operators.
모let l and r be two ranked inputs to a rank-join operator. let m and n be the table cardinalities of l and r  respectively. our objective is to get an estimate of depths dl and dr  see figure 1  such that it is sufficient to retrieve only up to dl and dr tuples from l and r  respectively  to produce the top k join results. we denote the top i tuples of l and r as l i  and r i   respectively. we outline our approach to estimate dl and dr in figure 1.
모in the following subsections  we elaborate on steps of the outline in figure 1. figure 1 gives algorithm propagate used by the query optimizer to compute the values of dl and dr at all levels in a rank-join plan. we set k to the value specified in the query when we call the algorithm for the final plan.
모we assume the following to simplify the analysis:  1  the combining scoring function is a linear combination of the scores  e.g.  a weighted sum of the input scores   and  1  each tuple in l is equally likely to join with sn tuples in r and each tuple in r is equally likely to join with sm tuples in l.
1 estimating any-k depths
모in the first step of the outline in figure 1  we estimate the depths cl and cr in l and r  respectively  required to get any k join results.  any k  join results are valid join results  but not necessarily among the top k answers in score.
outline estimatetop-kdepth
input: two ranked relations l and r the number of required ranked results  k
the join selectivity  s
any-k depths
1. compute the value of cl and cr  where cl is the depth in l and cr is the depth in r such that    expected k valid join results between l cl  and r cr 
top-k depths
1. compute the value of dl and dr  where dl is the depth in l and dr is the depth in r such that    expected k top-scored join results between l dl . and r dr . dl and dr are expressed in terms of cl and cr.
minimize top-k depths
1. compute the values of cl and cr to minimize dl and dr. cl  cr  dl and dr are paramterized by k

figure 1: outline of the estimation technique.

algorithm propagate  subplan p  k 
input: the number of required ranked results  k the root of a subplan  p
output: dl and dr for the operator rooted at p
1. compute dl and dr according to the formulas in section 1
1. call propagate left subplan of p  dl 
1. call propagate right subplan of p  dr 

figure 1: propagating the value of k.

figure 1: depth estimation of rank-join operators.
모theorem 1. if cl and cr are chosen such that sclcr 뫟 k  then the expected number of valid join results between l cl  and r cr  is 뫟 k.
모proof. let xi j denote a random variable that is equal to the number of join results produced by joining the first i tuples from l and the first j tuples from r. since every tuple in l is likely to join with sj tuples in r j   then the expected value of this random variable is e xi j  = sij. let cl = i and cr = j  hence  if sclcr 뫟 k  then we can expect at least k valid join results between l cl   the top cl tuples in l  and r cr . 
모in general  the choice of cl and cr can be arbitrary as long as they satisfy sclcr 뫟 k. we show that we choose values for cl and cr in section 1.
1 estimating top-k depths
모in the second step in the outline given in figure 1  we aim at obtaining good estimates for dl and dr  where dl and dr are the depths into l and r  respectively  needed to produce an expected number of top k join results. for the simplicity of presentation  the formulas presented in this section assume that the scoring function is the summation of individual scores.
모let sl i  and sr i  be the scores of the tuples at depth i in l and r  respectively. moreover  let 붻l i  and 붻r i  be the score difference between the top ranked tuple and the score of the tuple at a depth i in l and r  respectively  i.e.  붻l i  = sl 1    sl i  and 붻r i  = sr 1    sr i 
모theorem 1. if there are k valid join results between l cl  and r cr   and if dl and dr are chosen such that 붻l dl  뫟 붻l cl  + 붻r cr  and 붻r dr  뫟 붻l cl  + 붻r cr   then the top k join results can be obtained by joining l dl  and r dr .
모proof. refer to figure 1 for illustration. let 붻 = 붻l cl  + 붻r cr  and s = sl 1  + sr 1 . since  there are k join tuples between l cl  and r cr   the final score of each of the join results is 뫟 s   붻. consequently  the scores of all of the top k join results are 뫟 s   붻. assume that one of the top-k join results  j  joins a tuple t at depth d in l with some tuple in r such that 붻l d    붻. the highest possible score of j is sl d  + sr 1  = s   붻l d    s   붻. by contradiction  tuple t cannot participate in any of the top k join results. hence  any tuple in l  similarly r  that is at a depth   dl  dr  cannot participate in the top k join results. 
모since the choice of cl and cr can be arbitrary as long as they satisfy the condition in theorem 1  step  1  of the outline in figure 1 chooses the values of cl and cr that minimize the values of dl and dr. note that both dl and dr are minimized when 붻 = 붻l cl  + 붻r cr  is minimized. hence we minimize 붻 subject to the constraint sclcr 뫟 k. the rationale behind this minimization is that an optimal rankaggregation algorithm does not need to retrieve more than the minimum dl and dr tuples from l and r  respectively  to generate the top k join results.
1 estimating the minimum dl and dr
모till now  we did not have any assumptions on the score distributions of l and r. we showed that dl and dr are related to cl and cr in terms of the scores of the tuples at these depths.
모to have a closed formula for the minimum dl and dr  we assume that the rank scores in l and r are from some uniform distribution. let x be the average decrement slab of l  i.e.  the average difference between the scores of two consecutive ranked objects in l  and let y be the average decrement slab for r. hence  the expected value of 붻l cl  = xcl and the expected value of 붻r cr  = ycr. to minimize 붻 = 붻l cl  + 붻r cr   we minimize xcl + ycr  subject to
 the minimization is achieved by setting cl = p yk / xs  and in this case  dl = cl +
 y/x cr and dr = cr +  x/y cl
in the simplistic case  where both the relations come from i.e.  x = y  then cl = cr =
.
모in a hierarchy of joins  where the output of one rankjoin operator serves as input to another operator  the score distributions of the second level join are no longer uniform. assuming the scoring function is the sum of two scores  the

모모모모figure 1: central limit theorem. scores of rank join with two uniform distributions follows a triangular distribution. as we go higher up in the join hierarchy  the distribution tends to be normal  bell-shaped curve  by central limit theorem  see figure 1 .
모let x y be two independent random variables from the uniform distribution  1 n . we refer to this uniform distribution as u1. we refer to the summation of j independent random variable from u1 as uj. the random variable z = x+y   which follows the distribution u1  is a triangular distribution over  1n  with a peak at n. if we choose n elements from the u1 distribution  the score of the ith element  i 뫞 n/1   in a decreasing order of the scores  is expected to be. in general  if we choose m elements from uj  which ranges from  1 jn   then the score of the ith element is expected to be
	scorei = jn    j!inj/m 1/j	 1 
모using the described distribution scores  we estimate the values of cl and cr that give the minimum values of dl and dr for the general rank-join plan in figure 1  b . let the output of l be the output of rank-joining l ranked relations. let the output of r be the output of rank-joining r ranked relations. let k be the number of output ranked results required from the subplan  and s be the join selectivity. then minimizing 붻 = 붻l cl  + 붻r cr  amounts to minimizing 붻 =  l!clnl 1/l +  r!crnr 1/r. we substitute  and minimize 붻 with respect to cl. the minimizations yield:
	crl+l =  r! sll kll! nrrr rlllrl	 1 
r	r r! llrl sdl = cl 1 + r/l l 1 dr = cr 1 + l/r r 1 	cr+l =  l! rkrnl rrrl	 1 
note that dl and dr are strict upper-bounds assuming worst-case behavior. for an average case analysis  assume that l follows a ul distribution and r follows a ur distribution with each having n tuples. the join of l and r produces another relation  g with a ul+r distribution and sn1 tuples. using equation 1 and setting j = l + r and m = sn1  the score of the top kth tuple in g is scorek =  l + r n     l + r !knl+r 1/s 1/ l+r . hence  we need to check in l  r  up to a tuple that joins with r  l  to produce scorek. we can show that on average  dl and dr can be computed as follows:

모because the distribution of the depths is tight around the mean  we can apply the formulas recursively in a rank-join plan  as shown in algorithm in figure 1  by replacing k of the left and right subplans by dl and dr  respectively. the value of k for the top operator is the value specified by the user in the query.
1. experimental verification of the estimation model
모in this section  we experimentally verify the accuracy of our model for estimating the depths  input size  of rank-join operators and estimating an upper-bound of the buffer size maintained by these operators. estimating the input size and the space requirements of a rank-join operator make it easy to estimate the total cost of a rank-join plan according to any practical cost model.
1 implementation issues and setup
모all experiments are based on a research platform for a complete video database management system running on a
모sun enterprise 1 with 1 ultrasparc-ii processors running sunos 1 operating system. the prototype is built on top of an open-source database management system that allows us to implement a simple cost-based rank-aware optimizer in the query engine  details are omitted for expository reasons . we have implemented a simple dp join enumerator that generates all possible rank-join plans in a bottom-up fashion. in the experiments conducted in this section  the user query provides the system with an example image and requests the most similar video objects  segments or snapshots  to the query image based on multiple visual features. the visual features are extracted from the video data and are stored in separate relations. high-dimensional index access paths are available on these relations to rank the objects according to each of the corresponding features. example features include color histograms  colorhist   color layout  colorlayout   texture  texture  and edge orientation  edges . hence  for a multi-feature similarity query  each input ranks the stored video objects according to a single feature. the top-k query produces the k objects with the top combined scores. we use the following top-k query:
q: retrieve the k most similar video shots to a given image based on m visual features.
모in the implemented prototype  we automatically show the generated evaluation  sub plans at each level of the dp algorithm. we only display  templates  of the execution plans. each of these plan templates generates several evaluation plans by changing the join implementation choices  switching the join order  or gluing sort operators to enforce interesting order properties.
모figure 1 gives a snapshot of the plan generation interface for joining 1 inputs. we focus on the first complete generated plan and annotate it in figure 1 for easy referencing. we refer to this plan as plan p.
1 verifying input cardinality estimation
모in this experiment  we evaluate the accuracy of the depth estimates of rank-join operators. we conducted several experiments on a variety of example evaluation plans of query q. since all experiments show similar behavior  we show a representative sample results for this experiment. the results shown here represent the estimates for plan p in figure 1. we use hrjn as the implementation of the rankjoin operator. k ranked results are required from the top rank-join operator in the plan.
varying the number of required answers  k  for different values of k  figure 1  a  compares the actual values of d1 and d1  refer to figure 1  with two estimates: 1  any-k estimate  the estimated values for d1 and d1 to get any k join results  not necessary the top k   and  1 top-k estimate  the estimated values for d1 and d1 to get the top k join results. any-k estimate and top-k estimate are computed according to section 1. the actual values of d1 and d1 are obtained by actually running the query and by counting the number of retrieved input tuples by each operator. figure 1  b  gives similar results for comparing the actual values of d1 and d1 to the same estimates. the figures show that the estimation error is less than 1% of the actual depth values. in general  for all conducted experiments  this estimation error is less than 1% of the actual depth values. note that the measured values of d1 and d1 lie between the any-k estimate and the topk estimate. the any-k estimate can be considered as a lower-bound on the depths required by a rank-join operator.
varying the join selectivity figure 1 compares the actual and estimated values for the depths of plan p in figure 1 for various values of the join selectivity. for low selectivity values  the required depths increase as the rank aggregation algorithm needs to retrieve more tuples from each input to have enough information to produce the top ranked join results. the maximum estimation error is less than 1% of the actual depth values.
1 estimating the maximum buffer size
모rank-join operators usually maintain a buffer of all join results produced and cannot yet be reported as the top k results. estimating the maximum buffer size is an important parameter in estimating the total cost of a rank-join operator. in this experiment  we use plan p in figure 1. the left child rank-join operator in plan p needs d1 and d1 tuples from its left and right inputs  respectively  before producing the top k results. the worst case  maximum  buffer size occurs when the rank-join operator cannot report any join result before retrieving all the d1 and d1 tuples. hence  an upper bound on the buffer size can be estimated by d1s  where s is the join selectivity. we use our estimates for top-k depths  d1 and d1  to estimate the upper bound of the buffer size. we compare the actual  measured  buffer size to the following two estimates:  1  actual upper-bound  the upper bound computed using the measured depths d1 and d1  and  1  estimated upper-bound  the upper bound computed using our estimation of top-k depths.
모figure 1 shows that the estimated upper-bound has an estimation error less than 1% of the actual upper-bound  computed using the measured values of d1 and d1 . figure 1 also shows that the actual buffer size is less than the upper-bound estimates. the reason being that in the average case  the operator progressively reports ranked join results from the buffer before completing the join between the d1 and d1 tuples. the gap between the actual buffer size and the upper-bound estimates increases with k  as the probability of the worst-case scenario decreases.
1. related work
모another approach to evaluate top-k queries is the filter/restart approach  1  1  1  1 . ranking is mapped to a filter condition with a cutoff parameter. if the filtering
모

figure 1: example rank-join plan.	figure 1: a snapshot of the plan generation interface.

	 a 	 b 
figure 1: estimating the input cardinality for different values of k.

	 a 	 b 
figure 1: estimating the input cardinality for different values of join selectivity.
모
produces less than k results  the query is restarted with a less restrictive condition. the final output results are then sorted to produce the top k results. a probabilistic optimization of top-k queries is introduced in  to estimate the optimal value of the cutoff parameter that minimizes the total cost including the risk of restarts. optimizing top-k queries that contain only selection has been studied in  in the context of querying multimedia repositories. the optimization in  focuses on determining the best way to execute a set of filtering conditions given different costs of searching and probing the available indexes.
모in contrast to previous work  we focus on optimizing ranking queries that involve joins. moreover  our ranking evaluation encapsulates optimal rank aggregation algorithms. to the best of our knowledge  this is the first work that tries to estimate the cost of optimal rank aggregation algorithms and incorporate them in relational query optimization. we believe that the proposed optimization model for filtering operations in  can be used in tandem with our proposed optimization technique for selection predicates.

figure 1: estimating the buffer size of rank-join.
1. conclusion
모we introduced a framework for integrating rank-join operators in real-world query optimizers. our framework was based on two key steps. first  we extended the enumeration phase of the query optimizer to generate rank-aware plans. the extension was achieved by providing rank-join operators as possible join choices  and by defining ranking expressions as a new physical plan property. the new property triggered the generation of a new space of ranking plans either  naturally  by using rank-join operators or  enforced  by gluing sort operators to sort the partial results. next  we provided a probabilistic technique to estimate the minimum required input cardinalities by rank-join operators to produce top k join results. estimating the minimum required input cardinalities emerged from realizing the unique  earlyout  property of rank-join operator. unlike traditional join operators  rank-join operators do not need to consume all their inputs. hence  estimating the cost of rank-join operator depends on estimating the number of tuples required from the input.
모our proposed estimation model captured this property with estimation error less than 1% of the actually measured input cardinality under some reasonable assumptions on the score distributions. we also estimated the space needed by rank-join operators with estimation error less than 1%. we conducted several experiments to evaluate the accuracy of our estimation model and the validity of our enumeration extension. the results proved the concept and showed the robustness of our estimation to several parameters such as the number of required answers and the join selectivity.
