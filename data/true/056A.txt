　the hpm  heuristic procedure modification  system is a model of strategy learning and optimization  implemented as a processing environment within the prism production system package . this paper describes progress in getting hpm to emulate children's discoveries about basic addition procedures. hpm s goal-trace and production trace formalisms allow it to maintain a history of its actions which is both goal ordered and time ordered. heuristics about meaningful patterns in these traces guide the construction of new productions  which modify procedures by replacing or circumventing preexisting productions. 
1. introduction 
　young children  approx. 1 years  often add by a counting procedure called the  sum method . this method consists of  a  counting out a set of objects to represent the first addend;  b  counting out another set of objects to represent the second addend;  c  merging the two sets  and counting the number of 
objects in the new set. one strategy used by older children is the  min method   which starts with the larger number and increments it the number of times given by the smaller addend. this development can be modelled as an additive production system  in which the min procedure is obtained from the sum procedure by the insertion of a series of productions that mask or circumvent pre existing productions. 
　given an initial production system for the sum method coded in its goal structured formalism  the hpm system can discover for itself some of the productions in the additive set. its goal formalism allows hpm to maintain a history of its actions which is both time-ordered and goal-ordered. strategy transformation productions  which can fire in parallel with performance productions  respond to patterns in this history by building productions which predict future outcomes  in addition to productions which produce changed performance. the patterns which evoke initial strategy transformation productions each represent a different heuristic for suggesting when and where a certain type of transformation might be fruitful. 
　like barr  1   i am concerned with exploring how metaknowledge can be exploited in an intelligent learning system. the key concept in hpm is the specification of conventions to be followed when processing goals and passing information between them. their existence allows informal strategy change heuristics to be respecified formally as productions with their conditions 
the research reported in this paper was supported in part by nimh grant 
*mh1   and by arpa grant # f1 c 1 
expressed as propositions in the goal-description formalism. this enables the system to carry out strategy transformations by having those productions construct new productions which mask or circumvent preexisting productions. the formalism which implements the conventions also has the benefit of imposing constraints that reduce the reasoning power required to construct appropriate changes. 
　hpm is part of a larger project on procedure learning and optimization 1. the program is a self-modifying production system  implemented in maclisp on a pdp kl-1. its design has been influenced by analyses of human performance in procedure learning tasks. these analyses indicate that procedure modifications involve precompiled heuristics for applying transformations  simple procedures for producing particular kinds of changes. 
　neches  describes 1 application heuristics associated with various transformation types. the heuristics subsume most of those suggested by anzai & simon . this paper  however  will present only the heuristics actually implemented in the hpm system: 
  result still available: if a procedure is about to be executed with a certain input  but the result of that procedure with the same input is recorded in working memory  then try to borrow that result now and in the future.  requires procedure/goal  input  result  time  and processing 
information.  
  untouched results: if a procedure produces an output  but no other procedure receives that result as input  then try deleting the procedure.  requires procedure/goal  input  result  and episode information.  
  effort difference: if a difference in expended effort is observed when the same goal is operating on the same input s  at different times  then set up a goal to find a 
difference between the methods used  and try to produce the circumstances which evoked the more efficient method.  requires effort  procedure/goal  input  event  and subgoal information.  
　as the parenthesized notes indicate  each of these heuristics depends on the availability of certain information about a 
　procedure's processing history. the formalism described in section 1 is designed to capture the information required by such heuristics. retaining that information  although necessary to enable learning  makes hpm vulnerable to breakdown under a glut of extraneous information. section 1 briefly describes mechanisms for handling the information explosion problem. 
   this section has been greatly abbreviated due to limited apace. please consult this reference lor more details 
1 
　
once these issues are clarified  it is possible to examine the operationalization and application of these heuristics  the topic of the remaining sections. 
1. execution history: the goal trace and the production trace 
　hpm fundamentally operates by manipulating propositions stated as node relation object triples. an object can be either a node  a proposition  a list of nodes  or a list of propositions. activation is associated with propositions. 
　the condition  or left hand side  lhs   part of productions match against sets of propositions in active memory. when a production matches successfully and is selected for firing  its action part  or right-hand side  rhs   contains  a  propositions which are added to the semantic network and made active; and/or   b  actions  or rhs functions  which perform computations without necessarily adding propositions to memory. 
　hpm uses prism's trace-data option to invoke a procedure after each production firing that adds a description of the firing to active memory. the description reflects the production instantiation rather than the production itself. 
　hpm represents processes in a hierarchical goal structure similar m organization to sacerdotis  planning nets. goals are decomposed into partially ordered lists of subgoats until executable goals are reached. each goal is represented in terms of relations from a common node to other objects which define it. the rules of the representation constrain the form of hpm productions  procedures are productions that build goal structures. 
　for example  one of the first rules in a production system for addition by the sum method is.  to add two numbers  generate sets corresponding to them and then count how many elements the two sets contain.  figure 1a shows the goal-trace propositions involved in this production  with those matched as conditions shown with dark lines and those added as actions shown with lighter lines. figure 1b shows the corresponding production trace propositions. 
　the production responds to a goal to add by building structures in the network representing goals to generate-sets and count-up. these are linked by a subgoal relation from the initial goal  and a then relation from the first subgoal to the second these establish the goal subgoal hierarchy and the ordering of subgoals. input and result relations from the goal nodes point to nodes describing operands of the goals. these are 
described in terms of various relations  with the most important being value  which indicates the concept instantiated by an operand. 
　the goal and value relations are hpm's means of representing the type token distinction discussed by woods . hpm's strong type token distinction means that objects are represented in network structures of some potential complexity. to avoid comparison problems   formal-value  tags  associated with nodes in the semantic network  are constructed in a canonical fashion which causes nodes representing equivalent structures to have identical tags. this enables hpm to immediately recognize equivalent objects by comparing their tags. 
　as figure 1 illustrates  a production must only specify the propositions relevent to its own processing; it need not indicate all relations from a node nevertheless  it is required to construct a 
1 
goal trace representation by using only a restricted set of propositions and obeying their semantics. the semantics of the goal trace representation allow only the following types of nodes: 
 a  goal nodes;  b  data nodes  which instantiate concepts;  c  set nodes  used for concepts which represent sets of data nodes; 
 d  firing event nodes  discussed previously:  e  prediction nodes  discussed in section 1; and.  f  effort nodes  which have a numeric value associated with them representing the estimated processing effort of a goal. 
　an hpm production system for solving a task primarily consists of productions which add goals  such as was just illustrated   productions which set up data structures tor goals requiring iteration by establishing has data relations from the goals to data nodes  and productions which terminate processing of a goal by manipulating result  value  and status relations. 
　these goal structures are augmented by system productions which collect information. for example  effort estimation is managed by two hpm system productions. the estimate is linked to goal nodes by the 'effort relation. 

　
　in summary  productions build goal structures similar to many familiar goal representations. thus  hpm can express a range of procedures and processing constructs. the goal structure remains afterwards  and forms a trace of a procedure's actions. hpm also retains a production trace  which indicates the conditions under which portions of the goal trace were created or modified. section 1 will consider how the information contained in the goal and production traces is utilized by strategy modification heuristics. however  that discussion requires some understanding of hpm's mechanisms for managing the information explosion entailed by retention of the two forms of trace data  the topic of section 1. 
1. hpm processing mechanisms 
　by the very nature of learning  a self-modifying system cannot know in advance what it will learn in a specific case. therefore  it also cannot know in advance what information it will require to do that learning  which in turn implies that it must retain all information which it is likely to need. 
　the implication of this observation is that a large information base is an unavoidable requirement of a realistic model of performance and learning. this places greater stress on the attention-focusing mechanisms of production systems. since they must retain a potentially large body of extraneous information in order to avoid missing critical information  it becomes crucial that learning systems have effective means for concentrating attention on important data and avoiding distractions inherent in a larger information space. two processes affect focus of attention in hpm: associative retrieval and conflict resolution. 
1. goal-driven associative retrieval 
　hpm has a mechanism called  goal driven spreading  for associative retrieval by spreading activation. when any proposition is asserted  the scheme activates all other propositions about nodes contained in that proposition. when a goal becomes active  activation is spread not only from the proposition describing the goal  but also from the proposition s  describing its inputs and goal type. similarly  when a goal is terminated  activation is spread from the propositions describing its result  its planned successors  and the goal which invoked it. 
　associative retrieval functions as an attention focusing mechanism by allowing hpm to partition its memory into active and non active sections  with the non-active section automatically eliminated from consideration. goal-driven spreading activation helps reduce the size of active memory. it enables retrieval of indirect associates most likely to be relevent to the system's immediate performance and learning goals  while avoiding the combinatorial explosion inherent in activating all indirect associates. 
1. by-class conflict resolution 
　even under this context-sensitive associative retrieval method  active memory can still be quite large. this produces an increase in matches - many more productions are likely to find matching data  and many of those productions are likely to have more than one way to match against the data. this introduces the familiar problem of  conflict resolution . 
　parallelism simplifies these problems. first of all  it reduces the demands on conflict resolution by lowering the criterion of success. finding a single  best  production instantiation is difficult to do satisfactorily; it is much easier to find a set of  good  productions which do not interfere with each other. 
second  paralleliam - like the notion of  beam search  in the harpy system  -  helps avoid errors due to premature restriction of attention. third  it enables reducing active memory size because important data will be attended to promptly upon its assertion and can safely be eliminated from active memory much earlier than in a serial system. reducing memory size reduces the number of potential uninteresting matches  thereby easing the conflict resolution problem. 
　hpm emulates a parallel production system. productions are grouped into six different classes  with a separate conflict resolution policy for each class. the production instantiations fired on a given cycle represent the union of selections from the individual classes. productions in different classes can be presumed not to interfere with each other  and can safely fire in parallel. the circumstances under which productions in the same class might interfere with each other depend on the task performed by that class. therefore  conflicts are resolved by class-specific policies. 
　the six conflict resolution classes currently distinguished by hpm are: 
  goal manipulation: productions which operate upon goaltrace structures. 
  data bookkeeping: productions which maintain the correctness of hpm's representation of complex data objects. 
  goal-bookkeeping: productions which maintain correctness of goal structures. 
  data-description: productions which add information representing knowledge about properties of data objects. 
  strategy-change noticing: productions which detect or predict situations relevent to development of a strategy change. 
  strategy-change-maker: productions that perform actions which effect changes to a procedure  usually by building a new production. 
1. an example: discovering improved addition strategies 
　this section is concerned with showing how the hpm goal trace formalism applies to the simulation of cognitive processes. 
1. the sum strategy for addition 
　psychological researchers have shown that very young children who solve addition problems by a sum or  counting-all  method can discover min . the essential properties of sum are that external objects  e.g.  fingers or blocks  are counted out to represent each addend  and that these sets of objects are then merged and the combined set counted in order to produce the sum. 
　the hpm production system for sum requires 1 productions. following is a summary of its operation  with the names of key productions given in parentheses. unless otherwise stated  the productions belong to the goal-manipulation class. 
　the production system solves addition problems by asserting goals to generate sets and count-up the sets  addition-
plan   in response to a goal to add  goal-to-add . the first goal is decomposed into two goals to make-a set  one for each addend {goal to-generate-sets . these goals produce sets of objects corresponding in size to the addends. both spawn a aeries of correspond-element goals  which produce pairings of objects with numbers {make*-set of-fingers. goal to correspondelements . each of these objects is appended to a set associated with the makeaset goal. in both cases  the series of correspondelement goals is terminated when an object is appended to the set that has a number assignment matching the appropriate addend  have-a-set . after the two sets are constructed by the make a set goals  a set representing their merger is constructed during termination of the generatesets goal  sets-have been generated . 
　the count up goal then becomes active  continue plannedsubgoai in the goal bookkeeping class   and counting of that set is initiated  start counting-up . the counting involves finding objects in the set of objects-to be counted  assigning a new number to them  and appending them to a set of counted objects. this process is also accomplished by a sequence of correspondelement goals  count-element . the sequence is terminated when the set of counted objects matches the set of to be counted objects  finished-counting up . the answer is then given by the size of the counted objects set  finished-adding . 
1. strategy transformations in hpm 
　the goal trace formalism is designed to facilitate domainindependent heuristics for modifying procedures  like the three mentioned in section 1. this section discusses their application in modifying the sum strategy; the next section illustrates how they are operationalized by discussing the implementation of the first heuristic. 
　hpm gets from sum to min through a series of incremental refinements. the first involves eliminating redundancies in counting up the combined set of objects representing the two addends. since counting consists of creating a set of objects in which numbers have been assigned sequentially to each object in the set. there is a point where the counting up process creates a set of objects and number assignments equivalent to that created when building a set to represent one of the addends. after that point  the process continues adding to the set by taking objects corresponding to the other addend  which makes the set unique. 
　at this intermediate point  however  it is possible to recognize through the result still available heuristic that the counting out for one addend  i.e.. the result of a make-a-set goal  can also serve as part of the counting up process  i.e.  as an intermediate result in processing the count up goal . when a production is built that implements the change  the resulting procedure differs in that the count up goat starts its iteration of correspond* element subgoals with a set containing the elements produced by one of the make a set goals  rather than starting with an empty set. this causes processing to pick up with the result of the other make aset goal. rather than counting all of the objects in the combined set  the new procedure therefore counts only the objects representing one of the addends  but counts them starting from the number given by the other addend instead of starting from 1. 
   now  when double-counting of the one addend is eliminated in this fashion  an inefficiency is introduced which can be detected through the untouched-results heuristic. when the objects produced under make a set goal are no longer counted under the count-up goal  they are not really used at all. that is  there is no point in creating these objects if they aren't going to be counted. the only function which they still serve is to give the starting number for counting up the objects representing the other addend. that information can be gotten elsewhere  however  since the size of the set representing an addend is  of course  given by the addend itself. 
　this change is realized by building a production which responds to the make a set goal used in the first strategy change to speed up processing of the count-up goal. the production asserts that the make a set goal has assigned to an object the number given by the addend which was input to the goat this satisfies its termination conditions  causing the goal to complete with a single element set as its result. that single element has the correct number assignment for initializing 
counting of the objects representing the other addend. note that this new production would give an erroneous result if it fired to all instances of make a set goals. however  the conditions of the new production are constructed from the production trace. therefore  the conditions describe the context for asserting the particular goal instance that is used in the first shortcut  and the new production will not fire in the general case. the result of this second change is a procedure which counts out objects corresponding to one of the addends  and then counts up those objects starting from the number after the other addend. 
　when one or both of these changes are made  the opportunity is created for hpm to discover effort differences between different trials with the same problems. this is because the effort involved depends on whether the addend treated specially is the larger or smaller of the two effort is minimized in the case where objects are generated to represent the smaller addend and their counting is initialized by the larger addend the result is a procedure in which  for problems in which the other shortcuts would treat the smaller addend specially  the problem is first transformed into an equivalent form where the larger addend is taken as special. problems in which the shortcuts would initially be applied to the larger addend are left as they are. this new procedure has the properties of the min procedure: effort is now proportional only to the size of the smaller addend  but there is a small effect of the order of the addends1. 
　it is important to note that the independence of these last two strategy changes means that they can take place in either order  which means that hpm can follow several different paths from sum to min. 
1. operationalization of heuristics 
　we have seen that very straightforward heuristics can be used to account for transitions between procedures. operationalizing these heuristics in hpm requires dealing with the following set of problems:  a  detecting instances of situations described in the heuristics' conditions;  b  determining the precursors of those situations  i.e.  learning to predict them;  c  constructing 
appropriate new actions for productions which implement strategy changes; and.  d  discovering the range of application for a new production. this paper is primarily concerned with  a  through  c . where the goal trace conventions permit making assumptions that greatly simplify the problems. 
1. determining applicability of heuristics 
　the approach taken in hpm to operationalizing conditions for heuristics basically consists of re-expressing the conditions as patterns in sets of goal-trace propositions. it is not essential that all of these patterns co exist in time  because of the production trace. 
latter observation was first reported by svenson   and has been 
confirmed in recent studies of his reported in a personal communication 
　
　in the result-stillavailable heuristic  the stated condition is that a previously computed item is needed again. however  this explicit condition really consists of several implicit conditions which go into deciding that an item is  needed again  in hpm  the first step begins when the system notices that the input for a goal is something that has been used before. this post hoc discovery comes too late for hpm to change its course of action on that trial; hpm cannot tell that it will re-use a computed value  only that it just has reused one. since inputs can come to a goal either as the result of another goal or through a hasdata relation from a higher-level goal  two versions are needed of the production which makes this discovery. figure 1 illustrates the production which applies when the current source of a goal's input is a has data node. this is the production which initiates the first strategy transformation in the development from sum to min. 
considerkeep-partials-for-datanode: 
if a goal has just been asserted with a particular data node as input  there is a different data node with an equivalent value  the goal was established in response to a has data relation between the input and a higher goal  and trace-data is available for the production asserting the goal and for the actions of the production which terminated the goal that had the other data node as its result  
then build a production to predict that this relationship will recur: 
if another instance of this goal is asserted with this input under the equivalent conditions  and another instance of the other goal terminated in the same way as observed this time  
then predict that the result of that other goal will be equivalent to the input of the new goal-instance. 
figure 1. 
　the conditions for the production can be put into three groups: conditions governing when it fires  ensuring that it will fire as early as possible   main conditions checking that criteria for firing the production are met  in this case  that the goal's input has a potential alternative source   and conditions which pick up data needed on the action side of the production  by inspecting the production trace to find the context in which the earlier source completed and the current source was asserted . 
1. finding conditions for the new production 
　the action of the first production builds a new production which essentially predicts that the same situation  if observed again  would produce the same relationships between goal trace propositions. that is  the prediction is that any goal terminating with equivalent assertions to the observed earlier source will have its result equivalent to the input of any goal asserted under conditions equivalent to those for the observed current goal. 
　since a new prediction production is only built when the prediction is known to be true for the current case  hpm behaves as if the prediction had been made and tested for that case. this causes a strategy transformation production to fire and build a second production which will change the strategy. the strategy transformation production is shown in figure 1. 
keep partial-set -for-data: 
if a goal has just been asserted with a particular data node as input  there is a different data node with an equivalent value  the goal was established in response to a has-data relation between the input and a higher goal  and trace-data is available for the production asserting the goal and for the actions of the production which terminated the goal that had the other data node as its result  and a prediction has been asserted and confirmed that the goal's input and the other data node would match  and the input is a set with an element as current member  
and the other data node has some relation associating it with an element equivalent to that current member  
then construct a production to avoid recomputation of the set by copying the prior data node over: 
if the evoking conditions are present for the production which asserted the hasdata relationship between the higher goal and the current input of the current goal  andan instantiation of the goal which produced the alternative source has both been asserted and completed under the same circumstances as this occasion  and that goal's result has relations that correspond to those needed to predict what the current member should be  
then assert that the higher goal has data to a node which has the set represented by the alternative source as its subset; assert a current-member for this new set  along with any other relations used in the conditions of the goal of interest. 
figure 1. 
　as before  there are several versions of the production in order to allow for each of the alternative information-passing methods which can be used in the goal-trace formalism. the one shown is the version which applies in making the first strategy change. its first conditions require that a successful prediction has been made. like the noticing production  it also contains conditions which identify the context in which the new source goal was terminated. in addition  it contains conditions which identify the circumstances under which the to-be-replaced goal was asserted. finally  it has conditions specialized for has-data data nodes which represent sets; these conditions test whether the current goal makes use of any propositions allowed in describing sets  e.g.  the current-member relation  or other data objects. related to those conditions are others which seek to find or construct the analogous propositions for the result of the potential new source goal. 
　when the production actually builds the production for the strategy change  the conditions of that production are derived from the conditions just described. first  they borrow the conditions which led to assertion of the data's current source. this ensures that the new production can fire at the time the source would have been asserted  thus enabling it to override the production which would do so. second  they borrow the terminating conditions of the goal which first produced the data. this ensures that the value is available to be copied  and that the new production has the ability to do so. third  they borrow the initiating conditions of the first goal  expressed in terms of the production trace since they may no longer be true at the critical point in time. these conditions increase the likelihood that the new production will fire only in siuations closely equivalent to the 
　
current situation. finally  the new production is given the conditions needed to specify auxilary propositions such as current member relations. figure 1 provides an example of a new production resulting from this process. this new production  which implements the first shortcut for the problem 1  + 1  will compete with the start counting up production mentioned in section 1. 
if a set containing a left thumb  a left index finger  a right thumb  a right index finger  and a right middle-finger is input to 
an active count-up goal  
and that goal has no has data node. 
and a goal to make a set that produced a left thumb and a left index finger is done  and that goal was asserted as a subgoal of a generate sets goal  and the set produced by the make-a set goal has a left-thumb as its first and a left index finger as its last element  and the set is of size 1  
then assert that the count up goal has-data to a node which has the make a set goals result as a subset  the left thumb as its first member  the left-index finger as its current and last member  and the number two as its size. 
figure 1. 
1. determining appropriate actions for new productions 
   the actions of the new production are almost entirely determined by the constraints of the goal trace formalism. this is exactly the point of having such a formalism; the amount of reasoning which the system must do in order to construct a change is minimized. in this case  the intent to borrow a 
   previously generated set in order to avoid reconstructing it completely determines the actions. having found that the set was constructed as a hasdata node attached to a higher level goal  the first thing to do is to replace that node with one representing the previously computed set. however  it is only necessary to set up the new linkages  since the production's conditions ensure that it fires in place of the productions which would have added the old linkages. since the constraints of the formalism say that elements may be added to a set while an active goal has a has-data link to it  the production asserts propositions creating a new set which has the previously computed set as a subset. this maintains the correctness of the goal trace if additional members are added to the set. as is the case here  because the additional members are represented as belonging to the  copy  of the set rather than the original set. the goal-trace formalisms for sets  and the hpm system productions which maintain them  guarantee that the original and the copy are treated identically when their values are accessed but are distinguished when querying the source of those values. 
　the other actions of the new production are also determined by the constraints of the formalism. when a data node representing a set is being made available to subgoals by a hasdata relation  there is a restricted set of possible propositions which might be accessed by those subgoals. the remaining actions of the productions assert propositions which duplicate those which appeared in the set being copied. 
　this new production will fire just after assertion of a count-up goal  skipping to the point just after counting of the set representing the first addend. its specialized conditions make it applicable only for the particular problem  1 + 1. methods for generalizing such productions are discussed in . 
　this change opens the way for the effort difference and untouched results heuristics to apply in later strategy changes. 
1. closing notes 
　three features of hpm are especially important. formal-value tags let hpm represent subtle type/token distinctions without losing the ability to detect higher level identities between the objects represented. goal driven associative retrieval helps hpm ameliorate problems of large working memory size while still ensuring that potentially relevent data will be in active memory. by class conflict resolution lets hpm fire productions with fewer concerns about introducing unintended interferences or database inconsistencies. 
　the most important aspect of hpm is the notion of a goal trace formalism these conventions for specifying procedures and actions in the system cause those procedures to leave a history of their execution behind them. this history is a hierarchical semantic network representation of the process that preserves information about relations between goals and data. the parallel notion of a production trace preserves information about both the time-ordering of events and the context in which goals were initiated and terminated. 
　the existence of the formalism greatly simplifies the implementation of heuristics for improving procedures  by providing a formalism tor specifying them and by imposing constraints which reduce the reasoning power required to construct appropriate modifications. furthermore  the domain independent conventions move the system closer to the goal of being able to demonstrate domain independent learning capabilities. 
