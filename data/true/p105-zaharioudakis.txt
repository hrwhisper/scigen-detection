we investigate the problem of using materialized views to answer sql queries. we focus on modern decision-support queries  which involve joins  arithmetic operations and other  possibly user-defined  functions  aggregation  often along multiple dimensions   and nested subqueries. given the complexity of such queries  the vast amounts of data upon which they operate  and the requirement for interactive response times  the use of materialized views  mvs  of similar complexity is often mandatory for acceptable performance. we present a novel algorithm that is able to rewrite a user query so that it will access one or more of the available mvs instead of the base tables. the algorithm extends prior work by addressing the new sources of complexity mentioned above  that is  complex expressions  multidimensional aggregation  and nested subqueries. it does so by relying on a graphical representation of queries and a bottomup  pair-wise matching of nodes from the query and mv graphs. this approach offers great modularity and extensibility  allowing for the rewriting of a large class of queries.    
 
1. introduction 
 
recent years have seen rapid growth in the area of decisionsupport queries. such queries typically operate over huge amounts of data  many terabytes   performing multiple joins and complex aggregation. furthermore  they are becoming increasingly more interactive  requiring response times in the order of seconds. traditional optimization techniques often fail to meet these new requirements. in such cases  a solution often used in practice is to create a number of materialized views  mvs  that contain the precomputed results of the common operations in a set of user  queries; individual user queries can then be optimized by accessing the mvs instead of the raw data. 
 
permission to make digital or hard copies of part or all of this  work or personal or classroom use is granted without fee    provided that copies are not made or distributed for profit or    commercial advantage and that copies bear this notice and the    full citation on the first page. to copy otherwise  to republish  to   
post on servers  or to redistribute to lists  requires prior specific  permission and/or a fee. 	 mod 1  dallas  tx usa  c  acm 1-1-1/1 . . .$1 
 
in this paper  we present an algorithm that is able to take advantage of mvs by proving that the contents of an mv and a user query overlap  and compensating for the nonoverlapping parts. when an overlap exists  we say that the query and the mv match. after discovering a match  the query can be rewritten so that it will access the mv instead of one or more of the base tables. we consider mvs that are expressed as sql queries with aggregation. given their transparent  automatic  use in optimization  and the fact that they summarize the raw data via aggregation  we refer to such mvs as automatic summary tables  asts . experience with the tpc-d benchmark and several customer applications has shown that asts can often improve the response time of decision-support queries by orders of magnitude. such performance advantages have made asts indispensable in data warehousing environments. of course  for a complete ast solution  the following related problems must also be addressed:  a  finding the best set of asts for each workload under space and/or update overhead constraints   b  deciding whether an ast should actually be used in answering a query  and  c  maintaining the asts efficiently when the base tables are updated. examples of existing work on these problems include     and  for  a    b   and  c   respectively.  
 
in the remainder of this section we describe a sample db schema  give an example of matching  and list our main contributions. in section 1  we briefly explain the query graph model. in section 1  we describe a general matching infrastructure  and then  in sections 1 and 1 we present a number of specific matching  patterns . in section 1  we give the details of how individual expressions from a query are matched with  or derived from  the expressions of an ast. in section 1  we review related work. finally  in section 1 we summarize the main points of the paper. 
 
1 sample database and example 
figure 1 shows the sample db schema that we have used for the examples in this paper. the schema contains a single fact table  trans   which records credit card transactions. each transaction corresponds to the purchase of one product  and records the product group  fpgid   the location  flid  and date of the purchase  the credit card id  faid   the number of items purchased  qty   and the price and discount rate for the product. the product groups  locations  and credit card accounts comprise three of the schema's dimensions. the product dimension consists of a single level recorded in the pgroup table. the location dimension contains city  state  and country levels  and is represented by a single  de-normalized table  loc . the account dimension contains two levels  represented by the cust and acct tables. the schema contains a time dimension as well  which is encoded in the date field of the trans table. the time levels  day  month  and year  are extracted from the date field using built-in functions. the arrows in figure 1 represent referential integrity  ri  constraints connecting the fact table to the dimensions.  

figure 1: simplified credit card schema 
q1: select faid  state  year date  as year  ast1: select faid  flid  year date  as year                   count *  as cnt                      count *  as cnt        from trans  loc            from trans
       where flid = lid and country = 'usa'           group by faid  flid  year date           group by faid  state  year date         having count *    1
newq1: select faid  state  year  sum cnt  as cnt               from ast1  loc               where flid = lid and country = 'usa'               group by faid  state  year               having sum cnt    1
figure 1: example of query rewrite 
an analyst of such an application will be interested in aggregating the transaction data along different dimensions and levels. for example  query q1 in figure 1 counts the number of transactions performed in usa per each account  state  and year and returns the counts that are greater than 1. if ast1 is defined as in figure 1  then q1 can be rewritten as newq1  which accesses ast1 instead of the trans table. given that the average customer performs a few hundred transactions per year  most of them within the same city  ast1 is about hundred times smaller than trans. therefore  newq1 should perform much better than q1. 
 
1 our contributions 
the problem of query matching has received considerable attention before. however  previous work has focused on certain simple query patterns only. in our work  we have build on such simple patterns in order to design a powerful algorithm that extends prior art in the following ways. 
1. modern sql applications make heavy use of subqueries. today  scalar subqueries can be used wherever a scalar is expected  and subqueries that return tables can be used wherever a table is expected. this flexibility leads to complex multi-block queries.  in the best scenario  existing algorithms can rewrite only the innermost query blocks using single-block asts. in contrast  the algorithm described here can match multi-block queries with multi-block asts. 
1. even in the context of single-block queries  existing algorithms cannot handle complex expressions very well. often  select and group-by lists are restricted to base table columns only or aggregate functions of base table columns. here  we extend the existing work to include arbitrary expressions.  
1. multidimensional aggregation  expressed via supergroup functions like cube  rollup  and grouping sets  is fundamental in decision-support applications. nevertheless  it has not been considered before in the context of matching. here  we present matching conditions for queries and asts that perform multidimensional aggregation.  
1. previous algorithmic descriptions have often been rather abstract. sometimes the emphasis is on theoretical results  and at other times  important details are omitted. in contrast  here we describe in detail a practical algorithm  a substantial portion of which has been implemented inside db1 udb. furthermore  the algorithm is modular and extensible; it consists of a generic matching infrastructure and a collection of matching conditions for specific query patterns. 
 
1. background: the qgm model 
 
in this section  we give a brief overview of the query graph model  qgm   which serves as the basis for our matching algorithm. in qgm  a query is represented as a rooted directed acyclic graph1 in which the leaf nodes  boxes  represent base tables  internal nodes represent table operations  and edges represent a flow of records from a child  producer  box to a parent  consumer  box. each nonleaf box produces a relational table after performing its operation on its input  which is a set of relational tables. the root qgm box produces the final query result. 
 
qgm boxes are labeled by the type of their operation. the two most common types are select and group-by. 
select boxes represent the select-project-join portions of queries; they apply the where or having predicates  and compute all of the scalar expressions that appear in select and group-by clauses. group-by boxes perform grouping and compute the aggregate functions. for example  the qgm graph for query q1 is shown in figure 
1. the bottom select box in the figure performs a join between the trans and loc tables  as specified by the flid = lid join predicate  applies the selection predicate country = usa to the records coming from the loc table  computes the year date  grouping expression  and passes on the values of this expression as well the values of the faid and state columns to the parent group-by box. the groupby box groups its input records by faid  state  and year  computes the number of records per group  and passes on the grouping columns and the counts to its parent. finally  the top select box applies the having predicate cnt   1 and exports the final result. it should be emphasized that qgm represents the query semantics and not any particular execution plan. for example  the bottom select box in figure 1 does not dictate whether the join is performed before or after the selection of the usa locations.  

figure 1: qgm graph for query q1 
as indicted by figure 1 and the above discussion  a qgm box is described by its type and by its input columns  output columns  and predicates. the predicates and the output columns are computed by expressions that are built using input columns. in the remainder of this section  we define these constructs in greater detail. 
 
the input columns  or qncs  in qgm terminology  of a box are the columns consumed by the box; their values are produced by the children of the box and flow along the edges that connect the box to its children. qncs are used  together with functions  operators  and constants  to build expressions. expressions that consist of a single qnc or constant are considered simple; otherwise  they are complex. expressions specify the computations for the output columns and the predicates of a box. predicates are found in both select and group-by boxes. select predicates may be simple selection predicates  join predicates  or selection predicates with subqueries. as a result  a select box may have multiple children  which are join operands or subqueries. group-by predicates describe the groups to be created. such grouping predicates are either simple qncs  like faid  state  and year in figure 1  or supergroup functions over simple qncs. group-by boxes have a single child always. the output columns  or qcls  in qgm terminology  of a box are the columns produced by the box itself. for select boxes  qcl expressions can be arbitrarily complex as long as they do not contain any aggregate functions. the reverse is true for group-by boxes; their qcls include all of the grouping input columns  plus aggregate functions over simple input columns.  given that all of the grouping qncs are qcls as well  we refer to such columns simply as grouping columns. the set of these grouping columns is the grouping set of the box.  it should be noted that a given qcl may be consumed by multiple parent boxes  and hence  there is a 1:n relationship between qcls and qncs.  
 
1. the matching framework 
 
as explained below  the matching algorithm is based on the idea of matching pairs of qgm boxes. in general  a box e matches with another box r  if and only if a qgm graph g e r  can be constructed such that g e r  contains the subgraph g r  rooted at r  and g e r  is semantically equivalent to the subgraph g e  rooted at e  i.e.  g e r  and g e  always produce the same result. if box e matches with box r  then g e r  - g r  is the compensation  that is  the set of operations that have to be performed on the output of r in order to get the same output as e. a graphical representation of this definition is shown in figure 1. if the compensation is empty  the match is exact and boxes e and r are equivalent; otherwise  box e is equivalent to the root box of the compensation. obviously  a non-exact match relationship is asymmetric; to distinguish the different roles of the two boxes in such a relationship  we call e the subsumee and r the subsumer. 

figure 1: the matching relationship  
having defined the match relationship  we can now present the matching algorithm  starting with its two main components: the match function and the navigator. the match function takes as input two qgm boxes and determines whether they match. ideally  the match function should implement the match relationship defined above. however  this definition is too general for practical use. in reality  the match function tries to approximate the match definition in meaningful and practical ways. it does so by considering certain simple  but general graph patterns  which consist of the given subsumee and subsumer  as well as the compensation boxes for the matches between the children of the subsumee and subsumer. for each pattern  the match function tests a number of sufficient conditions to determine if a match is possible. two such conditions that are common for every pattern are the following: 
 
1. at least one of the subsumee's children must match with some subsumer child.  
1. the subsumee and subsumer must be of the same type.  
 
the first condition makes sure that there is some minimum overlap between the two boxes. the second condition serves as a quick test  although it is somewhat restrictive1. 
 
the match function is driven by the navigator. the navigator scans the query and ast graphs in a bottom-up fashion  identifying potential pairs of matching boxes  where the subsumee comes from the query graph and the subsumer comes from the ast graph   and invoking the match function  until the root ast box is matched  if possible  with one or more query boxes. to perform its task  the navigator initializes a set of candidate subsumee/ subsumer pairs by forming all of the pairs between the leaves of the graphs. during each iteration  the navigator removes a pair from this set and passes it to the match function. if a match is established  the navigator forms all of the pairs between the parents of the subsumee and the subsumer. the navigator processes its set of candidate box pairs in an order that guarantees that during each invocation of the match function  the children of the two input boxes have been matched already  i.e.  the match function has been invoked on each pair-wise combination of the children. furthermore  the match function knows the compensations for the matches between the children. as a result  it does not have to look at the whole subgraphs of its input boxes; it needs to concentrate on the subsumee  the subsumer  and the child compensation boxes only.  
 
1. match function patterns 
 
in this section  we present a list of patterns for matching. the patterns listed here consist of select and/or simple group-by boxes  i.e.  group-bys with no supergroup functions. we start by considering patterns where all of the matches among the children of a candidate subsumee/ subsumer pair are exact. then we present patterns where the child matches have compensation. in each case  we first state the matching conditions  then describe the compensation  and finish with an example. it should be noted that the matching conditions are sufficient only  and as a result  they are correct only when viewed together with the associated compensation. due to space  correctness proofs are not included here; instead  some intuitive justification is given in the context of the examples. 
 
before we proceed  some more terminology must be established regarding the children of two select boxes in a candidate match. as we will see  it is possible to have a subsumee child that does not match with any of the subsumer children; such a subsumee child is called a rejoin child. it is also possible to have a subsumer child with no matching subsumee child; such a subsumer child is called an extra child and a join between an extra child and the rest of the subsumer is called an extra join.  
 
1 exact child matches 
1.1 select boxes with one-to-one child matches 
pattern: the subsumee and subsumer are select boxes and  a  each subsumee child matches with at most one subsumer child   b  no two subsumee children match with the same subsumer child1. 
matching conditions:  1  every extra join is lossless  i.e.  it does not duplicate or eliminate any subsumer rows.  1  every subsumer predicate that is not an extra join predicate is semantically equivalent  matches  with some subsumee predicate1.  1  every subsumee predicate matches with a subsumer predicate or is derivable from the subsumer's qcls and/or the qcls of the rejoin children  if any .  1  
each subsumee qcl is derivable from the subsumer's qcls and/or the qcls of the rejoin children.  a subsumee expression  predicate or qcl  is derivable  if it can be written as a function of the subsumer and/or the rejoin qcls. the details about expression equivalence and derivability are given in section 1.  
compensation: the compensation consists of the rejoin children  if any  and a select box that  a  rejoins the subsumer with the rejoin children   b  applies all of the subsumee's predicates that do not have matching subsumer predicates  and  c  derives all of the subsumee's qcls from the subsumer's qcls and/or the rejoin qcls. example: figure 1 shows a match between query q1 and ast1. the qgm graphs for q1 and ast1 consist of one select box joining three base tables. as explained below  the two select boxes satisfy all of the above conditions  and hence they match with a compensation that consists of a select box  sel-1  and the pgroup table.  the rewritten query is newq1 in figure 1. in this example  pgroup is a rejoin child and loc is an extra child. condition 1 is satisfied  as the ri constraint between columns flid and lid makes the join between trans and loc lossless. for condition 1  the relevant subsumer predicates are faid = aid and disc   1  both of which appear in the subsumee as well. as a result  the ast does not eliminate any rows that are needed by the query. for condition 1  the relevant subsumee predicates are fpgid = pgid  price   1  and pgname = tv  all of which are derivable. as shown in figure 1  these predicates become part of the compensation. with respect to qcl derivability  condition 1   two things are worth observing. first  the compensation derives q1's aid column from the ast's faid column. although aid and faid originate from different base tables  they are equivalent because of the faid = aid join predicate. our algorithm is able to recognize such column equivalence and thus derive aid from faid. second  the amt column can be derived from the ast using the qty  price  and disc qcls  or the disc and value qcls. as shown in figure 1  when alternative derivations are possible  we choose the one that involves the minimum number of subsumer qcls. 
q1: 
select aid  status  
          qty * price *  1-disc  as amt from trans  pgroup  acct where   pgid = fpgid and faid = aid      and price   1 and disc   1      and pgname = tvast1:
select tid  faid  fpgid             status  country             price  qty disc             qty * price as value from trans  loc  acctnewq1: 
select faid as aid  status            value* 1-disc  as amt from ast1  pgroup where  pgid = fpgid      and price   1where   lid = flid and faid = aid       and pgname = tv
figure 1: select boxes with exact child matches. 
1.1 group-by boxes 
pattern: the subsumee and subsumer are simple groupby boxes whose children match exactly.  
matching conditions:  1  every subsumee grouping column is semantically equivalent  matches  with some subsumer grouping column.  1  if the subsumee's and subsumer's grouping sets match exactly  i.e.  every subsumee grouping column matches with a subsumer grouping column and vice-versa  then every aggregate subsumee qcl matches with some subsumer aggregate qcl; otherwise  every aggregate subsumee qcl is derivable from the subsumer's qcls.  
compensation: no compensation is required if the subsumee and subsumer grouping sets match exactly. otherwise  the compensation consists of a group-by box that re-groups by the subsumee's grouping columns  and derives the subsumee's qcls from the subsumer's qcls. for aggregate functions  special derivation rules must be observed; these are listed below for the most common aggregates.  the rules can be combined to derive any other aggregate that is an algebraic expression of the listed functions.  throughout this list we assume that x is a subsumee qnc  y and z are subsumer qncs  z is nonnullable  and x and y are semantically equivalent. 
  
a. count *  is derived as sum cnt   where cnt is the count *  subsumer qcl or the count z  subsumer qcl. 
b. count x  is derived as sum cnt   where cnt is the count y  subsumer qcl. if x is non-nullable  then cnt might also be the count z  subsumer qcl. 
c. sum x  is derived as sum sm   where sm is the sum y  subsumer qcl. if y is a grouping column  then sum x  can also be derived as sum y*cnt   where cnt is the count *  subsumer qcl; in this case  the compensation includes a select box as well to compute the y*cnt expression before regrouping. 
d. max x  is derived as max max  or max y . in the first derivation  max is the max y  subsumer qcl; in the second derivation  y must be a grouping column. 
e. min x  is similar to max x . 
f. count distinct x  is derived as count y   if y is a grouping column. 
g. sum distinct x  is derived as sum y   if y is a grouping column. 
q1:	ast1:	newq1: 
select year date  as year  	select year date  as year 	select year  
           sum qty * price  as value          month date  as month       sum value  as value from trans          sum qty * price  as value from ast1

figure 1: group-by boxes with exact child matches  
example 1: in figure 1 the two select boxes  sel-1q and sel-1a  are matched first using the conditions from section 1.1. sel-1q and sel-1a match exactly1. as a result  the two group-by boxes  gb-1q and gb-1a  comply with the current pattern  and are matched using the current conditions. this match requires re-grouping compensation  box gb-1  in order to compute the query's yearly groups from the ast's monthly groups. additionally  the compensation derives the yearly sums by re-summing the monthly sums  using rule  c  above.  this derivation is correct because the ast's monthly sums are partial sums for the query's yearly sums.  
 
1 non-exact child matches 
when the children of a given subsumee/subsumer pair do not match exactly  then  in addition to the subsumee and subsumer  we must also consider the boxes that comprise the compensations for the non-exact child matches. usually  these child compensation boxes have to be included in the compensation for the parent match. this is called pulling up the child compensation boxes.  
 
1.1 group-by boxes with  select-only child compensation 
pattern: the subsumee and subsumer are group-by boxes whose children match with compensation that is a single1 select box  which may perform rejoins. furthermore  we assume here that if agg x  is a subsumee aggregate function  then qnc x originates from non-rejoin columns only  this assumption is relaxed in  . 
matching conditions:  1  every subsumee grouping column is derivable from the subsumer grouping columns and/or the rejoin qcls  if any .  1  if no regrouping compensation is required  then every subsumee aggregate qcl matches with some subsumer aggregate qcl. otherwise  every subsumee aggregate qcl is derivable from the subsumer's qcls.  1  pullup condition: every predicate in the child compensation is derivable from the subsumer's grouping columns and/or the rejoin qcls. compensation: the compensation includes the pulled up select box  potentially followed above by a group-by box. if the child compensation does not perform rejoins  then the rule for including or not the group-by box is the same as in section 1.1. otherwise  regrouping can be avoided only if the two grouping sets are the same and the rejoin is 1:n with the rejoin tables being the  1  side. if regrouping is required  then the aggregate functions are derived using the rules of section 1.1 again.  
q1: 
select year date  % 1 as year        sum qty*price  as value from trans
where  month date   = 1
group by year date  % 1	gb-1ast1:
select year date  as year         month date  as month         sum qty*price  as value from trans group by year date   example1  no rejoins : in figure 1  the two select boxes  sel-1q and sel-1a  are matched first  creating the sel-1 compensation box  which comprises the child compensation for the next match between the two groupby boxes. gb-1q and gb-1a satisfy all the conditions of the current section  and as a result  they match with a compensation that consists of boxes sel-1 and gb-1. sel-1 is the pulled-up version of sel-1. it is worth observing that sel-1 is not pulled up  as is ; as indicated by the pullup condition  only the predicates are pulled up. in contrast  the qcls that appear in sel-1 are created there as a side effect of deriving the subsumee's expressions  see section 1 . the reasoning behind this tactic of not pulling up the qcls can be explained in the context of the  x  qcl: x is needed in sel-1 to make that box equivalent to sel-1q. however  x is not preserved at the output of the parent gb-1q box; it is used there internally only  to compute the sums. furthermore  sum x  is derived from the ast as sum value . as a result  what we need in sel-1 is value  not x.  this pullup tactic is not unique to this pattern; it is used whenever compensation is pulled up. with respect to predicate pullup  we notice that the ast rows eliminated by the month   1 predicate in sel-1 are exactly the same rows  modulo duplicates  that are eliminated by the same predicate in sel-1q. as a result  the predicates in sel-1 and sel-1q have the same effect. finally  as in section 1.1  condition 1 of the current section guarantees that each subsumer group is a partial group of exactly one subsumee group. as a result  regrouping and re-aggregating in gb-1 produces the correct result.  
figure 1: group-by boxes with simple select child compensation 
example1  with rejoin : figugre 1 shows an example with rejoins. let's assume  for the moment  that the join between loc and trans in q1 is an n:m join. then  according to the above rules  the compensation between the two groupby boxes  gb-1q and gb-1a  must include a groupby box  gb-1 . to see why this compensation is correct  we first observe that q1 joins trans with loc  whereas newq1 joins ast1 with loc. given that ast1 is a summarization of trans  the outputs of sel-1q and sel1 differ only in the multiplicity of their rows; sel-1q produces more duplicates than sel-1. other than duplicates  however  sel-1q and sel-1 produce the same rows. furthermore  sel-1  remembers  the number of the lost duplicates in its cnt qcl. as a result  sel-1 does not lose any information  and the counts computed by the query can be derived in gb-1 by re-grouping and summing over the ast's cnt column. if we take into account the fact that the join between loc and trans is 1:n  then gb-1 is not needed because the join does not affect the multiplicity of the trans rows. furthermore  the effect of the country = usa predicate is to eliminate some whole groups  but it does not affect the number of trans rows that fall into each group. hence  the counts produced by q1 are the same as the counts produced by ast1. 
q1: select lid  year date  as year  count *  as cnt        from trans  loc
       where flid = lid and country = usa        group by lid  year date ast1:select flid  year date  as year                      count *  as cnt           from trans
          group by flid  year date    
figugre 1: group-by boxes with rejoin child compensation 
1.1 group-by boxes with group-by child compensation 
pattern: the general form for this pattern is shown in figure 1. the subsumee and subsumer are group-by boxes  gb-q and gb-a  and the child compensation contains at least one group-by box and a number  possibly zero  of select boxes. in figure 1  gb-cc1 is the lowest group-by box in the child compensation.  matching condition: to handle this pattern  the match function calls itself recursively  trying to match gb-cc1 with the subsumer  gb-a . this recursive invocation of the match function conforms to patterns 1.1 or 1.1: gb-cc1 plays the role of the subsumee  gb-a is the subsumer  and sel-cc1  if present  is the child compensation. if this intermediate match succeeds  then the original match  between gb-q and gb-a  succeeds as well. compensation: to build the compensation  we start with the intermediate compensation for the match between gbcc1 and gb-a. then  all the child-compensation boxes above gb-cc1 are copied above gb-pc1 in the parent compensation. for example  box-pcn is an exact copy of box-ccn. finally  the original subsumee  gb-q  is also copied at the top of the parent compensation  gbpc n+1  . to see why this construction is correct  we first notice that if gb-cc1 and gb-a match  then  by the match definition  gb-cc1 and gb-pc1 are equivalent. as a result  all boxes above gb-cc1 in the child compensation are equivalent to their copies in the parent compensation. in particular  box-ccn is equivalent to box-pcn. however  box-ccn is also equivalent to child-q  due to the match between child-q and child-a. we conclude that child-q is equivalent to box-pcn. as a result  boxes gb-q and gbpc n+1  are equivalent as well  because they are copies of each other and their children are equivalent. 

figure 1:group-by boxes with group-by child compensation  general form  
q1: select tcnt  count *  as ycnt        from  select year date  as year                             count *  as tcnt                 from trans
                group by year date   gb-1ast1:select year  tcnt  count *  as mcnt           from  select year date  as year                               month date  as month                               count *  as tcnt                    from transnewq1: 
figure 1: group-by boxes with group-by child compensation 
example: in the example of figure 1  q1 and ast1 are histogram queries; q1 prints out all of the yearly transaction counts  and for each such value it gives the number of different years during which that count was achieved. ast1 performs the same computation but for monthly transaction counts. in figure 1  box gb-1 is the compensation for the match between the two inner group-bys. boxes gb1 and sel-1 is the compensation for the match between gb-1 and gb-1a  where the conditions and rules of section 1.1 were used. finally  box gb-1 is a copy of gb-1q that completes the compensation for the match between gb-1q and gb-1a. 
 
1.1 select boxes with select-only child compensation 
pattern: the subsumee and subsumer are select boxes whose children match with compensations that do not include any grouping. 
matching conditions: the conditions here are similar to the ones in section 1.1  but adjustments have to be made to include the child compensation boxes. the revised conditions are:  1  same as in 1.1  1  every subsumer predicate that is not an extra join predicate matches with  or subsumes  some subsumee or child compensation predicate.  1  same as in 1.1.  1  same as in 1.1.  1  pullup condition: every child compensation predicate that does not have a matching subsumer predicate is derivable from the subsumer's qcls and/or the rejoin qcls  if any . 
compensation: it includes the rejoin children  if any  and a single select box that contains all the subsumee and/or child-compensation predicates that do not have matching subsumer predicates. 
example: an example is given in .  
 
1.1 select boxes with group-by child compensation  but no common joins 
pattern: the subsumee and subsumer are select boxes with no overlapping joins and at most one child match whose compensation includes grouping.   matching conditions: the matching conditions are the same as in section 1.1  with the addition of a pullup condition for the group-by box es  of the grouping child compensation: every predicate  i.e.  grouping column  of every child-compensation group-by box is derivable from the subsumer and/or the rejoin qcls. compensation: the compensation is built in three steps. first  any non-grouping child compensations are pulled up as described in section 1.1. this creates a single parentcompensation select box  call it sel-pc1 . then  the grouping child compensation is pulled up on top of selpc1. finally  another select is added at the top to compensate the subsumee'spredicates and qcls. 
example: figure 1 shows an example for this pattern  the bottom select boxes have been omitted to save space . in this example  the two top select boxes  sel-1q and sel-1a  are matched using the conditions for the current pattern. compensation boxes gb-1 and sel-1 are the pulled-up versions of gb-1 and sel-1  respectively. box sel-1 is the additional select box inserted to compensate the subsumee's cnt   1 predicate and derive its qcls. this example is discussed further in section 1. 
q1: select flid 	ast1:select flid  year date  as year 
              count *  /  select count *  from trans  as cntpct	                       count *  as cnt 
         from trans  loc	sel-1	                        select count *  from trans  as totcnt

figure 1: select boxes with group-by child compensation 
1. matching cubes 
 
recently  sql has been extended with the introduction of three supergroup functions - rollup  cube  and grouping sets  or  gs  for brevity  - which allow multiple simple group-by queries to be expressed within a single sql statement. specifically  multidimensional grouping can be expressed by a group-by clause that contains any combination of the supergroup functions  e.g.  group by rollup a b   gs  f g    f h  . it turns out that every supergroup expression can be converted to an equivalent canonical expression that consists of a single gs function: gs gs1  gs1  ...  gsk   where each gsi is a simple grouping set .  in this section  we present matching conditions for such canonical expressions only1. we start by explaining the precise semantics of the gs function. then  we present two patterns with multidimensional group-by's. 
 
let q be a query block with the following group-by 
                                                                   i clause: group by gs gs1  gs1  ...  gsk   where gsi = { a1   
ai1   ...  aini }. let gs = u1kgsi   and n be the number of elements in gs. then q is equivalent to the union of k simple group-by query blocks  known as cuboids  and q is said to be a cube query. each cuboid qi groups by gsi and produces n columns - one column for each grouping item in gsi  plus n - ni null-valued columns  that is  one null-valued column for each grouping item that belongs to gs but not to gsi. an example of a cube query is shown in figure 1. for simplicity  we assume that all of the base table columns are non-nullable  and as a result  the only null values appearing at the output are the ones added to represent the grouped-out columns of each cuboid. 
  
select flid  year date  as year  faid  count *  as cnt from trans where year date    1
sample trans table          query result           flid      year      faid
1     1   1       1     1    1       1     1    1       1     1    1       1     1    1       1     1    1       1     1
1     1 flid       year     faid     cnt    1       1     null     1    1       1     null     1    1       1     null     1    1       null     1       1    1       null     1       1    1       null     1       1    1       null     1       1
   1       null     1       1	group by gs  flid  year date     flid  faid           	gb
figure 1: cube query with sample result and qgm graph 
1 simple group-by query with cube ast 
pattern: the subsumee is a simple group-by box whereas the subsumer is a multidimensional group-by box. the child compensation may be empty or consist of a single select box with or without rejoins.  child compensations with group-by boxes are handled in exactly the same manner as in section 1.1.  let  gse be the subsumee's grouping set  and gsir   i = 1  1  ...  k be the subsumer's grouping sets. 
matching conditions: the approach taken here is to match the subsumee with one of the cuboids that comprise the subsumer. care must be taken  however  so that the null columns of a cuboid will not participate in the matching. specifically  a match is possible if there is at least one subsumer grouping set gsir such that the conditions and derivation rules of 1.1 or 1.1 are satisfied when restricted to the grouping columns of gsir only  rather than all of the subsumer's grouping columns . compensation: if more than one of the subsumer's cuboids satisfy the matching conditions  then  to minimize the amount of regrouping in the compensation  the cuboid with the smallest number of grouping columns is selected. let 
gsminr be the selected cuboid. the compensation consists of a select box potentially followed above by a groupby box. the inclusion rule for the group-by box is the same as the rules in 1.1 or 1.1 restricted to the grouping columns of gsminr . the select box applies the pulledup predicates from the child compensation  if any   as well as a slicing predicate  which selects the cuboid corresponding to gsminr out of the other cuboids. the slicing predicate is a conjunction of is null and is not null conditions over the subsumer's grouping columns: if a grouping column belongs to gsminr   then it must not be 
null; otherwise it must be null. 
example: in figure 1  the grouping set of q1 matches exactly with the  flid  year  grouping set of ast1. in addition  rule  a  from 1.1 and the pullup condition from 
1.1  restricted to  flid  year   are also satisfied. as a result  q1 can be rewritten as newq1  which simply selects the  flid  year  cuboid without regrouping. in contrast  matching q1 with ast1 requires regrouping  even though q1 has the same grouping set as q1. the reason is that the pullup condition is not satisfied in  flid  year   as this set does not include the month column. as a result  we have to use the  flid  year  month  cuboid from the ast and regroup. finally  no match exists for q1  because rule  f  from 1.1 requires that faid be a grouping column  and as a result  ast1 should have a grouping set with at least faid  flid  year  and month.     
ast1:
select flid  faid  year date  as year  month date  as month  count *  as cnt from trans group by gs  flid  faid  year date   
                     flid  year date   
                     flid  year date   month date   
                     year date   
q1:	newq1:
select flid  year date  as year  count *  as cnt select flid  year  cnt
from trans 	from ast1

where year date    1where flid is not null and faid is null and group by flid  year date            year is not null and month is null and
           year   1
　　　　　　　　　　　　　　　　　　　　　　newq1: q1:
　　　　　　　　　　　　　　　　　　　　　　select flid  year  sum cnt  as cnt select flid  year date  as year  count *  as cnt
　　　　　　　　　　　　　　　　　　　　　　from ast1 from trans 
 where flid is not null and faid is null and where month date   = 1            year is not null and month is not null and group by flid  year date             month  = 1 
　　　　　　　　　　　　　　　　　　　　　　group by flid  year date  q1:
select flid  year date  as year  month date  as month 
          count distinct faid  as custcntno match from trans group by flid  year date   month date 
figure 1: simple group-by query with cube ast 
1 cube query with cube ast. 
pattern: both the subsumee and subsumer are multidimensional group-bys. let gsie   i = 1  1  ...  m 
                                             e	m	e be the subsumee's grouping sets  gs = u gsi   and 
1
gsir   i = 1  1  ...  k be the subsumer's grouping sets. 
matching conditions: a match is possible if every subsumee cuboid can be independently matched with the subsumer using the conditions from section 1. otherwise  if any of these sub-matches fails  the entire match fails. compensation: if none of the sub-matches requires regrouping compensation  then the final compensation is a single select box  which contains the pulled-up predicates from the child compensation  if any  and the slicing predicate. in this case  the slicing predicate is the disjunction of the slicing predicates for each sub-match. if  however  any of the sub-matches requires regrouping compensation  then the subsumee is treated as if it were a simple group-by  whose grouping set is gse . gse is then matched with the subsumer using the conditions from section 1. in this case  the select portion of the compensation is the same as in section 1  i.e.  it contains the pulled-up predicates  if any  and a slicing predicate that selects the smallest subsumer cuboid that matches with gse . regrouping  however  is performed not by gse   but by a multidimensional group-by box that has the same gs function as the subsumee.  
ast1:
select flid  faid  year date  as year  month date  as month  count *  as cnt from trans group by gs  flid  acctid  year date   
                     flid  year date   
                     flid  year date   month date   
                     year date   	newq1:
select flid  year  cnt
q1:	from ast1
select flid  year date  as year  count *  as cnt where   flid is not null and faid is null and from trans              year is not null and month is null  where year date    1            or

group by gs  flid  year date                flid is null and faid is null and
                      year date   	             year is not null and month is null  
      and year   1
q1:	newq1:
select flid  year date  as year  count *  as cnt	select flid  year  sum cnt  as cnt
from trans 	from ast1
where year date    1where flid is not null and faid is null and group by gs  flid    year date   	           year is not null and month is null
      and year   1 group by gs  flid    year  
figure 1: matching cubes 
example: in figure 1  every cuboid of q1 matches with ast1. none of these sub-matches requires regrouping  and hence  no regrouping is performed by newq1 either; newq1 just extracts the  locid  year  and  year  cuboids out of the ast and re-applies the year   1 predicate. in contrast  the match between q1 and ast1 requires regrouping because the query's  locid  grouping set does not match exactly with any of the ast's grouping sets. as a result  q1 is temporarily viewed as a simple group-by query  which matches with the  locid  year  ast cuboid. that cuboid is selected out of the ast in newq1  which then regroups by gs  locid    year  . 
 
1. expression matching and derivation 
 
so far  we have often required that some subsumee expression eexp  predicate or qcl  be semantically equivalent with some subsumer expression rexp. a method is therefore required to test for expression equivalence. the first step of such a method should be to translate eexp into an equivalent expression e＞exp that is valid within the subsumer's context  i.e.  uses subsumer qncs. this is very important because what might appear as column x inside eexp may not be a direct reference to a base table column  but rather a complex sub-expression produced by a nested subquery. as a result  it is not possible to directly compare the qncs in eexp with those in rexp  as they originate from different subgraphs. once the translation is done  any expression-matching algorithm can be used to compare the parse trees of e＞exp and rexp. however  expression matching is orthogonal to the rest of the matching algorithm  and will not be discussed further. instead  our focus here is on the expression-translation method  which is a crucial component of our matching infrastructure. 
 
when the subsumee and subsumer children match exactly  translation is easy. specifically  for each qcl x produced by a non-rejoin subsumee child  there is an equivalent qcl y produced by the subsumer's matching child. as a result  if xe is a subsumee qnc that consumes x and appears in eexp  and the subsumer consumes y  i.e.  the subsumer has a qnc yr   then we can replace xe in eexp with its equivalent yr qnc. by replacing each non-rejoin qnc in eexp with its equivalent subsumer qnc  if it exists   we get e＞exp. translation is more complicated when the children do not match exactly. this is best illustrated by an example. in particular  consider the example in figure 1  but with a modified ast1 that has a having predicate: count *    1. adding this predicate to ast1 makes a match between the two top select boxes impossible because their predicates are not semantically equivalent  even though they are syntactically equivalent. the problem is illustrated in table 1  which shows the query and ast results for a sample trans table. we see that the having predicate eliminates the group  1  1   which is necessary to produce the correct query result.  
 
 locid date cnt sample trans table 
 flid 	and 	date 
columns  1 1/1  1 1/1 1 1/1 1 1/1 ast result 1 1 1 query result 1  1 table 1 
our method detects this semantic inequivalence between the two having predicates by appropriately translating the query predicate. the steps taken during the translation are shown in figure 1  where each qnc name has been annotated with the name of the box that contains the qnc. the translation begins by creating a copy of the whole expression  step 1 . then  each qnc is translated in turn. to translate a qnc  we first find the child box that produces the qnc and replace the qnc with the associated qcl expression; in our example  cnt-1q is produced by count *  in box gb-1q  step 1 . the next step is to replace count *  with its equivalent qcl expression at the top of the child compensation. thus  count *  is translated to sum cnt-1   step 1 . then  we recursively translate each new qnc  except qncs produced by rejoin children  until we reach the bottom of the child compensation. this way  sum cnt-1  becomes sum cnt-1   step 1 . finally  we notice that cnt-1 and cnt-1a are equivalent  as they are both produced by the cnt qcl of the subsumer's child. as a result  we can replace cnt-1 with cnt-1a  step 1 . the translated predicate is sum cnt-1a    1  which is obviously not the same as the subsumer's predicate cnt-1a   1.  
 
the translation method described above is also the first step in deriving a subsumee expression eexp from the subsumer's qcls. after translating eexp to e＞exp  derivability can be established by making sure that the subsumer computes at its output certain necessary subexpressions of e＞exp  or even the entire e＞exp . the problem that arises  however  is to determine the parts of e＞exp that can/should be computed by the subsumer. in general  translation causes an expression to expand by replacing individual qncs with equivalent subexpressions. for example  cnt-1q   1 is translated to sum cnt-1a    1. derivation is the reverse operation  where pieces of the translated expression are collapsed as they are computed along the derivation path. for example  sum cnt1a    1 is derived as cnt-1   1 at the top of the compensation. the next paragraph explains the derivation method in more detail in the context of the cnt / totcnt expression that computes the cntpct qcl of query q1. 
subsumee
	expression	step 1	step 1	step 1	step 1	step 1
	 	 	 	 	 	 

cnt-1q	1 cnt-1q	1 count *  1 sum cnt-1 1 sum cnt-1  1 sum cnt-1a  1
figure 1: expression translation  
the expression is first translated as sum cnt-1a  / totcnt1a. during this translation  our method determines that the division operator and the sum function should be computed by the sel-1 and gb-1 boxes  respectively. given that those are they only internal nodes of the expression tree  and that neither of them should be computed by the subsumer  we conclude that for the expression to be derivable  the subsumer must preserve the cnt-1a and totcnt-1a qncs at its output  which it does. as a result  the expression can be pulled up inside sel-1 as sum cnt1  / totcnt-1. next  the expression is pulled up one box further and becomes sum cnt-1  / totcnt-1 within the context of gb-1. during this pullup  the totcnt qcl is created inside sel-1 and consumed by the totcnt-1 qnc. the last step is to pull the expression from gb-1 up to sel-1. to do so  the totcnt and cnt qcls  as well as the totcnt-1 predicate  are created inside gb-1.  in fact  cnt should already be there  because it was created earlier during the derivation of the query's having predicate . notice that the cnt qcl in gb-1 actually computes the sum function. as a result  the expression is pulled up as cnt-1 / totcnt-1  which becomes the expression that computes the original cntpct qcl. 
 
1. related work 
 
in this paper  we have presented a practical algorithm for real sql queries with aggregation. previous work most closely related to ours includes     and . in all three cases  the domain of the algorithms presented consists of simple  single-block select-where-groupby-having sql statements. in   matching is performed by applying a set of rewrite rules to the query until a portion of it is syntactically identical to the ast. to handle multi-block queries   proposed the use of similar rewrite rules for transforming multi-block queries to single-block ones. however  such a transformation is often impossible.  
 
another limitation of  is its reliance on syntactic matching  which cannot  for example  derive a query expression from the ast expressions. this limitation is also recognized in   where semantic matching conditions are proposed. for example  if pq and pa are the sets of where predicates in the query and the ast respectively   requires that pq is equivalent to pa & pc  where pc is a set of predicates that involve only ast and rejoin columns  i.e.  pc are the compensation predicates. although this condition is more general than our conditions 1 and 1 in section 1.1  no algorithm is presented in  for finding the pc  predicates. as we argued in section 1  such an algorithm is orthogonal to a general matching infrastructure and should rely on first translating the query predicates into the context of the ast. 
 
neither  nor  make use of database semantics that are specified via constraints. such semantics are exploited . in addition to ri constraints  which have helped us handle extra ast tables   considers other functional dependencies as well in order to derive query columns that are not present at the ast. furthermore   presents matching conditions for outer-join operations. in general  however  the algorithm description in  is rather sketchy.  
 
using our algorithm  or any of        a query may be rerouted towards multiple asts by an iterative process where  at each iteration  the result of the previous rewrite is matched with the next available ast. a different approach is taken in   where  for each aggregate function  the general format of the rewritten query is determined in advance. many candidate rewritings can be derived from the general format by simultaneously combining the aggregation results of different asts  e.g. sum x  might be derived as sum sum xi*cntj*cntk   where sum xi  cntj  and cntk are computed by the ith  jth  and kth asts respectively . the candidate rewritings are then tested for equivalence with the original user query using the equivalence theory developed in  and . although such a global approach should  in general  be more powerful  but also less efficient  that an iterative approach  it is not clear that this is indeed the case with . in particular  all of the examples presented there can be handled by our algorithm as well. furthermore  having clauses were not allowed in . 
   
another interesting problem  from a theoretical perspective  is the discovery of complete rewriting algorithms  which  given a query and a set of mvs  guarantee that a rewriting will be found  if one exists. the existence and complexity of complete rewriting algorithms depends on the complexity of the queries and mvs considered and the language used to construct the rewritings. in general  finding a complete algorithm is a hard problem  and existing ones are limited to restricted classes of queries.  presents a complete algorithm for simple conjuctive queries without constants  comparisons  or aggregation  using set semantics. this algorithm is adapted for bag semantics in . finally  a more powerful algorithm for simple conjuctive queries and mvs that may also contain counts is developed in  using bag-set semantics.  
 
1. summary 
 
all of the related work reviewed in section 1 applies to user and ast queries that are single block and do not contain complex expressions. in this context  queries can be described as sets of base table columns  e.g.  predicate  grouping  select-list  and aggregation columns . previous matching algorithms typically operate by comparing such sets of base table columns from the query and the ast. this approach  however  cannot handle multi-block queries and/or complex expressions  for two reasons. first  as their semantics become more complicated  queries cannot be described as single units anymore; instead they must be broken into smaller pieces  and matching should be done in a piece-by-piece fashion. second  columns that appear in various parts of a query are not  in general  base table columns anymore; instead they are computed as complex expressions over other columns  potentially produced by nested query blocks. as a result  a translation mechanism is required before query and ast columns can be compared. 
 
in this paper  we have presented a matching algorithm that addresses the above issues by relying on a general matching infrastructure  consisting of the qgm model  the navigator  the match function  and the translation mechanism. this infrastructure offers great modularity and extensibility by breaking the matching task into many smaller sub-matches  each involving only a small subset of qgm boxes in isolation  i.e.  a subsumee  a subsumer  and their childcompensation boxes . in addition to the generic matching infrastructure  we have also presented matching conditions and compensation rules for several specific query patterns.  overall  our experience of implementing the matching algorithm inside ibm's db1 udb dbms and testing its performance benefits has been very positive. using a small number of asts in each case  we have seen dramatic improvements in query response times both with tpc-d queries and with a number of customer applications.    
 
