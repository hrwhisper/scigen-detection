semantic caching is an important technology for improving the response time of future user queries specified over remote servers. this paper deals with the fundamental query containment problem in an xquery-based semantic caching system. to our best knowledge  the impact of subtle differences in xquery semantics caused by different ways of specifying variables on query containment has not yet been studied. we introduce the concept of variable binding dependencies for representing the hierarchical element dependencies preserved by an xquery. we analyze the problem of xquery containment in the presence of such dependencies. we propose a containment mapping technique for nested xquery in presence of variable binding dependencies. the implication of the nested block structure on xquery containment is also considered. we mention the performance gains achieved by a semantic caching system we build based on the proposed technique.
categories and subject descriptors
f.1  theory of computation : logics and meanings of programs; i.1  computing methodologies : expressions and their representation; h.1  information systems : database applications
general terms
xquery containment mapping algorithm and theory
keywords
xquery containment  variable binding dependency
1. introduction
　due to its fundamental role in many database applications such as query optimization and information integration   the problem of query containment has received considerable attention over the past few decades. with the initial focus on relational queries  researchers have recently begun to study the containment problem for various fragments of xpath  1  1  1  1  and xquery  1  1  1 . the key technique of containment mapping for relational queries  has been extended in the new contexts to derive mappings between navigation pattern trees and nested xquery
copyright is held by the international world wide web conference committee  iw1 . distribution of these papers is limited to classroom use  and personal use by others.
www1  may 1  1  chiba  japan.
acm 1-1/1.
constructs. it has been commonly recognized that extended containment mapping is central for minimizing xml queries  1  1   and for reformulating queries in a mediator system  or a peer-to-peer environment .
1 motivation
　this work is motivated by the promising application of semantic caching for answering xml queries using cached xml views  1  1 . the idea of semantic caching is that the  mobile  client maintains both the semantic descriptions and associated answers of previous queries in its cache  in the hope of being able to reuse them to speed up the processing of subsequent queries.
　an xquery-based semantic caching system named acexq has been proposed  1  1  for facilitating xquery processing in the web environment. the main techniques exploited by ace-xq include the containment mapping approach for nested xquery  xquery rewriting  and a multi-granularity replacement strategy. with  focussed on the proposed replacement strategy and the cache performance evaluation  we introduce  in this paper  the fundamental query containment technique underlining ace-xq which is the first comprehensive practical semantic cache solution for handling nested conjunctive xquery.
1 the related work
　in the xml setting  extensive research has focussed on the query containment problem for regular path expressions on general cyclic graph databases   tree pattern queries and xpath queries over xml data  1  1  1  1 . especially the containment problem for xpath and tree pattern queries has attracted a lot of attention recently due to the fundamental role they play in many xml query languages.
　different fragments of xpath have been targeted by different works. a well recognized core xpath fragment includes child axis '/'  descendant axis  //   branching        and wildcard '*'. it is shown in  that query containment for this fragment  denoted xp{  //    }  is conp-complete. if any of the three constructs  //          and '*' is dropped  query containment is ptime. the essence of their containment mapping technique is the polynomial-time tree homomorphism algorithm1  which serves as a sufficient but not necessary condition for containment of xp{  //    } in general. on the other hand  if tag variables and equality testing are allowed  query containment is np-complete. the complexity increases to Πp1 with disjunctions added. we refer

1
tree homomorphism and tree embedding are exchangeable. the readers to  1  1  1  for discussions of the containment complexity results under different xpath fragments.
　however  research on the containment problem for xquery is still in its infancy. besides using xpath expressions as the navigation mechanism  xquery also employs other query constructs such as flwr expressions and the nesting of query blocks. these features make xquery more expressive than xpath. on the other hand  they also impose new difficulties on the containment problem. specifically  difficulties arise since an xquery cannot simply be represented by a navigation tree pattern. hence containment mapping based on tree homomorphism alone is no longer sufficient for determining xquery containment.
　to our best knowledge  the containment of nested xquery has so far been studied only in     and .  exploits xquery containment for query optimization. it utilizes containment mapping for identifying redundant navigation patterns in a query and later for collapsing them to minimize the query. in   the containment of nested xquery is researched for the purpose of rewriting queries posted on one peer to be answered by another peer.  studies the complexity of the problem regarding completeness.
　targeting different goals  these three works exploit different approaches. the containment mapping technique proposed in  essentially extends tree homomorphism between navigation patterns with additional requirements for mapping the equality-based where-conditions  groupby id and groupbyvalue variables. in   two types of mappings  i.e.  a query-head embedding ehead q1 q1  and a query-body embedding ebody q1 q1   are employed as the sufficient conditions for deriving q1 v q1  assuming q1 and q1 are two nested xqueries . ehead embeds the block structure of q1 into that of q1 while ebody embeds the navigation pattern of q1 into that of q1. in   containment of nested xquery is defined based on xml instance containment. the theoretical complexity result for methods that ensure completeness is established.
　among these three works   presents an approach that guarantees completeness  i.e.  no false negative answers . in answering-queries-using-views scenarios  it is commonly considered more crucial to guarantee the soundness while the completeness is often ignored to avoid the high complexity. for example  the containment of nested xquery in general is conexptime when ensuring completeness .
　in contrast   and  attempt to provide more practical containment mapping techniques by extending tree homomorphism with additional mapping conditions. in   a technique is proposed for identifying redundant navigation within one query. it considers the mapping of equality-based where-conditions and that of variables distinguished by the set or bag semantics they each represent. however  all return expressions are considered as black-box functions and ignored in the containment mapping process. this containment mapping technique is hence a not suitable foundation for determining the containment relationship between two queries. this is obvious considering the fact that whether the direct bindings of variable v or subelements obtained from further navigation of v's bindings are returned does make a major difference in the query result.
　furthermore  neither of the two techniques considers the effect of dependencies among variable bindings on the query result and consequently on the containment result. in section 1  we give examples of subtle differences in xquery semantics caused by different dependencies among the specified variables. since these two techniques have failed to address the critical effect of such differences on the query containment result  we propose our containment mapping approach which provides sufficient mapping conditions for correctly deriving the containment decision.
1 problem analysis
　in this work  we target the containment problem for nested xquery. we consider a core fragment of xquery that allows nested blocks  conjunctive equality-based conditions  set and bag semantics. disjunctions  negations  universal quantifier and tag variables are not considered. this xquery fragment is the same as that being studied in .  and  study a subset of this fragment as they exclude the bag semantics.

for $t in document ``bib.xml'' //book/title 
　$a in document ``bib.xml'' //book/author return  pairq1  $t  $a
 /pairq1 
q1
for $b in document .. //book 
   $t in $b/title  $a in $b/author where some $p in $b/price satisfies $p=1
return  pairq1  $t $a/last
 /pairq1                            q1
for $b in document .. //book
return  pairq1 
{for $t in $b/title  $a in $b/author return $t  $a}
 /pairq1 q1
for $b in document .. //book return  pairq1 
{for $t  in $b/title return $t} 
{for $a in $b/author return $a}
 /pairq1                         q1figure 1: example queries
　now let us consider the example queries in figure 1. all four queries qi  i=1..1  specify $t and $a and return their bindings in the results. suppose the input document bib.xml is shown at the left top corner in figure 1  we can see that their results rqi  i=1..1   also shown in figure 1  are all different due to the subtle differences in their variable specifications and nested block structures. suppose that the dtd for bib.xml specifies  !element book title author  publisher   price   . rq1 contains six title and author pairs derived from all combinations of the $t and $a bindings documentwide regardless of whether the paired title and author elements belong to the same book. in contrast  the $t and $a bindings in q1 are specified based on $b. therefore  the title and author elements corresponding to different book parents do not appear in the same pair in rq1. for example  t1 is paired with a1 and a1 but not with a1 in rq1.
	.bib	.results
b1. b1book. book .b1 p1. p1. .p1.p1 .p1.p1 book	pairq1 ...
.	author. title. publisher. title. author... .. .... ..
　　　　a1	t1	pu1	t1 a1 t1 a1 t1 a1 t1 a1 t1 a1 t1 a1 bib.xml	rq1
.
	results	.results	.results
　p1.. p1 .b1 .b1 b1. . .b1 pairq1pairq1 pairq1 pairq1 pairq1 pairq1 title.author. title..author .title.author author.title.
t1 a1	t1 a1	t1	a1	a1
	rq1	rq1	rq1
figure 1: bib.xml and example query results
　the differences in the structure of rq1 versus that of rq1 can be intuitively explained by the differences in specifying variable dependencies in q1 and q1. that is  the variables $t in q1  denoted by $tq1  and $aq1 are defined based on $bq1  while $tq1 and $aq1 are based on $r  i.e.  the default root variable bound to the root element of document  bib.xml   . we first explain the effect of variable dependencies on the resulting query result for q1. when constructing the result rq1  since $tq1 and $aq1 are defined in the same query block  the corresponding new element hpairq1i is produced for each tuple in the cartesian product of the bindings of $tq1 and $aq1. due to the way how $tq1 and $aq1 are specified  the bindings of $tq1 and $aq1 derived from the same binding of $bq1 preserve the sibling htitlei hauthori element associations under the same parent book element. such hierarchical data dependencies in the source xml are preserved in the intermediate variable bindings based on which the query result is constructed. in this case  each pairq1 element in rq1 combines bindings of $tq1 and bindings of $aq1 only if they share the same parent binding of $bq1. in contrast  the sibling htitlei hauthori associations are not kept in the bindings of $tq1 and $aq1. q1 hence produces hpairq1i elements based on the cartesian product of all the bindings of $t and $a regardless of their respective parent book elements. q1 hence preserves a finer hierarchy of element dependencies among its intermediate variable bindings than q1 does.
　we now analyze the effect of such preserved dependencies on the containment result. suppose that the containment mapping technique proposed in  is applied to q1 and q1 in figure 1. q1 v q1 would be derived since both ehead q1 q1  and ebody q1 q1  can be established as illustrated in figure 1. to derive q1 v q1  this approach utilizes not only the navigation pattern based mapping represented by ebody  but also ehead for checking if the variables returned by q1 are a subset of those returned by q1. however  whether such dependencies among variable bindings influence the query containment result has not been studied in either  or .

figure 1: illustration of containment mapping via ehead and ebody
　assume q1 is answered using rq1 based on the containment result q1 v q1. then there is no way to re-group the returned bindings of $t and $a in rq1 by their respec-

tive book parent elements as required by q1. ignoring this requirement  the produced result of q1 would contain superfluous pairs  namely  t1 a1  t1 a1  t1 a1 and t1 a1.
1 our contributions
　first  we address the problem of producing superfluous answers based on the query containment result when ignoring the effect of variable binding dependencies in the containment mapping process. correspondingly we identify some important concepts and their connections  as illustrated in figure 1  to this problem.
element dependecies
xquery containment
 formally hmvds 
	preserved  in	concerns
	variable binding dep.	query result structure
	 vartree 	 tagtree 
reduced to utilizes essential variable binding dep.
 minimal vartree 
figure 1: connection between preserving of element dependencies and xquery containment
　the left hand side flow illustrates the preservation of data dependencies in the source xml in the intermediate bindings via the specification of variables. the right hand side flow represents the fact that xquery containment needs to take the query result structure constructed based on the binding dependencies into consideration. terms enclosed in the parentheses in figure 1 will be introduced in section 1. also  we realize that not all the intermediate binding dependencies preserved by a query are necessarily utilized in constructing the final result. thus we call a subset of variable binding dependencies being utilized the essential ones via which both flows are connected.
　second  based on our problem analysis  we propose a containment mapping technique that considers the containment of the utilized binding dependencies in the query result. for this  we first decompose the input query and represent the two parts of its semantics  i.e.  variable binding and result construction  by respective tree structures. then we identify the binding dependencies that are preserved by the former and utilized by the latter. we call it variable minimization. next we propose to employ three types of containment mappings for deriving the containment decision.
　in sum  we will show that our containment mapping approach is more comprehensive than the prior works  1  1  1  in that it deals with the effect of variable binding dependencies on the query containment result. in other words  it avoids deriving the query containment decision which may lead to producing superfluous answers for the contained query by using the result of the containing query. like  and   our approach does not necessarily ensure completeness.
1 paper outline
　the rest of the paper is organized as follows. in section 1  we define the problem of xquery containment in the presence of variable binding dependencies. section 1 gives the overview of our approach. we describe the pre-step of query decomposition and minimization in section 1. this is followed by our containment mapping technique in section 1. we show the query performance gains achieved by applying the proposed technique in a semantic caching system in section 1 and conclude in section 1.
1. problem definition
　in this section  we first introduce the notion of hierarchical multivalued dependencies  hmvds  which represent a typical type of data dependencies in the source xml. also  we define variable binding dependencies as the hmvds being preserved by the query in the intermediate variable bindings. we then define the problem of nested xquery containment in the presence of variable binding dependencies.
1 hierarchical multivalued dependencies
　it has been recently recognized that studying the extension of the traditional integrity constraints in the xml setting is both theoretically and practically meaningful. several classes of integrity constraints including key constraints  path constraints  functional constraints  and inclusion constraints have been defined for xml . the more advanced constraints such as the multivalued dependencies  aka tuple generating dependencies  have also been studied in  1  1  with the goal to develop a normalization theory for xml and in  for mapping xml dtds to relational schemas.
　xpath containment in the presence of dtd constraints such as sibling constraints and functional constraints has been investigated in . the semantics of an xpath query can be captured by a unary pattern tree in which only one node has its bindings returned as the result while others are matched but not returned. however in xquery  even a single for clause may specify multiple variables which correspond to an n-ary  n−1  pattern tree. this is where the challenges arise for xquery containment.
　let us first analyze the semantics of a single-block xquery for the sake of simplicity. in a single-block xquery that utilizes a flwr expression  the return clause is invoked for all the cartesian product combinations of the variable bindings produced by the for clause. these combinations are determined based on how variables are defined based on others. as far as we know  no research has studied the implication of such dependencies on xquery containment. this is the task of our work.
　definition 1. given a dtd  suppose ε is a set of binary edge relations between element type e and its children element types  each labeled with the corresponding cardinality relationship 1     * or + 1. for any two descendant element types x and y of e  if either x or y has a multiple cardinality relationship  i.e.  * or +  with e  then we call the dependency among their corresponding elements in a conforming xml a hierarchical multivalued dependency  hmvd   denoted e ★★ x|y.
　recall that the notion of multivalued dependency  mvd  in relational databases defines that if a relation has two or more multivalued independent attributes  e.g.  x and y   every value of one attribute  e.g.  x  must be repeated with every value of the other attribute  e.g.  y . hmvd extends mvd in the sense that e  x and y are not attributes in a relation but element types in a dtd. if e  x and y are mapped to a 1-column relation and their bindings are unnested  then in each partition with an e binding  every x binding needs to be repeated with every y binding.

1     * and + respectively represent the 1  1- 1   1- 1 m  and 1- 1 m   m −1  mappings.
1 variable binding dependency
　for an xml document d  the dependencies among its elements which have multiple cardinality relationships with their respective parents can be represented by hmvds. a query imposed against d specifies a subset of hmvds  direct or derived  to be preserved by its variable bindings.
　definition 1. suppose a given query defines variable vj based on vi  e.g.  for vj in vi /|// pj  where pj is the relative xpath expression used for deriving vj's bindings from each binding of vi. we call this dependency of vj's bindings on their respective vi bindings a variable binding depen-
                 p dency  denoted.
/author
　for example  $$t and $b  $a hold for q1゛1 in figure 1. they all specify their corresponding $t and $a based on $b.
the variable binding dependency relationship satisfies:
  transitivity rule  
where pjk is the path expression obtained by concatenating pj and pk  and   denotes an induced variable binding dependency. given an xquery  the direct variable binding dependencies extracted from it compose a base dependency set from which the non-direct dependencies can be derived inductively.
　for example  q1  q1 and q1 in figure 1 define $b via an absolute path expression //book from the root of the source xml  bib.xml . suppose variable $r is used as a default root variable to be bound with the root element  then $r b. $t and $b  
　//book/author we can derive $r   $t and $r   $a. in contrast  q1 in figure 1 directly defines $t and $a based
　　　　　　　　　　　　　　　　　　　　　　　　　　　　//book/title on the root variable $r. hence it has $r	 $t and
//book/author
$r		$a.
1 hmvd and xquery containment
　to tackle xquery containment in the presence of variable binding dependencies  we cannot solely utilize tree homomorphism between the two respective navigation pattern trees. additional conditions need to be asserted in the containment mapping process to deal with the effect of variable binding dependencies on the query semantics.
　let us consider the containment relationship between q1 and q1 in figure 1 again. a tree embedding of the pattern tree of q1 into that of q1 exists  as illustrated by ebody q1 q1  in figure 1. as described before  if we were to use rq1  see figure 1  to answer q1 according to q1 v q1  then it will result in the superfluous answer pairs t1 a1  t1 a1  t1 a1 and t1 a1. with the new concepts introduced in this section  we can see that this is because the hmvd $b ★★ $t|$a is required by q1 but not preserved by q1.
　suppose that vars q  and rets q  are the defined variables and the returned expressions in a query q respectively. all the variables occurring in rets q  must be defined in vars q  for q to be safe. on the other hand  variables occurring in rets q  may be a subset of vars q . that is  not all the variable binding dependencies are utilized in the query result. to determine query containment  we need to reason about not only the containment of the returned bindings due to rets q   but also the containment of the utilized variable binding dependencies due to both vars q  and rets q . correspondingly  we now define xquery containment in the presence of variable binding dependencies.
　definition 1. let q1  q1 be two xqueries. q1 v q1 if and only if: 1  there exists a containment mapping from ret q1  to ret q1   and 1  the hmvds preserved in vars q1  and utilized by ret q1  are subsumed by those preserved in vars q1  and utilized by ret q1 .
　for example  the hmvd $b ★★ $t|$a is reflected in rq1 in figure 1 but not in rq1. that is  the bindings of $tq1 and $aq1 are paired document-wise in rq1  whereas those of $tq1 and $aq1 are grouped by their common book elements in rq1. the former pairs can be derived from the latter by pairing all the $tq1 bindings with $aq1 bindings regardless of if they came from the same book parents. however  there is no way to recover the dependencies of $tq1 and $aq1 bindings on their common book elements as required by q1.
1. overview of our approach
　the main idea of our xquery containment approach is to incorporate the checking of the containment of the utilized hmvds in addition to the checking of the pattern tree homomorphism  i.e.  the embedding of the containing query pattern tree into that of the contained query . the main steps of our approach are depicted in figure 1.
xqueries

figure 1: containment checking flow
  xquery decomposition. we separate the variable definition part from the result construction part and represent each using a tree structure. the former tree  i.e.  vartree  captures all the preserved hmvds. it is different from the navigation pattern tree used in   as will be explained later. the latter tree  i.e.  tagtree  is used to represent the result construction template. the tagtree also indicates how the preserved hmvds are utilized in the result construction.
  variable minimization. we identify the variables that are neither directly nor indirectly utilized in the result construction and degrade them to navigation steps. this way  we derive a minimal set of variable binding dependencies for which we conduct the containment checking. this is a critical step for ensuring the correctness of the containment result.   containment mapping. we conduct three types of containment mappings. first  we perform the minimal vartree embedding to check the containment of the utilized hmvds. second  we check the tree embedding relationship between the navigation patterns. lastly  we apply a mapping that deals with the effects of block-structure-induced variable dependencies on the containment of xquery.
  xquery rewriting. if the new query q1 is contained within a cached query q1  then the mapping mc established in the containment mapping phase can be used for rewriting q1 against the query result structure of q1. the basic idea is to substitute each path expression p in q1 for its corresponding path expression p1 in the tagtree of q1 based on p1 = mc p  mt  where mt represents the mapping of path expressions from the vartree of q1 to its tagtree. namely  p1 is computed by the composition of mc and mt. we skip the details of query rewriting in this paper.
1. decompositionandminimization
1 xquery decomposition
　the purpose of query decomposition is to separate the semantics of variable bindings from that of result construction. however  the semantic distinction is sometimes not very easily extracted from the surface syntax. for example  not necessarily all expressions in return clauses represent the return construction semantics. due to the flexibility in composing a nested xquery  flwr expressions may be nested within a for clause  e.g.  for v1 in  for v1 in e1 return e1  return e1. in this case  e1 in the nested return clause does not result in returning its bindings in the ultimate query result but only serves for specifying v1's binding.
　therefore  we need to first normalize the query to derive a form based on which this semantic distinction is made easy. then we represent the two semantics respectively using two tree structures  which are connected via variable bindings.
1.1 the normalization rules in use
　our goal is that the normalized query can facilitate the separation of the path expressions that are to be output in the result from those that are used for specifying variable bindings  such that the later query decomposition step is made easy. there are a number of xquery normalization techniques  1  1  1  available. they overlap in some commonly used normalization rules. for example  unnesting the flwr expression within a for clause  as illustrated before  is a standard rule shared by many techniques.
　we adopt a set of query normalization rules including rules  r1 ゛ r1    r1 ゛ r1   and  rg1  from . we also apply rules  r1    r1    r1   and  r1   but in their reverse directions. rule  r1  does not apply in our context since we exclude disjunctions from our xquery fragment. since we consider the xquery fragment with no aggregations  we can also apply the rule that substitutes each let-variable with its definition. after applying these rules  the query is free of let clauses  empty sequence expressions and unit expressions. also  only return clauses may contain nested fwr1 expressions.
1.1 decomposition into vartree and tagtree
　definition 1. given a normalized xquery q  a tree structure named vartree= v  e  l  can be constructed based on the extracted variable binding dependencies. each defined variable is denoted by a var node v （ v . each

1
 letter l for representing let is removed since the normalized query is let-clause free.
dependency corresponds to an edge e =  vi vj  （ e labeled pj （ l. we refer to e the derivation edge of vi.
　the vartree is different from the pattern tree concept referred to in other research . an edge in the pattern tree corresponds to an axis step  / or //  and the associated element type test. in contrast  a derivation edge in vartree denotes the navigation pattern used for deriving a child variable from its parent. actually this is indicated by the label on a derivation edge which is an xpath expression composed of possibly multiple steps and branches. in this sense  the vartree can be considered as a nested tree with each edge encapsulating the navigation pattern corresponding to the label on it.
　definition 1. for a normalized xquery q  a tree structure conforming to its nested block structure can be constructed to represent the result construction semantics. it is called tagtree= n a . each block node n （ n is a quadruple  v． c ． r ． t．  and each edge a= ni nj （a denotes that block nj is nested within block ni. furthermore 
  v．  c．  r．  and t． respectively represent the variables  where-conditions  return expressions  and to-be-constructed new elements specified in the corresponding block;
  c． is denoted by a forest of constraint pattern trees each rooted at a variable defined in the local or an ancestor block. equality conditions are associated with the corresponding node s ;
  if unnesting of the bindings of variables in v． results in a non-empty set and conditions c． are satisfied  then the construction of a new element denoted by t． will be invoked for each tuple in that unnested binding set;
  t． may have either none  one  or a sequence of tag names in the form ht1iht1i...htni. this means that the returns of r． will be enclosed by an empty tag  ht1i and h/t1i  or ht1iht1i...htni and h/tni...h/t1ih/t1i.
　we now extend the vartree structure with a few more features. given the tagtree ttq of a query q  we get each return expression v/pm in a r． of ttq and correspondingly attach to the var node for v in the vartree v tq a leaf node  also referred to as ret node . each ret node represents the corresponding return expression. to distinguish var nodes from ret nodes  we use solid circles to denote the former and use hollow circles for the latter.
　the second extension is to shift the constraints and conditions in the c．'s of ttq to be represented in v tq. specifically  if the constraint pattern represented by the xpath expressions  with or without variables defined in their respective where clauses1  is derived from v  or the equalitybased conditions are affiliated to where-variables that are dependent of v  then we move them in the filter       of the xpath expression p which labels the derivation edge of v in v tq. intuitively  this can be done because these constraints and conditions are  in a sense  analogous to the relational selection operations. they hence can be pushed to be executed in the navigation pattern matching stage for deriving variable bindings.

1 where-variables refer to variables defined in where clauses  while for-variables are those defined in for clauses. unless indicated otherwise   variable  means a for-variable. a where-variable can be removed since its life scope is refrained within the local where clause.
　for example  the extended vartrees and tagtrees of example q1 and q1 are depicted in figure 1 respectively. note that the where-condition  some $p in $b/price satisfies $p=1  in the c． of the bottom block in ttq1 is serialized into  price=1  and then moved in       as the filter expression for defining $b in v tq1.

figure 1: vartrees and tagtrees of q1 and q1
　however  we must carry out this vartree extending process with caution. that is  the shifting of return expressions in r． and where-conditions in c． would not change the query semantics only if the to-be-attached var node v is defined in the same block where r． and c． are specified. some return expressions in r． and where-conditions in c． refer to variables that are defined in ancestor blocks. by moving them up along the nested block hierarchy to be attached to their referring variables  more or fewer bindings than desired may be returned. for example  suppose the example query q1 in figure 1 also specifies the where-condition  some $p in $b/price satisfies $p=1   however in the inner block. then attaching   price=1   to the definition expression of $b in the outer block may cause generating fewer  pairq1  elements due to the push-up condition. we hence leave such return expressions and where-conditions in their original block nodes in ttq.
　the vartree with these extensions is comprehensive enough to also represent the to-be-returned bindings and the effect of where-conditions on variable bindings. it is also noteworthy that the vartree and tagtree of a query are connected via variables. in particular  all variables in v．'s and those referred to in r．'s in the tagtree must be present as var nodes in the vartree for the query to be safe.
1 use-based variable minimization
we explained earlier that the vartree of a query is a
nested tree with navigation patterns encapsulated in its derivation edges. on one hand  the query semantics stays the same if we fully expand the vartree by unnesting all the encapsulated navigation patterns and by naming each node in them with a variable. on the other hand  it is also possible not to affect the query semantics by degrading some variables into navigation pattern nodes to be encapsulated in derivation edges. we call the latter a variable minimization process since the number of var nodes is reduced  however with more complex navigation patterns encapsulated  and the vartree structure seems minimized. a variable can be minimized without affecting the query semantics only if it does not participate in preserving any hmvd that is utilized in the result construction  nor serve in any way as a constraint context  will be explained later  for the return expressions.
　our goal here is to explore the opportunities for variable minimization to obtain the minimal vartree  i.e.  no further minimization is possible . this is critical since the later containment checking of utilized hmvds can be based on the derived minimal vartrees of two given queries.
　definition 1. given an xquery q  suppose d is the source xml and v is a variable defined in q. if by substituting all occurrences of v with v's definition  q's result will not change for any xml data instance that conforms to the same dtd as d  then we say v is nonessential. otherwise v is essential.
　now we provide practical criteria for distinguishing essential variables from non-essential ones based on their uses.
　explicit vs. implicit uses. a variable v may either be used for defining another variable or in a return expression. we call the former case a var use of v and the latter a ret use of v. both are referred to as explicit uses of v in general  regardless of where it is used  i.e.  either in the local block where v is defined or in descendant blocks .
　besides explicit uses  v may also be implicitly used as a  loop counter  for invoking returns. for example  when the block where v is defined encloses return expressions referring to other variables than v  then the cardinality of v's bindings is used to determine the number of times that the returns are to be invoked. in the extreme case when the binding set is empty  i.e.  cardinality is 1   no return will be invoked. in this sense  v serves as the constraint context for the returns. if a variable v has neither explicit nor implicit uses  we call it has no-use. such variables are definitely nonessential and can be minimized. otherwise  the essentiality of v depends on the combination of different uses and the number of variable use occurrences.
　one vs. multiple uses. basically  v is essential if it has at least two explicit uses  being either var or ret uses  or a ret use and an implicit use. the detailed case studies and rationale are depicted in figure 1.
essential variable identification procedureif v has no explicit use if v has no implicit use either                                 	case 1: no-use then v is nonessential else  v is essential	# since removing v would cause the lost of ``loop counter''. else if v has more than one explicit use  var or ret    case 1: multiple uses then v is essential	# since it is necessary for preserving the hmvds among its bindings and those of its dependent variablesor return expressions.
else  i.e.  exactly one explicit use  if v has no implicit use                                         case 1: one use then v is nonessential # since no two variables or return expressions have codependencies with v  minimizing v causes no lost of hmvds or condition changes
if  v has one ret use                         case 1: one ret with implicit uses then v is essential # since removing v would cause lost of ``loop counter''.
else  i.e.  v has one var use            case 1: one var with implicit uses v is nonessential # since no return expression will be affected by only v but not u due to their common life scope  and v occurs only in u's definition..
figure 1: identifying variable essentiality
　lemma 1. all essential variables can be correctly identified by our analysis in figure 1 based on variable uses. 1 example 1. we use q1 in figure 1 to illustrate the minimization process. before minimization  as shown in figure 1   the var node for $tq1  denoted by the solid circles  in v tq1 and that for $aq1 each have one dependent ret node  denoted by the hollow circles . hence $tq1 and $aq1 each have one ret use. also  the original ttq1 reveals that $tq1 and $aq1 each are specified alone in a bottom block. thus they have no chance to affect any other return. this means that $tq1 and $aq1 each have no implicit use. therefore  the var nodes for $tq1 and $aq1 in v tq1 can be minimized according to the analysis of case 1 in figure 1. correspondingly  the xpath expressions on the ret nodes are changed to $b/title and $b/author respectively by substituting the variable occurrences by their definitions.

figure 1: minimization example
1. xquery containment mapping
　in this section  we present our containment mapping technique which is composed of three types of mappings. the first two mappings are based on the obtained minimal vartrees  while the last one is based on the tagtrees.
1 vartree-based containment mapping
　given two queries q1 and q1  the first mapping is to check the containment of the utilized hmvds in two queries by conducting tree homomorphism  i.e.  tree embedding  between their vartrees. suppose the embedding is from v tq1 to v tq1. then the second mapping is to make sure that the navigation pattern used for deriving each var node in v tq1 implies a more restricted constraint than that for the matched var node in v tq1. these two mappings are called mac mapping and mic mapping respectively  indicating that the former is conducted at the macroscopic level of the vartree  i.e.  mapping of var nodes  while the latter is performed at the microscopic level of the vartree  i.e.  mapping of navigation patterns encapsulated in derivation edges .
1.1 mac mapping
　we now extend the traditional tree homomorphism  namely based on root  label  and ancestor-descendant relationship preserving  to define the mac mapping.
　definition 1. suppose v t1 and v t1 are the minimal vartrees of q1 and q1 respectively. for determining q1v q1  there must be a mac mapping from v t1 to v t1  denoted by Φ v t1  = v t1  such that the following conditions are satisfied:
c1  roots v t1    roots v t1  
c1  for any node u（v t1  there is a match Φ u （v t1 such that t  u =t  Φ u   if Φ u  is a var node  and t  u   : t  Φ u   if Φ u  is a ret node  t returns the type of the element  and  : denotes the subtypesupertype relationship  
c1  u is an ancestor of v for all u v （ v t1 if and only if Φ u  is an ancestor of Φ v  in v t1  and
c1  if u is a var node in v t1  then Φ u  is either a var or a ret node; if u is a ret node  then Φ u  must be a ret node.
below we explain each of these required conditions.
　c1: root inclusion1. this condition requires that each source xml document referred to in q1 must also be referred to in q1. correspondingly in the vartrees  roots v t1  returns the urls of the source xml documents involved in q1  which should be a subset of those returned by roots v t1 .
　c1: mapping of element types. this condition requires a total but not necessarily injective mapping from nodes in v t1 to those of v t1. in addition  a node u in v t1 must be mapped to a node in v t1 that has either the same type or a supertype1 of u's depending on if the matched node is a var node or a ret node. the element type of a node can be inferred from the xpath expression on its incoming derivation edge. u can be mapped to a super-type ret node Φ u  because the associated bindings of Φ u  are all deeply returned  due to the semantics of a return expression  to enable the retrieval of u's bindings from subtrees of Φ u 's bindings in q1's result.
　c1: preservation of ancestorships. in a minimal vartree  nodes represent essential variables and the hmvds among them are captured by their ancestor-descendant relationships. therefore  if all the ancestor-descendant relationships in v t1 have correspondence mappings in v t1  then it means that the to-be-utilized hmvds required by q1 are all preserved by q1 and also present in q1's result.
　c1: correspondence of construct types. this condition checks the correspondence between query construct types. a var node represents a for expression while a ret node denotes a return expression. the bindings of a ret node are definitely returned whereas those of a var node may be used for constructing new elements correspondingly. therefore  a var node can be mapped to a ret node and still get the correct bindings  while a ret node cannot be mapped to a var node since the new elements in q1's result rather than the original bindings would be returned in doing so.
　we can see from the above conditions that the mac mapping ensures that all the essential variable bindings  the hmvds among them  and their attached returns required by q1 are preserved in the result of q1.
1.1 mic mapping

1
 our technique allows a query to involve more than one xml document. in this case  the corresponding vartree is actually a forest of trees  which may be connected by equality conditions on variables across trees.
1
 here the concept of subtype-supertype is not the same as those in the object-oriented modeling domain. instead  it corresponds to the element inclusion hierarchy in the dtd.
　in addition to the mac mapping  we need to check if the binding set of each node in v t1 is indeed a subset of that of its match in v t1. this is guaranteed by the mic mapping  which essentially checks xpath containment.
　definition 1. let v t1 and v t1 be the minimal vartrees of q1 and q1 respectively. suppose Φ v t1 =v t1 according to the mac mapping. in mic mapping  tree homomorphism is checked between the encapsulated navigation patterns for each pair of matched nodes. two steps are carried out for each node u in v t1:
1. if u 1（ roots v t1   concatenate the xpath expressions along the path from Φ parent u   to Φ u ;
1. assume that the xpath expression on the derivation edge of u is p1 and the one obtained from step  1  is p1. p1  p1 is checked with   denoting xpath containment  i.e.  there is a tree homomorphism from the pattern tree representation of p1 to that of p1 .
　note that if a pair of parent-child nodes  p c  in v t1 maps to a pair of ancestor-descendant nodes  a d  in v t1 by the mac mapping  then p1 is the concatenated xpath expressions originated from a to d. this implies that  to make q1v q1 hold  more essential variables may be specified in q1 than q1 to preserve more hmvds in q1's result. the mic mapping makes sure that p1  the xpath expression used for deriving d's bindings from a's  imposes a less restricted pattern constraint than p1  the xpath expression used for deriving c's bindings from p's.
     $r. $r.bib .bib vt vt1 //book/title. //book/author. //book . price=1  ..//book.
	$b	$b
	$t	$a	  /title. /author.	/title	/author
	$t	$a	$t	$a	$t	$a
	$t	$a/last	$t	$a
 :
figure 1: mac mapping between minimal vartrees
　example 1. figure 1 illustrates two mac mappings. one is between the two vartrees of q1 and q1 in figure 1. Φ v t1=v t1 as shown on the left hand side. for one reason  the var node $b in v t1 has no match in v t1 that satisfies c1. we can hence derive q1 q1.
　the second mapping is between the two vartrees of q1 and q1 in figure 1. the right hand side of figure 1 shows Φ v t1 =v t1  i.e.  Φ $rq1 =$rq1  Φ $bq1 =$bq1  Φ $tq1 =
$tq1  Φ $aq1 =$aq1  Φ $t1 =$t1  and Φ $a/last =$a1 mapping Φ $	 =$aq1 holds due to	 $	 =	 	 $aq1 = author  and last＋:author.
　the mic mapping between the navigation pattern trees encapsulated in the derivation edges of v t1 and those of v t1 is also successful. for example  the pattern tree for the
xpath expression  //book  in deriving $bq1 can be embedded

1
 our xquery fragment allows xpath // *    for which the complexity of containment is conp-complete. however  the xpath containment complexity is reduced to ptime if only two out of the three features are included. we refer the readers to  for the details of xpath containment.
into that for  //book price=1   in deriving $bq1. note that the tree embedding direction for xpath containment p1  p1 is from p1 to p1.
1 tagtree-based containment mapping
　we now address the implications of nested block structure on the containment of xquery.
　one intuitive example of such implications is the reliance of the return semantics on the emptiness of variable binding set s . for example  note that since q1 in figure 1 specifies both $tq1 and $aq1 in the outer block  the construction of a new  pairq1  element occurs only when a book element has both title and author subelements. in other words  if the binding set of $aq1 is empty for a specific $bq1 binding as for example for b1 and b1 in the source xml in figure 1  then there will be no invocation of the return to construct the new elements.
　contrary to this example  the construction of  pairq1  elements for q1 in figure 1 is solely based on the bindings of $bq1  irrelevant of the bindings $tq1 and $aq1. the reason lies in the nested block structure of q1  i.e.  q1 has two query blocks versus that q1 has just one . while variables specified in q1 are the same as those in q1  they however are placed in different blocks  i.e.  $tq1 and $aq1 are specified and returned in the inner block while $bq1 is defined in the outer one  as oppose to being put in the same block as those in q1. consequently  q1 v q1. similarly  we have q1 v q1. recall that the tagtree structure of a query conforms to the nested block  see its definition in definition 1 . the v． and c． in an outer block together compose the evaluation context for those in its descendant blocks. also  variables in the same v． affect each other in the sense that their cartesian product would produce no tuple if any variable member in v． has an empty binding set.
　definition 1. let tt be the tagtree of query q and n= v． c ． r ． t．  be a block node n in it. variables in v． mutually depend on each other. also  they all depend on those variables defined in n's ancestor block nodes. we call such dependencies region dependencies and denote them by  ★.
　intuitively  if there is a variable binding  then v can only be defined either in the same block or a descendant block of where u is defined  i.e.  u  ★ v. however  we cannot imply from u  ★ v. this is formally stated as below.
　lemma 1. for any two variables  then u  ★ v. 1
1.1 block mapping
　we now define a third mapping that complements the previously defined mac and mic mappings.
　definition 1. let tt1 and tt1 be the tagtrees of q1 and q1 respectively. the block mapping is a one-to-many mapping function θ from each block node n of tt1 to nodes of tt1  denoted by θ tt1 =tt1  such that n= v． c ． r ． t．  in tt1 and its image set s=θ n  in tt1 satisfy:
c1  for every variable u （ v．  Φ u  （ sniv．i  ni（s  
c1  for any two variables w x（sniv．i  ni（s   if w ★ x  then there must be u and v in tt1  such that Φ u =w  Φ v =x  u ★v  and
c1  any ci （ snic．i  ni（ s  can be implied by a con-
dition c （  c． “ smic．1   mi is an ancestor block node of n .
　c1': containment of variables. this condition is actually used for establishing the θ mappings  i.e.  finding for each block node n in tt1 its image node set s  based on the vartree node matches. intuitively  a block node ni in tt1 is included in s if any variable in it is the match of any variable u （ v． in n. v． and sniv．i denote variables in n and the union of those defined in n's images ni（s respectively.
　c1': implication of region dependencies. if a variable w in an image node ni of tt1 is involved in a region dependency  e.g.  w ★x   then c1' ensures that there must be a region dependency between the corresponding variables in block nodes of tt1. in other words  the region dependencies with matched variables in tt1 involved must be a subset of those among the corresponding variables in tt1.
　c1': implication of where-conditions. suppose ni in tt1 is an image node of the node block n in tt1. c1' checks if every where-condition ci left in ni can be implied from a where-condition c either in n or an ancestor block of n  i.e.  c （ smic．1  with mi（ancestors n  .
　in a nutshell  c1 ゛ c1 required by the block mapping make sure that q1 must assert more restricted constraints 
i.e.  region dependencies and where-conditions  than q1 does.
　example 1. suppose that two adjacently nested blocks n1 and n1 in tt1 define variables u and v respectively. there is no other variable in n1 or in n1. we also suppose that Φ u  = x and Φ v  = w  and that x and w are defined in the same block n in tt1. by condition c1  we have θ n1  = {n} and θ n1  = {n}. we derive x ★w and w ★x due to the mutual region dependencies asserted by a block node. also  from the enclosing relationship between n1 and n1  we know that u ★v but v 1★u. c1' is not satisfied based on these facts. consequently  the block mapping fails and we derive q1vq1.
　putting all three types of containment mappings together  we now have a sound  not generally complete  solution for xquery containment in the presence of variable binding dependencies.
　theorem 1. given two xqueries q1 and q1  q1 v q1 if there exist a mac mapping Φ v t1 =v t1  a mic mapping p1 p1  i.e.  the encapsulated xpath containment  for every matched node pair  and a block mapping θ tt1 =tt1. 1
1. system and evaluation
　based on our proposed containment mapping approach for xquery  we have designed and implemented a semantic caching system called ace-xq  1  1 . the ace-xq system is developed using java 1. it utilizes the ipsi-xq engine  installed at both the cache and the remote server sites to execute the rewritten query and the original query respectively. source xml documents are hosted at the server.
　the first set of experiments is for validating our containment mapping and rewriting methods for xquery. for this  we designed some query workload1 that includes queries that are similar to those w1c use cases  and are within the scope of our xquery fragment. the experiment shows that the results produced by running a query with and without

1
 we mainly focus on the  refining  case. namely  the hit ratio of a new query being contained in a cached one is high.

figure 1: query response times for different document sizes w/o caching
the attempt of conducting containment mapping and rewriting it against a containing view result are the same.
　the second set of experiments is to evaluate the query performance with and without the semantic cache. as expected  figure 1 shows the improved query performance by up to 1 folds for the totally contained cases in our setting. table 1 shows the break down of the query response time for a contained case into the computation overhead  i.e.  query decomposition and minimization  containment mapping  and rewriting  and the query evaluation time. we see that the overhead is considerably small compared to the query evaluation time. this implies that although the complexity of our xquery containment approach is np-complete in general  since all three mappings are tree homomorphism extensions with additional checking of equivalence conditions  of the inclusive relationships between element types  etc.   it is efficient and practical in many real scenarios.
xmldecomp. &cont.queryquerysizeminimizationmappingrewritingexecution1kb1ms1ms1ms1ms1kb1ms1ms1ms1ms1kb1ms1ms1ms1mstable 1: processing time decomposition
extensive experimental studies can be found in  1  1 .
1. conclusion
　in this paper  we proposed a containment mapping approach that handles the effects of variable binding dependencies and the nested block structure on xquery containment. our approach provides sufficient conditions for solving nested xquery containment.
　an intermediate future work would be to incorporate the xquery logical optimization technique in  in our normalization step to reduce the possible navigation redundancies in the vartree representation. this helps to prune the space for conducting containment mapping. however  the lack of this optimization step as of now does not impact the soundness of the approach.
　the xquery fragment defined in this paper provides a good scope for us to focus on a set of important xquery features with respect to the containment problem. we plan to extend the proposed containment mapping approach to accommodate a broader fragment of xquery that includes disjunctions  aggregations  and other features as well as to consider more general constraints in xml and xquery.
