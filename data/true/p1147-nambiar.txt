agents manning a service desk have the unenviable task of satisfying multiple conflicting objectives. specifically  businesses require the agents to meet pre-specified customer satisfaction levels while keeping the cost of operations low or meeting sales targets  objectives that end up being complementary. additional complexity is introduced by the fact that the objectives are often inter-dependent and have to be met in real-time. moreover  business might change the objectives from time to time e.g. from reducing cost of operation to increasing sales of slow moving product. in this paper  we describe callassist - a speech enabled real-time dialog management system that dynamically helps agents in building a conversation that meets the various business objectives while satisfying customer requirements. an added benefit of our solution is the ability to adapt to changing business needs without incurring agent re-training costs. we provide evaluation results displaying the efficiency and effectiveness of our system.
categories and subject descriptors
h.1  database management : systems-relational databases  query processing; j.1  computers in other systems  : real time
general terms
algorithms  design  management  performance
keywords
preference elicitation  real-time entity analytics  dialog systems

 work done while visiting ibm india research lab  delhi as summer intern.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod'1  june 1  1  vancouver  bc  canada.
copyright 1 acm 1-1-1/1 ...$1.
1. introduction
　the increasing complexity and variety in products and services being offered by businesses has made providing customers with easy access to technical assistance an important business function. therefore  most businesses operate service desks to respond to informational queries and provide personalized help during product purchase. agents at the service desk interact with customers to provide them necessary information or to help them in placing an order. even though easy to explain  the job is made difficult when we consider the fact that agents must satisfy multiple conflicting objectives of the business providing the service to the customer. specifically  businesses require the agents to meet pre-specified customer satisfaction levels  csat  by maintaining high first time problem resolution rates  ftr  but insist on agents keeping the cost of operations low by having low average call handling times  aht . additional complexity is introduced by the fact that the objectives have to be met in real-time and that the objectives could vary depending on the type of support being provided  the needs of the customer and the expertise of the agent. moreover  the businesses might change the objectives from time to time e.g. from reducing cost of operation to increasing sales of slow moving product. the problem is aggravated by the fact that the objectives are often inter-dependent - a low customer satisfaction can lead to lesser profits in the long term. moreover  in service desks that are setup to help in purchasing a product  the businesses prefer agents pitching a higher profit substitute whenever possible. for example  in our study of service desk practices followed by a leading us car rental company  we found that its agents were trained to suggest the more profitable full size sedans first before offering the economy options to customer. while the model worked well  it was difficult to move to other models such as - suggest cars that sat longer on the lot first  without considerable re-training cost. the business objectives may also vary depending on the customers domicile location and in such cases it becomes harder to meet the objectives as putting an agent for each potential customer location is not feasible. asking a limited set of agents to learn a variety of process models would increase the agent training cost and also may result in adversely affecting the aht  ftr and csat values.
　the inter-dependence between aht  csat and profit of the business is graphically displayed in figure 1. we derived this model after discussions with operation managers handling third-party service desks. in general  as the aht increases  the profit from selling more items increases. however  csat decreases as customers have to wait longer to talk to an agent and then have a longer conversation for problem resolution. but  as marked in the figure  there

figure 1: model of aht and csat interaction
obviously is a optimal region where both the aht and csat will fall within acceptable limits and result in overall profit to the business. agents are constantly monitored and pushed to attain this optimal goal. the task evidently is complex and stressful even for experienced agents. the net result is large attrition rates and resulting high cost of training new agents. as service desks continue to evolve from being just a point-of-service to a point-of-sale  the problem of ensuring that diverse business objectives are met will become even more critical. hence  a solution that allows businesses to vary their objectives without having to re-train the agents manning the service desks will be immensely useful.
　to assess the potential benefit of having a system for conversation management  we looked at a collection of 1 voice calls made by customers of a leading car rental agency in the us. average call length was 1 minutes and 1 seconds and contained an average of 1 questions answer pairs per call. we manually inspected 1 randomly selected calls for potential call time reduction assessment. among them 1 calls had agents asking redundant queries leading to an average saving of 1 seconds while 1 calls had a significant silence period which if avoided would lead to an average savings of 1 seconds. in computing savings we ignored queries posed by agents to confirm the answers given by the customer. also  we considered only the continuous silence periods greater than 1 seconds. while the savings look simple  their effect gets compounded when considered across all the calls an agent handles during a day and could lead to smaller wait times for customers.
　in this paper  we present callassist   a conversation management system designed to help service desk agents in solving the customer's need while ensuring that the diverse business objectives are also met. callassist is similar in spirit to general dialog systems  and consists broadly of three parts - a query formulation strategy  a partitioning strategy based on maximal information gain that determines which attribute to ask next and a termination criteria based on lack of additions to top-k mapping entities. however  callassist differs from other dialog systems as it is not interacting directly with the customer but only helping the agent in meeting the needs of the business. furthermore  we also deal with issues resulting from real-time speech transcription errors which other dialog systems do not tackle.
　since most service desk interactions are audio conversations  our solution is built for assisting an agent handling real-time audio conversations. however  the solutions developed can be easily adapted to help agents interacting over chat and email too. specifically  we model each service desk conversation as a series of questions and answers that lead to identification of a desired piece of information from a database  henceforth called an entity1. the challenge is to narrow the context of the conversation to eventually focus on an entity that satisfies the customer requirement and at the same time help the agent meet the high level objective of maximum profit. accordingly  we start by automatically extracting the most relevant set of entities for the current stage of the conversation. based on the extracted set of entities  pre-computed values of user interest and profit  we then identify the best query that the agent should ask. herein lies our first challenge: how to ensure that the query suggested would not only reduce the number of entities with low eventual relevance but also maximize the chances of obtaining the highest profit  moreover  our query generation model has to be flexible enough to allow the business to sacrifice profit for improved csat and vice-versa. our solution hinges on the ability to quickly identify a potential set of entities that will map to the conversation. this brings forth our second challenge - how to efficiently map relevant entities to the current conversation . our problems are complicated by the fact that the interactions between customer and agent is over a real-time audio call and therefore the customer expects satisfactory answers and suggestions in real-time. the realtime response constraint brings additional complexity to the above mentioned challenges. we will use the example below to further highlight the challenges and to briefly explain out solution.
example: suppose agent at a car rental service desk receives the query:  hi  i want to know rates for a rental next week at vegas. 

　the customer obviously has a vague idea of potential car in mind which she is likely to reserve. however  to gain her business  the agent will need more information about the customer's preference. the standard practice  as learnt from observation and discussions  is to ask a scripted list of queries that will ask for rental duration  pick-up and drop-off location. the agent will issue a query over the back-end database and give a rate for a full size car for the duration requested. the rate suggested by default is quite often not satisfactory and so the customer or the agent will then suggest/ask for other car types e.g. compact  economy  standard etc. if rates suggested for alternate models are not acceptable  then agents may ask customer if they are eligible for discounts via memberships to certain groups or based on age etc. this standard process of eliciting customer's preference is not conducive for providing the best customer satisfaction or for maximizing benefit to the company. in our example scenario  the fact that the request is for a rental at vegas  could be used to suggest a convertible or an suv - car models that are often requested by customers for that region. while experienced agents may go beyond the script to satisfy the customer  the high volumes of calls handled together with the exponential set of options result in the agents not deviating from the script in general. assigning a group of agents for a certain geographical region and providing additional training to provide more personalized service would result in higher training costs but cannot guarantee higher profits by way of more bookings. thus  formulating the right set of queries has many challenges. foremost among them is the need to quickly identify the queries that are answerable by the customer and will lead to an eventual entity that is likely to be of interest to the customer and result in a booking. as explained above  the success of the overall conversation could vary depending on the amount of additional information that is made use of by the agent. often  in the interest of not affecting the aht  agents will not deviate from the scripted conversation model and end up not getting the business.

1
 an entity is a  thing  of significance  either real or conceptual about which the relational database holds information .
　the solution we provide begins by assuming that all conversations handled by callassist will eventually lead to a unique entity stored in a back-end database. in other words  every conversation will contain the context of a single entity stored in the database. for the example above  an entity is a tuple in a virtual database that consists of a cartesian product of tuples in the cars table and promotions table. our interest is in terms that might appear in a categorical attribute describing the entity and since most categorical attribute bindings are done using noun phrases  we select noun phrases as keywords e.g. vegas in the above example. obviously  a large number of potential entities would appear for vegas. to narrow the list  we then formulate easy to answer yet highly classifying queries using our objective function that combines user interest for entities in the currently extracted set and profit that business can obtain if one of them is chosen by the user. this is the guiding principle behind our approach - measure the context of the current conversation as the number of entities that can map to it and then suggest queries whose answers will lead to a reduction in the mapped set of entities while ensuring that the business objective of reduced aht  higher profit or both are adequately met by the resulting new set of entities. our solution is domain-independent and can be used by an agent with minimal understanding of the business. our system can also identify up-sell 1/cross-sell 1 opportunities. for example  if the pick-up and drop-off locations are in different states  we could prompt the agent to suggest a navigation system as part of the rental.
our main contributions can be summarized as follows:
1. we identify an ever increasing business need for  and thetechnical challenges involved in  satisfying multiple complementary business objectives during a service desk conversation.
1. we provide an objective function that combines user interestfor an entity with the likely profit from the entity and enables dynamic generation of queries that satisfy the various business objectives.
1. we present an efficient real-time entity mapping algorithmthat enables extraction of entities relevant to the conversation.
1. we present results of thorough experimental evaluation ofour proposed technique.
　we list related research efforts in section 1. an overview of our approach is given in section 1. the process of automatic generation of maximal benefit queries is explained in section 1. the realtime entity mapping solution is explained in section 1. section 1 describes our approach at reducing the effect of noise introduced by asr systems. section 1 presents evaluation results over both synthetic and real-life data. we summarize our contributions in section 1.
1. related work
　entity matching in callassist is similar to dictionary-based namedentity recognition  ner   1  1  1  where the focus is to identify sequences of terms within the documents as named-entities such as person name  company name  location  etc. by exploiting explicit

1
up-sell is a marketing term for the practice of suggesting higher
priced products or services to a customer. 1
 cross-sell is a marketing term for the practice of suggesting related products or services.
lists  dictionaries  of single and multi-word terms and patterns. unlike ner  callassist identifies entities even when they are not explicitly mentioned in the input stream.
　record matching techniques are primarily relevant to structured records   but can be extended to semi-structured records  such as paper citations and street addresses  by including text-segmentation as a pre-processing step  1  1 . callassist  in contrast  matches structured records with streaming unstructured text generated from real-time audio conversation. any segmentation effort must be done in real-time with incomplete data due to the streaming nature of the input. existing techniques for segmentation are not easily applicable in this situation if errors are to be kept to a minimum.
　semantic integration in text  is the task of identifying whether different entities identified using ner within or across documents correspond to the same real-world entity; this identification is done by matching multiple features extracted using natural language rules. note that the real-world entity is not available for reference  which is an inherent limitation. in callassist  the focus is to match mentions of an entity in a real-time audio conversation with a welldefined structured representation of the entity  which acts as a reference.
　most research related to call centers is focused on call routing  1  1 ; the task of forwarding callers to the right resource in the call center. here  ir techniques are typically used to compare the customers request to a set of known classified requests. eresponder  stores question and answer pairs that have previously been asked and answered. these pairs can be used to either provide an immediate response to user questions  or to assist agents in drafting new responses to similar questions or to yet unanswered questions. callassist  differs from the above approaches as it is relating an incoming query to entities stored in a database. moreover  based on the query context and entities identified  callassist will suggest additional queries to the agent. this is different from providing a list of queries that were asked previously by other agents. however  when available  the historic information can be exploited to improve the efficiency of callassist.
1. overview of our solution
　in our current implementation  we make the assumption that most service desk conversations will eventually lead to a single entity of interest. i.e.  we assume that there is only one entity  that is being referred to by the customer. our surveys reveal this assumption is true for most service desk calls. in particular  this allows us to define a stopping criteria for the system. we acknowledge that our assumption of single entity per conversation will not hold for all service desk conversations. in some cases  parts of a conversation may refer to different entities. we can handle such situations by looking for k-best entities. below  we first provide the high level architecture of our system  define essential terms and then provide a formal problem statement.
1 architecture
　the architecture and the flow of information through our system is illustrated in figure 1. callassist consists of three main subsystems: an automatic speech recognition asr  system  the context controller and entity mapper. the context controller has three subcomponents - the stream segmenter  ss   context builder  cb  and query builder  qb .
the output from ss - a subset of the audio conversation that has
been buffered; is sent to entity mapper as the unstructured text to which entities have to mapped. a detailed explanation of the mapping process is given below in section 1. once the best matching entities for each keyword are identified  entity mapper returns them

figure 1: architecture diagram
to the cb which then constructs the current context for the conversation. the conversation context is defined as a set of best matching entities for all keywords appearing in the conversation. these context defining entities are then shown to the agent and also used by qb to build the next best query to recommend to the agent. we explain the techniques used by qb in section 1. given the limited space available on the agent's desktop  we must ensure that only the most relevant parts of an entity are displayed to the agent. the information  set of attributes  displayed must explain why the given set of entities were chosen from all the entities available. moreover  the queries suggested should involve the attributes that are being displayed  so that the agent is aware of what answers to expect from the customer. thus  deciding an output schema for the extracted entities at run-time is a non-trivial task. in fact  this problem quickly becomes np-complete as shown in . hence  in our current implementation  we assume that a output template corresponding to each primary template is given at design time. we plan to extend the heuristics identified in  to develop dynamic display solutions.
1 definitions
　we assume the entity can be described by a single database table t = {t1 t1 .. tm} with n categorical attributes a = {a1 .. an} and with m tuples. we ignore the non-categorical attributes in this work. each attribute ai in a tuple is bound by a value vij from its domain di = {vi1 vi1 .. viki}.
1.1 queries
　we broadly classify the queries suggested to the agent into two classes - attribute queries and value queries. attribute queries probe the user for the preferred binding value of an attribute  like  which class do you prefer  . potential answers are assumed to be a value belonging to the domain of the attribute. value questions ask user's preference for a particular value lying in the of an attribute. for example   do you prefer business class   is a value query asking for customers preference of flying class=business. value queries are boolean queries and must be answered with yes or no. the set of attribute queries is defined as qa = {qa1 .. qan} where each qai （ qa asks user's preference for the ith attribute. the set of value queries qv = {qv1 qv1 .. qvn} where qvi is the set of value questions probing user's interest values of attribute ai  and qvi = {qi1 qi1 .. qiki} where qij is question value of ai. the complete set of possible queries then is
	=	a	v.
1.1 customer preference
