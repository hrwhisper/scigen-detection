xml has a tree-structured data model  which is used to uniformly represent structured as well as semi-structured data  and also enable concise query specification in xquery  via the use of its xpath  twig  patterns. this in turn can leverage the recently developed technology of structural join algorithms to evaluate the query efficiently. in this paper  we identify a fundamental tension in xml data modeling:  i  data represented as deep trees  which can make effective use of twig patterns  are often un-normalized  leading to update anomalies  while  ii  normalized data tends to be shallow  resulting in heavy use of expensive value-based joins in queries.
　our solution to this data modeling problem is a novel multicolored trees  mct  logical data model  which is an evolutionary extension of the xml data model  and permits trees with multicolored nodes to signify their participation in multiple hierarchies. this adds significant semantic structure to individual data nodes. we extend xquery expressions to navigate between structurally related nodes  taking color into account  and also to create new colored trees as restructurings of an mct database. while mct serves as a significant evolutionary extension to xml as a logical data model  one of the key roles of xml is for information exchange. to enable exchange of mct information  we develop algorithms for optimally serializing an mct database as xml. we discuss alternative physical representations for mct databases  using relational and native xml databases  and describe an implementation on top of the timber native xml database. experimental evaluation  using our prototype implementation  shows that not only are mct queries/updates more succinct and easier to express than equivalent shallow tree xml queries  but they can also be significantly more efficient to evaluate than equivalent deep and shallow tree xml queries/updates.

 supported in part by nsf under grants iis-1 and iis1.
 supported in part by grants from nserc  canada  and bc advanced systems institute.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage  and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod 1 june 1  1  paris  france.
copyright 1 acm 1-1/1 . . . $1.
1. introduction
　xml  extensible markup language  is rapidly becoming the de facto standard for exchanging data between applications  and publishing data  on the web. the data model that underlies xml is tree-structured  comprising nodes  atomic values and sequences   and is used by query languages such as xpath  and xquery .
　the importance of the tree structure in the xml data model can be appreciated from the rich variety of ways in which xpath and xquery support  navigation  between structurally related nodes in an xml database. in contrast  for xml nodes that are related only through values  of the id/idref attributes  or otherwise   one needs to explicitly perform value-based joins  one  edge  at a time  akin to sql queries over relational databases. the following example is illustrative:
example 1.  deep trees vs shallow trees 
consider a movie database  with elements movie  movie-genre  movie-award actorand movie-role. there are many ways of organizing this information in xml  two of which are:
deep-1: the movie-genre nodes are hierarchically organized  with each movie as a child of its primary movie-genre node. each moviehas children movie-awardand movie-rolenodes  and movie-role nodes have children actor nodes.
shallow-1: the nodes are in a shallower tree structure  and the relationships between movie-genre and movie nodes  between movie-award and movie nodes  and between movie  actor and movie-rolenodes  are captured via attributes values. nodes have an id attribute  a movie may have a movieawardidrefs and a moviegenreidrefs attributes  and movie and actor nodes have the roleidrefs attributes.
　consider the query  return names of comedy movies nominated for an oscar  in which bette davis acted . in the deep-1 approach  one can write the following xquery expression:
for $m in document  mdb.xml  //movie-genre  name =  comedy  //movie .//actor/name
     =  bette davis   where contains $m/movie-award/name   oscar   return  m-name  $m/name  /m-name 
　in the shallow-1 approach  one would have to use value-based joins. the xquery expression would be:
for $mg in document  mdb.xml  //movie-genre
 name =  comedy  //movie-genre 
$m in document  mdb.xml  //movie 
$ma in document  mdb.xml  //movie-award 
$a in document  mdb.xml  //actor
 name =  bette davis   
     $r in document  mdb.xml  //movie-role where contains $ma/name   oscar   and $mg/ id = $m/ moviegenreidref and contains $m/ movieawardidrefs  $ma/ id  and contains $m/ roleidrefs  $r/ id  and
contains $a/ roleidrefs  $r/ id 
return  m-name  $m/name  /m-name 
　note that the deep-1 query expression is much simpler than that of shallow-1. the increased complexity of the shallow-1 expression would also  typically  result in an expensive evaluation  which cannot make an effective use of structural joins developed for the efficient evaluation of xquery's path expressions  1  1 . 
　the improved query specification and evaluation in deeper trees over shallower trees comes at a cost. the deeper representations are un-normalized   and the replication of data  e.g.  the actor and the movie-award nodes  in the above example  raises the problem of update anomalies  e.g.  if one wanted to add a subelement birthdate to an actor . it appears that neither the deep tree approach nor the shallow tree approach is ideal both for queries and for updates. what is an xml database designer to do 
　the solution proposed in this paper to effectively address the above-mentioned inadequacies of the conventional xml data model is a novel logical data model  referred to as multi-colored trees  mct . our mct data model is an evolutionary extension of the xml data model of  and  intuitively  permits multiple colored trees to add semantic structure over the individual nodes in the xml data. individual nodes can have one or more colors  permitting them to be hierarchically related to other nodes in a variety of ways  instead of only in one way. this allows  extended  xquery expressions to navigate between structurally related nodes  taking color into account  instead of relying heavily on value-based joins. an  enhanced  xquery expression can be used to create a new colored tree over a combination of newly created and existing nodes  and an  enhanced  update expression can be used to modify existing data in the mct data model. we develop our technical contributions in the rest of the paper as follows:
we present the mct logical data model  consisting of evolutionary extensions to the xml data model  in section 1.
we propose extensions to the xquery query language  for the mct logical data model  in section 1.
while mct serves as a significant evolutionary extension to xml as a logical data model  one of the key roles of xml is for information exchange. to enable exchange of mct information  we develop an algorithm for serializing an mct database in a schema-optimal way  as xml  in section 1.
we discuss alternative ways in which a logical mct database can be physically represented and manipulated  using relational and native xml databases  and describe an implementation on top of the timber native xml database  in section 1.
we used our prototype implementation to experimentally compare mct queries and updates against equivalent xml queries and updates  both for shallow and for deep xml trees  in section 1. our results demonstrate that not only are mct queries/updates more succinct and easier to express than equivalent shallow tree xml queries/updates  but they can also be significantly more efficient to evaluate than equivalent deep and shallow tree xml queries/updates.
　anecdotal evidence suggests to us that choosing a suitable hierarchy structure is one of the more difficult tasks in xml database schema design. the use of a multi-colored tree model eases the burden of the designer  while at the same time permitting concise query specification and efficient query evaluation over a range of queries that could not all be well supported with a single choice of hierarchy.
　next  in section 1  we present an overview of our mct data model  and highlight its benefits over the conventional xml data model using examples. related work is discussed in section 1  and we conclude in section 1  outlining several areas of research opened up by the mct data model.
1. overview of the mct model
　the w1c has focused considerable recent attention to developing a logical model and query language for xml  see  for example   1  1  1  1  . the xml data model is an ordered tree of nodes  with atomic values associated with leaf nodes.
　using examples  we next highlight the benefits of permitting multiple trees  instead of just a single tree  to add semantic structure over the individual data nodes. each tree is distinguished from the others by a color  and the resulting logical model is called the multi-colored tree  mct  data model. we will present a formal development of the mct data model in subsequent sections.
1 movie nodes with multiple colors
　consider  again  the movie database from example 1. there are several natural hierarchies: movie genres are akin to a topic hierarchy  e.g.  comedy and action are sibling genres  and slapstick is a sub-genre of comedy   and the oscar best-movie awards can be organized into a temporal hierarchy. individual movies can be naturally classified into each of these hierarchies: a movie can be a child of its most-specific primary movie genre  and  if the movie was nominated for a best-movie oscar award in a particular year  it can be made a child of that year's node in the best-movie award hierarchy.
　explicitly modeling such hierarchies in xml allows xquery expressions to be effectively used for formulating queries like query q1  in figure 1   without having to identify the most-specific genre of the movie. while xml allows either of these hierarchies to be modeled  it does not permit a natural modeling of both these hierarchies simultaneously; one of these hierarchical relationships would need to be captured using attribute values  increasing the complexity of the xquery specification of a query like q1  in figure 1 .
　our multi-colored tree data model extends the xml data model in permitting both these hierarchies to be first-class semantic hierarchies over the data nodes  simultaneously. queries like q1 can be easily expressed in a simple extension of xquery  that takes color into account in its path expressions. we illustrate an example mct database in figure 1.
example mct database: we depict a multi-colored tree database by showing each colored tree separately. the example mct movie database in figure 1 has trees of three colors: red  green and blue. for the moment  focus on just the red and the green trees. the red tree consists of  among other nodes  the hierarchy of movie-genre nodes  and their associated children name nodes. the green tree consists of  among other nodes  the temporal hierarchy of oscar movie-award nodes  and their associated children name nodes. all edges in a colored tree have the same color  depicting the parentchild relationships in that colored tree.
　a node is stored once in the database irrespective of how many colored trees it participates in. a node that has multiple colors
q1 : return names of comedy movies whose title contains the word eve.
q1 : return names of comedy movies that were nominated for an oscar  whose title contains the word eve.
q1 : return names of comedy movies that were nominated for an oscar  in which bette davis acted.
q1 : return names of actors in movies nominated for an oscar  with more than	votes.
q1 : return the list of oscar nominated movies  grouped by the number of votes received.
figure 1: example queries against movie database

figure 1: example mct database comprising three single-colored trees. multi-colored nodes occur in multiple trees  are represented with multiple circles  and have associated an identifier label comprising the node colors  by their initials  and a unique node number e.g.  rg1.
is represented in each of its colored trees  e.g.  as a green circle with a red outer circle in the green tree  and as a red circle with a green outer circle in the red tree. in the example mct movie database  a movie node is both red and green  i.e.  it participates in both colored hierarchies   if it has been nominated for an oscar movie-award. a movie node is only red if it has not been nominated for an oscar movie-award. in the example  the children name nodes of movie nodes have all the same colors as their parents. in addition  movie nodes that are both green and red have green children votes nodes  indicating the number of first-place votes received.
example queries: as in xquery  multi-colored xquery  mcx-
query  queries are flworexpressions  for  let  where  order by  return  with path expressions replaced by their colored counterparts. an ordinary path expression identifies nodes within a single tree by executing different location steps; each step generates a sequence of nodes and filters the sequence by zero or more predicates. a colored path expression additionally specifies colored labels with each location step  using curly braces  identifying the colored tree s  to navigate in that location step. unabbreviated mcxquery expressions for queries q1 and q1  of figure 1  are given in figure 1.
1 movie-role nodes with multiple colors
　consider  again  our movie database in figure 1. all actor nodes and their children name nodes are represented in a  relatively  shallow blue hierarchy. since each movie-role node captures the relationship of an actor with a movie  these nodes  and their children name nodes  can be made both red and blue: its red parent is the movie node  and its blue parent is the actor node participating in this specific relationship. note that  to demonstrate the flexibility of our mct data model  we have chosen  arbitrarily  not to let movie-role nodes be green  even if the movie was nominated for an oscar movie-award.
　having modeled actor nodes and movie-role nodes  we can now use multi-colored xquery to concisely express query q1  as in figure 1. note that multiple colored path expressions are needed in the for clause  since we decided to conservatively extend xquery  which currently does not support the ancestor and ancestor-or-self axes . if these axes were supported  query q1 would be expressible using a single colored path expression  with different colors used at different location steps.
1 colors are not views
　an alternative to the mct model is to use xml views: create deep tree views over the  stored  shallow tree data  and let users pose queries against the deep tree views. for example  one could specify deep-1  in example 1  as an xquery view over shallow1. while this would ease query specification  query evaluation over an unmaterialized view would still be expensive. further  and more importantly  updates would still be problematic. since updates through xml views can be ambiguous in general  just as for sql views   users would be forced to specify updates over the shallow tree representation  requiring them to be aware of two representations  one for querying and one for updates. materializing the view can address the query evaluation efficiency  but leaves the update issue unresolved.
　in contrast  each element  content and attributes  is stored precisely once in the mct model  irrespective of the number of colors it has. also  edges between mct nodes are independently specified in each colored tree  and are expected to be semantically independent; if there are dependencies between edges  these must explicitly
q1:for $min document  mdb.xml  / red descendant::movie-genre  red child::name
red descendant::movie contains  red child::name   eve   = comedy  /returncreatecolor black   m-name  $m/ red child::name  /m-name  q1:for $min document  mdb.xml  / red descendant::movie-genre  red child::name
red descendant::movie contains  red child::name   eve    = comedy  /$min document  mdb.xml  / green descendant::movie-award
 contains  green child::name   oscar   / green descendant::moviereturncreatecolor black   m-name  $m/ red child::name  /m-name  q1:for $min document  mdb.xml  / green descendant::movie-award
 contains  green child::name   oscar   / green descendant::movie $rin document  mdb.xml  / red descendant::movie-genre  red child::name
red descendant::movie . = $m / red child::movie-role = comedy  /$rin document  mdb.xml  / blue descendant::actor
  blue child::name =  bette davis  / blue child::movie-rolereturncreatecolor black   m-name  $m/ red child::name  /m-name  q1:for $ain document  mdb.xml  / green descendant::movie-award
 contains  green child::name   oscar   / green descendant::movie
  green child::votes	1 / red child::movie-role/ blue parent::actorreturncreatecolor black   a-name  $a/ blue child::name  /a-name  q1:createcolor black   byvotes  for $v in distinct-values document  mdb.xml  / green descendant::votes  order by $v return
 award-byvotes 
for $m in document  mdb.xml  / green descendant::movie  green child::votes = $v  return $m
 votes  $v  /votes 
 /award-byvotes 
 /byvotes  figure 1: example mcxquery queriesbe specified as constraints. thus  using mct  one can avoid redundant storage and also update anomalies.
1 overview of the rest of the paper
　data modeling traditionally distinguishes between the logical data model  which consists of data values  structured by a schema and manipulated by the query language  and the physical data model  which focuses on the storage  indexing and transformation of these data values. we make the same distinction  and  in addition  consider an exchange data model  which deals with the serialization of data values for exchange between applications.
　mct is our logical data model  structuring data values using multiple hierarchies  and the bulk of this paper is devoted to mct  section 1   and its related query and update languages  section 1 . one of the key roles of xml is for information exchange  so we develop algorithms for serializing  as xml  an mct database in section 1. there are multiple physical data models currently being investigated for storing xml data  including relational and native approaches; in section 1  we illustrate how these approaches could be extended for storing and manipulating mct databases  and describe our implementation of mct on top of the timber native xml database. finally  in section 1  we validate our intuitions about the many benefits of mct queries and updates  using our prototype implementation.
1. the mct logical data model
　in this section  we formally develop the mct logical data model  which we motivated and illustrated using examples in the previous section. mct is an evolutionary extension of the xml data model of   and  hence  is presented as such. as we shall see in the next section  this evolutionary approach allows us to build on query and update languages proposed for xml to obtain manipulation languages for mct databases.
1 multi-colored trees
　nodes in the xml data model are organized in a data tree  which defines a global document order of nodes  obtained by a pre-order  left-to-right traversal. every xml data model value is a sequence of zero or more items  where an item is either a node or an atomic value. the multi-colored trees  mct  data model enhances the xml data model in two significant ways:
each node has an additional property  referred to as a color  and nodes can have one or more colors from a finite set of colors .
a database consists of one or more colored trees   where each node in has color  as one of its colors .
more formally  we have:
　definition 1.  colored tree  let be a finite set of nodes of the seven kinds defined by the xml data model  and be a finite set of colors. a colored tree   where  i  the set of nodes ;  ii  the set of edges defines an ordered  rooted tree  satisfying the tree relationships imposed by the xml data model between the different kinds of nodes  with a
dm:parent $n as node 
$c as xs:string  as node 
dm:string-value $n as node 
　　$c as xs:string  as xs:string  dm:typed-value $n as node 
　　$c as xs:string  as atomicvalue* dm:children $n as node 
$c as xs:string  as node*figure 1: modified node accessors
triple specifying that node has as its parent and as its left sibling.1 
　essentially  a single colored tree is just like an xml tree. allowing for multiple colored trees permits richer semantic structure to be added over the individual nodes in the database.
definition 1.  mctdatabase  a multi-colored tree  mct 
is defined as a triple   where  i  each   is a colored tree;  ii  ; and  iii  each attribute  text and namespace node associated with an element node in any of the colored trees has all the colors of   and has as its parent node in each of its colored trees.
　an mct is said to be an mct database if the root of each of its colored trees is the same document node  which  hence  has all colors in    else it is an mct database fragment. 
　intuitively  in an mct database  fragment   a node belongs to exactly one rooted colored tree  for each of its colors. this is similar to the xml data model  where a node can belong to exactly one rooted tree. unlike an xml database  however  there is no global document order of nodes in an mct database: each colored tree defines its own local order of nodes  obtained by a pre-order  left-to-right traversal of the nodes in the colored tree.
1 node accessors
　in the xml data model   ten accessors are defined for all seven kinds of nodes. four of these accessors  namely  dm:parent  dm:string-value dm:typed-value and dm:children  would need to be extended to take a color into account. their signatures are given in figure 1. if the node on which these accessors are called does not have the color that is passed as an argument to the accessor  an empty sequence is returned. otherwise the node and the accessor are said to be color compatible  and the desired result is returned from the appropriate colored tree.
　the other six accessors defined in the xml data model  namely  dm:base-uri dm:node-kind dm:node-name dm:type  dm:attributes  and dm:namespaces  are not influenced by the color of the node  and continue to have the same signature and meaning as in the xml data model.
　in addition  a new accessor needs to be defined on all node kinds to determine the colors of a given node: dm:colors $n as node  as xs:string+
1 node constructors
　in the xml data model  each node kind defines its constructors  which always return a new node with unique identity. this is feasible since the nodes can be constructed iteratively  in a  bottom-up  fashion in the xml tree. in our mct data model  it is not always

possible to construct a node only after all its children in each of its colors have been constructed  e.g.  element node may be a child of element node in one color  but a parent in a different color. to effectively permit the construction of multi-colored trees  we define two different types of constructors for each node kind.
first-color node constructors are like constructors in the xml data model  except that they are extended to take a color into account  and return a new node with unique identity.
next-color node constructors take a previously constructed node  and add a color and the tree relationships in that color; the same node is returned.
　example constructor signatures for the element node are depicted in figure 1. note that the signature of the next-color constructor is somewhat smaller than that of the first-color constructor  since one does not need to repeat some of its properties  and its attribute and namespace nodes.
　the mct logical data model defines allowable syntactic structures. the semantics of the database are captured by its schema. the xml schema language proposed by the w1c deals with both structure  and datatypes . while we briefly use mct schemas in section 1  formally extending xml schema to multi-colored trees is an interesting direction of future work.
1 shallow and deep
　we conclude this section by characterizing the intuitive notions of shallow and deep xml trees the we have used in our examples.
　we call an xml schema shallow provided it is in xnf  as defined in . more precisely 
　definition 1.  shallow  deep schemas  let be a schema  where is a dtd and is a set of functional dependencies. then  is shallow provided for every non-trivial functional dependency or that is implied by   the functional dependency is also implied by   where is any dtd path from the root. is said to be deep if it is not shallow. 
　it is easy to verify that the deep-1 and shallow-1 trees used in example 1 indeed satisfy the above definition. note that this definition permits schemas with non-trivial hierarchies to be characterized as shallow. further  a shallow schema is not necessarily unique  e.g.  a schema with a non-trivial hierarchy can always be flattened  using id-idrefs   while preserving its  shallowness .
1. data manipulation languages
　we now formally develop the mcxquery logical query language  which we motivated and illustrated using examples in section 1. the mct data model  being an evolutionary extension of the xml data model  allows us to naturally build our logical query language as an extension to xquery .
1 mcxquery path expressions
　an xquery path expression can be used to locate nodes in treestructured xml data. here we discuss only the unabbreviated syntax for path expressions; abbreviated syntax can be developed for some expressions  as used in examples early in the paper .
examples of  unabbreviated  xquery path expressions include:
document  mdb.xml  /child::movie-genre descendant::movie-genre name =  comedy  
$c/parent::node  
dm:element-node $qname as xs:qname  $nsnodes as namespacenode*  $attrnodes as attributenode* 
　　$children as node*  $type as xs:qname  $color as xs:string  as elementnode dm:element-node $self as elementnode  $children as node*  $color as xs:string  as elementnode
figure 1: modified and new node constructors　in the mct logical data model  a node may have multiple colors  in which case it would belong to multiple colored trees. hence  an axis and a node test specification  e.g.  parent::node    does not suffice to uniquely identify the navigation to be performed in a single step  from a context node. for example  in the mct database of figure 1  the movie node rg1 has two parent nodes: a movie-genre node in the red tree  and a movie-award node in the green tree. however  since a node belongs to exactly one rooted colored tree  for each of its colors  augmenting the specification of a step by a color would serve to provide the necessary disambiguation.
　we achieve this by enclosing the color specification in curly braces  preceding the axis specification in the step expression  e.g.  red descendant::movie  blue child::movie-role.
the extensions to the relevant productions in the grammar of xquery are shown in figure 1. in general  different steps in an mcxquery path expression may have different color specifications  and the resulting navigation over the mct database can be quite sophisticated. the result of evaluating an mcxquery path expression is  as before  a sequence of items  all of which have the same color  as determined by the color specification of the final step in the path expression. the order of items in the result sequence is determined by their local order in the corresponding colored tree.
　figure 1 presents a few illustrative path expressions in mcxquery  with each step augmented by a color specification. query q1  in particular  illustrates the use of different color specifications in different steps of the path expression.
1 mcxquery constructor expressions
　xquery provides constructor expressions that can create xml tree structures within a query  based on the notion of constructors for the different node kinds in the xml data model.
　when the name of the element to be constructed is a constant  the element constructor is based on standard xml notation. enclosed expressions  delimited by curly braces  to distinguish them from literal text  1 can be used inside constructors to compute the content of the constructed node  and also its attributes.1 enclosed expressions are evaluated and replaced by their value  which may be any sequence of items . for example  the return clauses of the deep-1 and shallow-1 queries in the introduction have constructor expressions with enclosed expressions.
　since every tree in the mct logical data model is a colored tree  xquery constructor expressions are suitable for the creation of new colored trees in an mct database as well. one such constructor expression could be used for the creation of each colored tree  and an mct database/fragment could be created using multiple constructor expressions. one key issue needs to be resolved  however. the result of an element constructor in xquery is always a new ele-

ment node  with its own identity; all the attribute and descendant nodes of the new element node are also new nodes with their own identities  even though they may be copies of existing nodes.
　always creating a new node is inappropriate for constructor expressions in mcxquery  since such a node would have a different identity from existing nodes in the mct database  limiting the capability of mcxquery constructor expressions in creating mct databases/fragments  where nodes belong to multiple colored trees. to effectively permit the construction of multi-colored trees  mcxquery constructor expressions need the ability to reuse existing nodes and their descendants  in addition to being able to create element nodes with new identities. this is achieved as follows.
when an enclosed expression is evaluated  its value  a sequence of items  retains the identities of nodes in the sequence  instead of creating copies by default. this is similar to the behavior of mcxquery path expressions.
to create node copies  mcxquery provides a function named createcopy. the createcopy function takes any sequence of items as its argument  and returns copies of the items in the sequence  in the same order.
　for example  the result of evaluating the enclosed expression in the return clauses of queries q1  q1 and q1 in figure 1 would contain the node with identity rg1  since identities are preserved when the enclosed expression is evaluated. if  however  the return clause contained the constructor expression:
 m-name  createcopy  $m/ red child::name    /m-name 
the result would contain a new node  with a different identity.
　to associate a color with the result of a constructor expression  mcxquery provides a function named createcolor. this function takes two arguments: a color literal as its first argument  and any sequence of items as its second argument. it adds the specified color to the set of colors associated with each node in its second argument.
　finally  we address an interesting issue that arises if node identities are retained when evaluating enclosed expressions in a constructed expression  especially when this result is colored. since a node can be present at most once in any colored tree  the result of any constructed expression should not have a node  with a given identity  occur at more than one position in the colored tree. such a situation can arise  as the following constructed expression illustrates:
createcolor black   dupl-problem 
 m1  $m/ red child::name  /m1 
 m1  $m/ red child::name  /m1 
 /dupl-problem  
　in this case  the expression raises a dynamic error. note that such a situation doesn't arise if the createcopy function is appropriately used.
1:forwardstep::= color forwardaxis nodetest  color abbreviatedforwardstep 1:reversestep::= color reverseaxis nodetest  color abbreviatedreversestep 1:color::=     literal     figure 1: productions for mcxquery path expressions
figure 1: result of evaluating q1
1 xquery expressions
　we present an example depicting how an mcxquery expression can be used to add a new colored tree  consisting of new nodes and previously existing nodes  to an mct database. consider query q1 from figure 1. the mcxquery expression is shown in figure 1. the result of evaluating this expression against the mct database of figure 1 is shown in figure 1. notice that movie nodes now have three colors: red  because of their participation in the movie-genre hierarchy   green  because of their participation in the movie-award hierarchy   and black. all other nodes  including the newly created votes nodes in the result  are only black. note that the result is a tree since each movie in the green movie-award hierarchy has only one child element named votes.
　there is as yet no standard for specifying updates to xml data. in   the authors propose an extension to xquery  using for  let  where and update clauses  to perform updates to xml documents. it is easy to see that the mcxquery extensions to xquery path expressions and constructor expressions  described previously  can be used in a straightforward manner in conjunction with the update extensions of   to unambiguously update an mct database. each of the update operations can be performed on existing colored trees  once the tuple of bindings is returned. note that update operations implicitly add existing colors to new nodes  or to existing nodes. creating new colored trees is done via extensions to the constructor expressions in mcxquery.
1. serialization of mct databases
　while the mct logical data model is the basis for the query and update languages  and the mct physical data model  discussed in section 1  is the basis for storage of the data values  these are not appropriate for exchanging information in a flexible manner  which is crucial in today's networked world. what is needed is an exchange data model  which deals with the serialization of data values for exchange between applications.
　regular xml is the de facto standard for data exchange. so we need to develop a  serialized  xml representation of an mct database  such that the original mct database can be reconstructed efficiently from the serialized representation at the receiver's end.
in addition  we would like this serialization to be compact.
figure 1: example mct schema
1 real and primary colors
　consider our running example database of figure 1. for illustration  suppose movie elements additionally have category subelements in the green hierarchy  movie-rolecan have payment subelement in the blue hierarchy and description and scene subelements in the red hierarchy. the corresponding schema is illustrated in figure 1. for each element node type  call the colors  hierarchies  in which it appears in the mct database its real colors. call the hierarchy  color  in which an element is represented in a serialization  its primary color w.r.t. the serialization. so  movie elements have red and green as real colors and these are their only possible primary color choices. not every movie element need be both red and green in an instance but ignore this for now: we will revisit this point. the name subelement of movie has the same primary color choices  although its choice is determined by that of its parent movie element. the movie-role element can have blue or red as its primary color  since it is present in those hierarchies. but  surprisingly green is also a primary color choice for movie-role  even though it is not its real color. this is because when a movie element's primary color is chosen to be green  we have the option of using the same color as the primary color for all its subelements in any colored hierarchy  regardless of their real colors. in our example  some of the options for primary color choices are:  i  blue for movie-role  movie-role/name  payment  description  and scene  red for movie  movie/name  votes  and category;  ii  red for movie and all its descendants1;  iii  blue for movie-role and all its descendants in any color  and green for movie and its immediate subelements in any color  except movie-role; and  iv  green for movie and all its descendants in any color.
1 cost-based serialization
　to serialize using option  i   we need to associate a movieid attribute with each  red  movie node and a movieidref attribute with each  blue  movie-role node. similarly  other parent pointers have to be set up  as suitable idrefs. in addition to setting up such parent pointers  we need to associate a color attribute with certain elements in the serialization. the color attribute

type is a set of strings of the form    where is a string representing a color and  is one of   and is optional. if the color attribute of an element contains the value  blue    it means as well as its entire subtree in the serial representation have color blue  in addition to others . similarly   blue   says the relevant subtree is not blue  whereas  blue  only affects 's color. these color denotations can override: e.g.   blue  at a descendant of whose color includes  blue   overrides the latter and says the descendant has color blue. in finding a serialization of minimal expected cost  we have to account for the cost of such encoding of color information in addition to parent pointer setup. one additional piece of information that is relevant for deciding the cost of a particular primary color choice for an element is the average number of its children of each element type. for example  each movie-role may have only one name and description but  say  1 scenes on an average. we assume statistical summary information of this kind is available. let   for element type and color   represent the cost of choosing as the primary color for . for our running example  movie can be calculated as:
name
votes
category
movie-role	movie-role movie-role
　the 's represent the average number of each type of subelement for a movie element. the     accounts for the inclusion of color =  red   for non-red subelements. the last     accounts for setting up the parent pointer  as an id/idref  for a movie element in the green hierarchy. in general  for each element type  the minimal cost  among possible primary color choices for each element  as well as the best color choice itself can be determined using a dynamic programming approach.
1 optimal serialization
　in this paper  we consider only serializations where one of the colors present in the original mct database is chosen as the primary color for any element. furthermore  we assume for simplicity that elements that are multi-colored are not involved in any cycles in the schema  and that for each multi-colored element type  there is only one  production  in its schema grammar. even then  determining the optimal serialization is non-trivial. the optimal serialization algorithm is given in figure 1. the algorithm uses a helper function that for an element type and color
  returns the average number of children of type	for an element corresponding to	's parent type in the hierarchy with color
     . for example  movie-role means on an average  a movie has 1 movie-roles. the serialization scheme itself can be obtained by running the algorithm and then associating with each element of a given type  the best primary color choice found by the algorithm  and then following the ideas described earlier regarding setting up of parent pointers and color attribute values for various nodes.
　finally  recall so far we have assumed whenever an element type has multiple colors  all its instances will appear in each of its colored hierarchies. this is not always true; e.g.  some movie elements may not appear in the green hierarchy since they were not nominated for an oscar. our algorithm can be easily extended to this case by noting:  i  the calculations and book-keeping used to determine the best primary color choice  for an element type  can be used to maintain a ranked set of color choices from best to the worst  and  ii  whenever an actual element of a given type does not appear in the current primary color choice for that type  use
algorithm
input: an mct schema  together with stats output: optimal serialization scheme for  each color   identify  proceeding top-down  the multi-colored element types; for  each such element type  
find	 	; pick the	with the least cost;
end algorithm
function	;
input: element type and color   one of its legal primary color choices;
output: cost of choosing	as 's primary color; if  	 
if   is a leaf 
	if  	 	;
else if   is a child of a node whose color includes	 
;
	else	;
	return	;
;
//parent pointer setup cost for other colors; for  each color  
	let	 be 's production in color  
where '''' is 1     +  or *; for  each  
let	; find the primary color choice	with min.
cost for   subject to the constraint that
	's choice is	;
;
return cost; end function
function	;
input: given 's parent has as primary color choice  find best primary color choice for ;
set	to that color	that
minimizes the cost	;figure 1: algorithm optserialize
the next best choice for that element and proceed iteratively for its subelements. we omit details. we can show:
　theorem 1  optimality of serialization . let be an mct schema together with summary information for each color  of the average number of child elements of each type for each multicolored parent element type. then the serialization scheme found by algorithm optserialize is optimal w.r.t. . 
1. implementation
　there are many physical data models currently being investigated for storing xml data  including relational and native approaches. first  we briefly discuss how these could be enhanced for the physical representation and manipulation of an mct database. next  we present greater detail with regard to the specifics of a physical structure we have implemented.
1 physical model
　one popular technique for the physical representation of xml data is to map the data to an existing  relational  database system. several mapping techniques have been proposed  see  e.g.   1  1  1  1   to map tree-based xml data to flat tables in a relational schema. due to the heterogeneity of xml data  a simple xml schema often produces a relational schema with many tables. structural information in the tree-based xml schema is modeled by joins between tables in the relational schema. two main strategies have been proposed for this purpose. first  one could use primary-key foreign-key joins in relational databases to model the parent-child relationships in the xml tree. second  one could use a  start  end  parent-start  interval encoding or a dewey-style encoding of each node in an xml tree  as the node's key  represented in one or more attributes of the relation  to more directly determine relationships like ancestor-descendant and preceding-following between nodes in the xml tree.
　since an mct database consists of multiple colored trees  each of which is akin to an xml tree  relational approaches for the physical representation of xml are easily extended to handle mct databases. essentially  an mct node content can be fragmented into relations as with xml data. the structural participation of a node in multiple colored trees can be represented using foreignkeys   start  end  parent-start interval encodings  or dewey-style encodings  for each colored hierarchy  separately.
　there are also several native xml databases  where the physical representation and manipulation of xml data is independent of relational databases  see  e.g.   1  1  1  . such native xml database systems store xml data directly  retaining its natural tree structure  but often take recourse to the previously mentioned encodings for node identification  especially for indexing purposes. two choices suggest themselves for the native physical representation of mct databases. first  one can rely on mapping mct databases to xml  as discussed in section 1   and then store this using the native xml systems. alternatively  one could use the native xml system for separately storing each colored tree. where one element appears in multiple colored trees  straightforward data structures can be used to link the multiple occurrences of this element  once in each tree  and to minimize the amount of data replicated across these multiple occurrences.
1 our implementation
　we modified the timber  database system to implement the mct data model. in this system  element content and attributes are stored separately from the element structural relationships. thus  each  traditional  xml element is represented as one structural  node   a separate content node  if the element has content  and an attribute node  if the element has attributes. sub-elements have a similar representation of their own  and are merely linked to their parent through the structural node.
　for a multi-colored element  the content and attribute nodes remain the same as before. however  we create one structural relationships node for each color hierarchy that the element participates in. since the structural relationships for any one color are no different than in the single color case  no modification is required to the representation of the structural relationship node  or to the manner in which nodes are indexed.
　with the design just described  we have an effective representation of multi-colored elements  but with one critical shortcoming - there is no way to determine the multiple colors of a given node. given a particular structural node  we can obtain its attribute and content parts. but the xml database system we had did not provide a means to navigate in the opposite direction. we addressed this by introducing additional  attributes  for multi-colored nodes that provide links back to each of the corresponding single-colored structural nodes. the physical structures corresponding to a portion of the logical data of figure 1 are depicted in figure 1.
　each mc-query is decomposed into components that have a single color. each single color query evaluation proceeds in the normal manner. a color transition is accomplished by a cross-tree join access method  which simply follows the links described above to

figure 1: physical model
obtain the structural node of each element for the color being transitioned to. this bulk access method is implemented in a straightforward fashion as an attribute-value based join. since color transitions are not free  alternative plans are often worth considering. for example  we could choose to evaluate multiple single-color queries first  and perform cross-tree joins at the end  minimizing the cost of the cross-tree join. alternatively  it may be preferable to perform a single-color query  then a cross-tree join  before evaluating the next single-color query  to benefit from a selection that greatly reduces the size of the latter computation. such choices must be evaluated by a query optimizer in choosing a good plan. while we do not anticipate any significant new challenges on account of having one more type of join operator  the query optimizer design is beyond the scope of this paper. for all the experimentation described next  we manually specified the query plan  always choosing the one expected to be the best.
1. experimental evaluation
　whereas the primary motivation for the multi-colored model is ease of data modeling  it is frequently the case that better data models lead not just to simpler query specification but also to superior performance. to test whether this is the case for mct  we performed an extensive experimental analysis  using the implementation described above. all experiments were performed on a single processor pentium iiim 1mhz equipped with 1 mbytes of memory  1gbytes of disk storage and windows 1 operating system. the buffer pool size was set to 1mbytes and data page size configured to 1kbtyes.
　we used two popular data sets drawn from very different domains: tpc-wand sigmod-record. the tpc-wbenchmark  has been converted to xml format by xbench  using toxgene . the workload simulates an internet commerce-oriented transactional web server. we cannot directly use the xbench conversion of tpc-w because it is not multi-colored. instead  we used the same tool  toxgene  to generate tpc-w data in a multi-colored schema of our design. as a baseline  we also generated the same data in a shallow tree schema and in a deep tree schema. the shallow tree schema is a minor enhancement of the schema used by xbench. the deep tree schema places customer at the top level of the hierarchy  then order  address  country item  and finally author. the mct schema is comprised of 1 single-colored hierarchies:
customer--order--orderline 
mctshallowdeeptpc-wnum. elements1 1 11 1num. attrs111content nodes1 1 11 1data mbytes111index mbytes11sigmodnum. elements111recordnum. attrs111content nodes111data mbytes111index mbytes111table 1: storage requirement
billing address--order--orderline  shipping address--order--orderline  date--order--orderline  and author--item--orderline.
　sigmod-record is firstscaled up by a factor of 1  from 1kb to 1mb   and then dealt with in the same manner. its mct schema is comprised of 1 colored hierarchies:
date--issue--articles  and editor--topic--articles.
　the shallow tree schema has 1 trees: articles date--issue  and editor--topic. the deep tree schema is a minor enhancement of the original schema.
　each experiment was run five times. the lowest and highest readings were ignored and the other three were averaged. for our experiments  we constructed an index on element tag name and attribute id. we also constructed indices on element content and attribute value  where needed.
1 storage requirements
　first  we compare storage requirements of the three approaches. table 1 shows the numbers. as expected  the deep tree approach has many more elements and requires considerably greater storage due to its replication of data. the mct approach has exactly the same number of elements as shallow  but requires storage that is greater than shallow but less then deep. the reason for this is that each multi-colored element is physically stored as multiple structural nodes  see figure 1   one for each color  with an attendant overhead for this storage.
　looking at the sizes of indices created  we find similar trends. since it is the structural nodes that are most interesting to index  the size of index in the case of mct is comparable to deep and much larger than for shallow.
1 query processing time
　table 1 shows the execution time in seconds of 1 queries from the tpc-w xbench workload and 1 queries from the sigmodrecord workload. in addition  it also shows times for a few update statements that we defined.1
　we ran these experiments for a range of buffer pool sizes  and found no significant differences in the trends for the results obtained. as such  we report results for only on a buffer size of 1

queryresultsmctshallowdeepcolorstreestq11111tq11111tq11111tq11111tq11111tq11111tq11111tq1d111tq11111tq11111tq11111tq11111tq11111tq1d111tq11111tq11111tq11111tq11111tu1111tu1d11tu1111tu1d11tu11111tu1111tu1d11sq11111sq11111sq11111sq11111sq1d11sq11111su1111su1d11su1111su1d11table 1: query processing time in seconds. the first letter of the query label indicates the data set used: t=tpc-w  s=sigmod-record. the second letter indicates query type: q=read-only  u=update. the results column indicates the number of results produced for a read-only query  and the number of elements updated for an update query.
megabytes. we also ran experiments for a range of data-set sizes and found that most of the times scaled linearly with data set size. the only exceptions were the two queries involving an inequality value join  which is implemented as nested loops  and hence has a quadratic dependence on data set size. once more  in the interests of space  we report numbers only for the full size data set.
　we repeated our experiments under both cold cache conditions  by flushing all buffers completely before each query evaluation  and warm cache conditions  where a first time execution of the query is allowed to populate the buffer for subsequent warm cache executions . the trends were similar in both cases. we choose to report numbers here for the warm cache case since the differences stand out more - in the cold cache case  even a query plan that is very good about managing memory pays at least some penalty for getting data into the buffer  and this penalty is more closely related to the size of data stored than to the locality/quality of the query plan.
　overall  one can immediately see that mct in all cases is either comparable to shallow or substantially faster. however  deep seems to have a large variance - performing much better some times  and much worse at others.
　additional annotations in table 1 help to clarify the picture. for each query we have indicated the number of different trees involved  indicating the number of value joins that were required by shallow  and the number of colors involved  indicating the number of color transitions required by mct. we observe that structural joins are substantially cheaper to evaluate than value joins  with color crossings having a cost only slightly less than that of a value join in our implementation.  a more sophisticated implementation could bring down the cost of a color crossing substantially - but that is only speculation on our part at this time.  no value joins are required for the mct and deep representations. obviously  the concept of color crossings only applies to mct. the relative cost of a query is immediately determined by the number of value joins or color crossings. when there are not any  shallow and mct have comparable performance  and are never beaten by deep. when there are value joins or color crossings  performance suffers. mct beats shallow precisely in the cases where it does not need a color crossing  because it was able to fold the hierarchy relevant to the query into a single color  whereas shallow had to join trees. since mct has multiple colors available to it  it is indeed possible to have multiple hierarchies that could each be the one most appropriate for a query  and choose one of them a priori as part of database design.
　furthermore  with value-joins  the total running time of the query is very sensitive to the sizes of inputs to the join. consider tq1 and tq1  which are similar  except that the former computes a larger join  input sizes to the join are 1 and 1  than the latter  with input sizes 1 and 1 . the final result cardinality of the former is also correspondingly higher. the running time of the shallow tree query is dominated by the value join  and grows linearly with the size of the join. in contrast  the running times of deep and mct change very little between these two queries.
　the queries where deep does poorly all involve duplicate results.  the other queries happened to have no duplicates  due to the schema specifications.  deep not only has the cost of retrieving more  duplicate  results  but it also has to perform costly duplicate elimination afterwards. to tease these two factors apart  for each of these queries  we report two versions for deep  with and without duplicate elimination.  queries run without duplicate elimination are marked with a  d  at the end in table 1.  the conclusion is that any one of these factors is enough to render deep uncompetitive - the two together just compound the difficulty.
　tq1 is particularly interesting since it both requires value joins in shallow and also generates duplicate intermediate results in deep. in consequence  mct is able to perform better than both shallow as well as deep. note that tq1 includes grouping with duplicate elimination as part of the query specification: since the duplicates are in intermediate results rather than in the final results  we are not able to define and run a separate tq1d query to measure the performance of deep without duplicate elimination.
　the update queries showed trends similar to read-only queries. where the update specification was simple  and there were no duplicates  all three schemes performed comparably. once duplicates are involved  the performance of deep suffers because of having to update multiple copies. when the update specification is complex enough to require a value join to identify the nodes to be updated  shallow takes a performance hit.
1 query simplicity
　we have looked at performance metrics above  including costs for storage  for queries  and for updates. but for a data model  perhaps a more important metric is query simplicity. a central goal of a good data model should be to make it easy to express complex queries. while simplicity itself is hard to quantify  we have identified several metrics that are likely to be correlated - the number of path expressions and the number of variable bindings. for each

figure 1: query specification complexity: number of path expressions

figure 1: query specification complexity: number of variable bindings
of the tpc-w queries we studied above  we present these metrics in figure 1 and figure 1; queries that result in identical numbers for all three strategies are not reported. our conclusion is that mct and deep are comparable  with the equivalent shallow tree query being quite a bit more complex. the reason is that structural traversals are succinctly expressed in xpath  and xquery  whereas value-based joins  as required by shallow  require the definition of multiple variables and the introduction of a predicate in the where clause stating the join condition.
1. related work
　graph-based models have been investigated for data modeling in depth  initially in a general context  e.g.  see graphlog   hy+    and more recently  for semi-structured data  e.g.  see struql   unql   lorel  . indeed  there have been recent proposals to even extend the already expressive and powerful semistructured data models  e.g.  see  1  1  . our work is distinct from all of these in that on a per-color basis  our model is treebased  with all the simplicity and performance benefits trees have to offer. besides  our extension is specifically set in the context of xml. indeed  we have discussed at length how the basic xml model and query language syntax  xquery  can be extended to take advantage of multiple colored hierarchies.
　data warehouses typically provide support for multiple hierarchies  one  or more  for each dimension  see  e.g.   1  1  1  . a data warehouse schema consists of one or more fact tables and a number of dimension tables. the latter model hierarchical relationship among members of a dimension: e.g.  coke and pepsi are children of soda  while soda and juice may be children of softdrinks. a tuple in a fact table can be thought of having a presence in each dimension for which it has values. however  to our knowledge  none of the works in data warehousing/olap leverage this perspective in any formal way.
　finally  pedersen et al.  are investigating the integration of olap technology with xml data. however  their main concerns are modeling cost and query optimization in the context of providing olap-style functionality for heterogeneous xml data. given the applicability of the mct data model for xml data warehousing and olap  their work neatly complements ours.
1. conclusions
　we have developed a multi-colored tree model  which eases the restriction of developing a single hierarchy over data to be represented in xml. we described how this logical data model could be specified using only evolutionary extensions to the xml data model and to xquery. given the importance of exchanging data  we presented an algorithm to obtain a size-optimal serialization of data represented in our model  rendering it in pure xml. we also discussed the changes necessary to xml databases to be able to support multi-colored trees  and describe an implementation on top of the timber native xml database. finally  an experimental evaluation  using our implementation  demonstrates the many advantages of mct over shallow and deep xml trees.
　the multi-colored tree model proposed in this paper has three major benefits:
ease of schema design: the hard choices required for a deep tree design  i.e.  which element to put below which  are made easier by permitting multiple hierarchies to co-exist over the same data. an added benefit is that  like shallow  mct can avoid update anomalies.
ease of query specification: xquery  and xpath  make it much easier to specify hierarchical structural navigation than value-based or id-idref joins. multi-colored trees help avoid the latter and use the former instead.
efficiency in query processing: structural  containment  joins are much cheaper to compute than value-based  or pointer  joins. this makes it much cheaper to evaluate mct queries compared with equivalent single-color queries that require value-based or id-idref joins. another way of thinking about this is that more  pre-computed  structural paths are available  as opposed to ad hoc join paths .
