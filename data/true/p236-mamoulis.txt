in many applications that track and analyze spatiotemporal data  movements obey periodic patterns; the objects follow the same routes  approximately  over regular time intervals. for example  people wake up at the same time and follow more or less the same route to their work everyday. the discovery of hidden periodic patterns in spatiotemporal data  apart from unveiling important information to the data analyst  can facilitate data management substantially. based on this observation  we propose a framework that analyzes  manages  and queries object movements that follow such patterns. we define the spatiotemporal periodic pattern mining problem and propose an effective and fast mining algorithm for retrieving maximal periodic patterns. we also devise a novel  specialized index structure that can benefit from the discovered patterns to support more efficient execution of spatiotemporal queries. we evaluate our methods experimentally using datasets with object trajectories that exhibit periodicity.
general terms: algorithms
categories & subject descriptors: h.1  database management : database applications - data mining keywords: spatiotemporal data  trajectories  pattern mining  indexing
1. introduction
　the efficient management of spatiotemporal data has gained much interest during the past few years  1  1  1  1   mainly due to the rapid advancements in telecommunications  e.g.  gps  cellular networks  etc.   which facilitate the collection of large datasets of such information. management and analysis of moving object trajectories is challenging due to the vast amount of collected data and novel types of spatiotemporal queries.

 this work was supported by grant hku 1e from hong kong rgc and partially supported by nsf grants iis1 and career award iis-1.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
kdd'1  august 1  1  seattle  washington  usa.
copyright 1 acm 1-1/1 ...$1.
　in many applications  the movements obey periodic patterns; i.e.  the objects follow the same routes  approximately  over regular time intervals. objects that follow approximate periodic patterns include transportation vehicles  buses  boats  airplanes  trains  etc.   animal movements  mobile phone users  etc. for example  bob wakes up at the same time and then follows  more or less  the same route to his work everyday. based on this observation  which has been overlooked in past research  we propose a framework for mining  indexing and querying periodic spatiotemporal data.
　the problem of discovering periodic patterns from historical object movements is very challenging. usually  the patterns are not explicitly specified  but have to be mined from the data. the patterns can be thought of as  possibly noncontiguous  sequences of object locations that reappear in the movement history periodically. moreover  since we do not expect an object to visit exactly the same locations at every time instant of each period  the patterns are not rigid but differ slightly from one occurrence to the next. the pattern occurrences may also be shifted in time  e.g.  due to traffic delays or bob waking up late again . the approximate nature of patterns in the spatiotemporal domain increases the complexity of mining tasks. we need to discover  along with the patterns  a flexible description of how they variate in space and time. previous approaches have studied the extraction of patterns from long event sequences  1  1 . we identify the difference between the two problems and propose novel techniques for mining periodic patterns from a large historical collection of object movements.
　in addition  we design a novel indexing scheme that exploits periodic pattern information to organize historical spatiotemporal data  such that spatiotemporal queries are efficiently processed. since the patterns are accurate approximations of object trajectories  they can be managed in a lightweight index structure  which can be used for pruning large parts of the search space without having to access the actual data from storage. this index is optimized for providing fast answers to range queries with temporal predicates. effective indexing is not the only application of the mined patterns; since they are compact summaries of the actual trajectories  we can use them to compress and replace historical data to save space. finally  periodic patterns can predict future movements of objects that follow them.
　the rest of the paper is organized as follows. section 1 presents related work. in section 1  we give a concrete formulation of periodic patterns in object trajectories and propose effective mining techniques. section 1 presents the indexing scheme that exploits spatiotemporal patterns. we present a concise experimental evaluation of our techniques in section 1. finally  section 1 concludes with a discussion about future work.
1. related work
　our work is related to two research problems. the first is data mining in spatiotemporal and time-series databases. the second is management of spatiotemporal data. previous work on spatiotemporal data mining focuses on two types of patterns:  i  frequent movements of objects over time and  ii  evolution of natural phenomena  such as forest coverage.  studies the discovery of frequent patterns related to changes of natural phenomena  e.g.  temperature changes  in spatial regions. in general  there is limited work on spatiotemporal data mining  which has been treated as a generalization of pattern mining in time-series data  e.g.  see  1  1  . the locations of objects or the changes of natural phenomena over time are mapped to sequences of values. for instance  we can divide the map into spatial regions and replace the location of the object at each timestamp  by the region-id where it is located. similarly  we can model the change of temperature in a spatial region as a sequence of temperature values. continuous domains of the resulting time-series data are discretized  prior to mining. in the case of multiple moving objects  or time-series   trajectories are typically concatenated to a single long sequence. then  an algorithm that discovers frequent subsequences in a long sequence  e.g.    is applied.
　periodicity has only been studied in the context of timeseries databases.  addresses the following problem. given a long sequence s and a period t  the aim is to discover the most representative trend that repeats itself in s every t timestamps. exact search might be slow; thus   proposes an approximate search technique based on sketches. however  the discovered trend for a given t is only one and spans the whole periodic interval. in   the problem of finding association rules that repeat themselves in every period of a data sequence is addressed. the discovery of multiple partial periodical patterns that do not appear in every periodic segment was first studied in . a version of the well-known apriori algorithm  was adapted for the problem of finding patterns of the form *ab**c  where a  b  and c are specific symbols  e.g.  event types  and * could be any symbol  t = 1  in this example . this pattern may not repeat itself in every period  but it must appear at least min sup times  where min sup is a user-defined parameter. in   a faster mining method for this problem was also proposed  which uses a tree structure to count the support of multiple patterns at two database scans.  studies the problem of finding sets of events that appear together periodically. in each qualifying period  the set of events may not appear in exactly the same positions  but their occurrence may be shifted or disrupted  due to the presence of noise. however  this work does not consider the order of events in such patterns. on the other hand  it addresses the problem of mining patterns and their periods automatically. finally   studies the problem of finding patterns  which appear in at least a minimum number of consecutive periodic intervals and groups of such intervals are allowed to be separated by at most a time interval threshold.
　a number of spatial access methods  which are variants of the r-tree  have developed for the management of moving object trajectories.  proposes 1d variants of this access method  suitable for indexing historical spatiotemporal data. time is modeled as a third dimension and each moving object trajectory is mapped to a polyline in this 1d space. the polyline is then decomposed into a sequence of 1d line segments  tagged with the object-id they correspond to. the segments  in turn  are indexed by variants of the 1d r-tree  which differ in the criteria they use to split their nodes. although this generic method is always applicable  it stores redundant information if the positions of the objects do not constantly change. other works  1  1  propose multi-version variants of the r-tree  which share similar concepts to access methods for time-evolving data . recently   there is an increasing interest in  approximate  aggregate queries on spatiotemporal data  e.g.   find the distinct number of objects that were in region r during a specific time interval .
1. periodic patterns in object trajectories
　in our model  we assume that the locations of objects are sampled over a long history. in other words  the movement of an object is tracked as an n-length sequence s of spatial locations  one for each timestamp in the history  of the form { l1 t1    l1 t1   ...   ln 1 tn 1 }  where li is the object's location at time ti. if the difference between consecutive timestamps is fixed  locations are sampled every regular time interval   we can represent the movement by a simple sequence of locations li  i.e.  by dropping the timestamps ti  since they can be implied . each location li is expressed in terms of spatial coordinates. figure 1a  for example  illustrates the movement of an object in three consecutive days  assuming that it is tracked only during specific hours  e.g.  working hours . we can model it with sequence 
. given such a sequence  a
minimum support min sup  and an integer t  called period  our problem is to discover movement patterns that repeat themselves every t timestamps. a discovered pattern p is a t-length sequence of the form r1 ...rt 1  where ri is a spatial region or the special character *  indicating the whole spatial universe. for instance  pattern ab*c** implies that at the beginning of the cycle the object is in region a  at the next timestamp it is found in region b  then it moves irregularly  it can be anywhere   then it goes to region c  and after that it can go anywhere  until the beginning of the next cycle  when it can be found again in region a. the patterns are required to be followed by the object in at least min sup periodic intervals in s.
　existing algorithms for mining periodic patterns  e.g.    operate on event sequences and discover patterns of the above form. however  in this case  the elements ri of a pattern are events  or sets of events . as a result  we cannot directly apply these techniques for our problem  unless we treat the exact locations li as discrete categorical values. nevertheless it is highly unlikely that an object will repeat an identical sequence of locations precisely. even if the spatial route is precise  the location transmissions at each timestamp are unlikely to be perfectly synchronized. thus  the object will not reach the same location at the same time every day  and as a result the sampled locations at specific timestamps  e.g.  at 1 a.m. sharp  every day   will be different. in figure 1a  for example  the first daily locations of the object are very close to each other  however  they will be treated differently by a straightforward mining algorithm.
	1x	1	xsupport aa*c*g  = 1 a  an object's movement b  a set of predefined regions c  event-based patternsfigure 1: periodic patterns in with respect to pre-defined spatial regions　one way to handle the noise in object movement is to replace the exact locations of the objects by the regions  e.g.  districts  mobile communication cells  or cells of a synthetic grid  which contain them. figure 1b shows an example of an area's division into such regions. sequence {a  a  c  c  c  g  a ...} can now summarize the object's movement and periodic sequence pattern mining algorithms  like   can directly be applied. figure 1c shows three  closed  discovered patterns for t=1  and min sup = 1. a disadvantage of this approach is that the discovered patterns may not be very descriptive  if the space division is not very detailed. for example  regions a and c are too large to capture in detail the first three positions of the object in each periodic instance. on the other hand  with detailed space divisions  the same  approximate  object location may span more than one different regions. for example  in figure 1b  observe that the third object positions for the three days are close to each other  however  they fall into different regions  a and c  at different days. therefore  we are interested in the automated discovering of patterns and their descriptive regions. before we present methods for this problem  we will first define it formally.
1 problem definition
　let s be a sequence of n spatial locations {l1 l1 ... ln 1}  representing the movement of an object over a long history. let  be an integer called period  e.g.  day  week  month . a periodic segment s is defined by a subsequence lili+1 ...li+t 1 of s  such that i modulo t = 1. thus  segments start at positions 1 ，t  and there are exactly periodic segments in s.  let sj denote the segment starting at positionj lj，t of s  for 1 ＋ j   m  and let si = lj，t+i  for 1 ＋ i   t. a periodic pattern p is defined by a sequence r1 ...rt 1 of length t  such that ri is either a spatial region or *. the length of a periodic pattern p is the number of non-* regions in p. a segment sj is said to comply with p  if for each ri （ p  ri = * or sji is inside region ri. the support |p| of a pattern p in s is defined by the number of periodic segments in s that comply with p. we sometimes use the same symbol p to refer to a pattern and the set of segments that comply with it. let min sup ＋ m be a positive integer  minimum support . a pattern p is frequent  if its support is larger than min sup.
  then the last n modulo t loca-
tions are truncated and the length n of sequence s is reduced accordingly.
　a problem with the definition above is that it imposes no control over the density of the pattern regions ri. in other words  if the pattern regions are too relaxed  e.g.  each ri is the whole map   the pattern may always be frequent. therefore  we impose an additional constraint as follows. let
p be the set of segments that comply with a pattern p. then each region ri of p is valid if the set of locations rip := {sji | sj （ sp} form a dense cluster. to define a dense cluster  we borrow the definitions from  and use two parameters  and minpts. a point p in the spatial dataset rip is a core point if the circular range centered at p with radius  contains at least minpts points. if a point q is within distance  from a core point p  it is assigned in the same cluster as p. if q is a core point itself  then all points within distance  from q are assigned in the same cluster as p and q. if rip forms a single  dense cluster with respect to some values of parameters  and minpts  we say that region ri is valid. if all non-* regions of p are valid  then p is a valid pattern. we are interested in the discovery of valid patterns only. in the following  we use the terms valid region and dense cluster interchangeably; i.e.  we will often use the term dense region to refer to a spatial dense cluster and the points in it.
　figure 1a shows an example of a valid pattern  if and minpts = 1. each region at positions 1  1  and 1 forms a single  dense cluster and is therefore a dense region. notice  however  that it is possible that two valid patterns p and p of the same length  i  have the same * positions   ii  every segment that complies with p  complies with p  and  iii 
. in other words  p implies p. for example  the pattern of figure 1a implies the one of figure 1b  denoted by the three circles . a frequent pattern p is redundant if it is implied by some other frequent pattern p. the mining periodic patterns problem searches for all valid periodic patterns p in s  which are frequent and non-redundant with respect to a minimum support min sup. for simplicity  we will use 'frequent pattern' to refer to a valid  non-redundant frequent pattern.
1 mining periodic patterns
　in this section  we present techniques for mining frequent periodic patterns and their associated regions in a long history of object trajectories. we first address the problem of finding frequent 1-patterns  i.e.  of length 1 . then  we propose two methods to find longer patterns; a bottom-up  level-wise technique and a faster top-down approach.

	 a  a valid pattern	 b  a redundant pattern
figure 1: redundancy of patterns
1.1 obtaining frequent 1-patterns
　including automatic discovery of regions in the mining task does not allow for the direct application of techniques that find patterns in sequences  e.g.     as discussed. in order to tackle this problem  we propose the following methodology. we divide the sequence s of locations into t spatial datasets  one for each offset of the period t. in other words  locations {li li+t ... li+ m 1 ，t} go to set ri  for each 1 ＋ i   t. each location is tagged by the id j （  1 ... m 1  of the segment that contains it. figure 1a shows the spatial datasets obtained after decomposing the object trajectory of figure 1a. we use a different symbol to denote locations that correspond to different periodic offsets and different colors for different segment-ids.

1 x	1	x
 a  t-based decomposition	 b  dense clusters in ri's
figure 1: locations and regions per periodic offset
　observe that a dense cluster r in dataset ri corresponds to a frequent pattern  having * at all positions and r at position i. figure 1b shows examples of five clusters discovered in datasets r1  r1  r1  r1  and r1. these correspond to five 1-patterns  i.e.  r1*****  *r1****  etc. . in order to identify the dense clusters for each ri  we can apply a densitybased clustering algorithm like dbscan . clusters with less than min sup points are discarded  since they are not frequent 1-patterns according to our definition.
　clustering is quite expensive and it is a frequently used module of the mining algorithms  as we will see later. dbscan  has quadratic cost to the number of clustered points  unless an index  e.g.  r-tree  is available. since r- trees are not available for every set of arbitrary points to be clustered  we use a hash-based method  that divides the 1d space using a regular grid with cell area 1. this grid is used to hash the points into buckets according to the cell that contains them. the rationale of choosing this cell size is that if one cell contains at least minpts points  we know for sure that it is dense and need not perform any range queries for the objects in it. the remainder of the algorithm merges dense cells that contain points within distance   using inexpensive minimum bounding rectangle tests or spatial join  if required  and applies -range queries from objects located in sparse cells to assign them to clusters and potentially merge clusters. our clustering technique is fast because not only does it avoid r-tree construction  but it also minimizes expensive distance computations. the details of this algorithm are omitted for the sake of readability.
1.1 a level-wise  bottom-up approach
　starting from the discovered 1-patterns  i.e.  clusters for each ri   we can apply a variant of the level-wise aprioritid algorithm  to discover longer ones  as shown in figure 1. the input of our algorithm is a collection l1 of frequent 1patterns  discovered as described in the previous paragraph; for each ri  1 ＋ i   t  and each dense region r （ ri  there is a 1-pattern in l1. pairs  of  k   1 -patterns in
lk 1  with their first k 1 non-* regions in the same position and different  k   1 -th non-* position create candidate kpatterns  lines 1 . for each candidate pattern pcand  we then perform a segment-id join between p1 and p1 and if the number of segments that comply with both patterns is at least min sup  we run a pattern validation function to check whether the regions of pcand are still clusters. after the patterns of length k have been discovered  we find the patterns at the next level  until there are no more patterns at the current level  or there are no more levels.
algorithm stpmine1 l1  t  minsup ;
1 . k:=1;
1 . while
1 .	k:= ;
1 .1 .	for each pair of patterns  p1 pagree on the first1 p1  （ lk 1
	such that p1 and	
1 .1 .	pcandand have different  k  p1 -  pth non1 ;	-
:=candidate gen 
1 .	if  then
1 .	pcand:=p1  p1.sid=p1.sid p1; //segment-id join

1 .	if |pvalidatecand| − minpatternsup pthencand  lk  minsup ;
+ 1;
1 . return p:=slk  1 ＋ k   t;
figure 1: level-wise pattern mining
　in order to facilitate fast and effective candidate generation  we use the mbrs  i.e.  minimum bounding rectangles  of the pattern regions. for each common non-* position i the intersection of the mbrs of the regions for p1 and p1 must be non-empty  otherwise a valid superpattern cannot exist. the intersection is adopted as an approximation for the new pattern pcand at each such position i. during candidate pruning  we check for every  k   1 -subpattern of pcand if there is at least one pattern in lk 1  which agrees in the non-* positions with the subpattern and the mbr-intersection with it is non-empty at all those positions. in such a case  we accept pcand as a candidate pattern. otherwise  we know that pcand cannot be a valid pattern  since some of its subpatterns  with common space covered by the non-* regions  are not included in lk 1.
　function validate pattern takes as input a k-length candidate pattern pcand and computes a number of actual klength patterns from it. the rationale is that the points at all non-* positions of pcand may not form a cluster anymore after the join of p1 and p1. thus  for each non-* position of pcand we re-cluster the points. if for some position the points can be grouped to more than one clusters  we create a new candidate pattern for each cluster and validate it. note that  from a candidate pattern pcand  it is possible to generate more than one actual patterns eventually. if no position of pcand is split to multiple clusters  we may need to recluster the non-* positions of pcand  since some points  and segment-ids  may be eliminated during clustering at some position.
to illustrate the algorithm  consider the 1-length patterns
p1 = r1xr1y* and p1 = r1w*r1z of figure 1a. assume that minpts = 1 and 1. the two patterns have common first non-* position and mbr r1x  overlaps mbr r1w . therefore  a candidate 1-length pattern pcand is generated. during candidate pruning  we verify that there is a 1-length pattern with non-* positions 1 and 1 which is in l1. indeed  such a pattern can be spotted at the figure  see the dashed lines . after joining the segment-ids in p1 and p1 at line 1 of stpmine1  pcand contains the trajectories shown in figure 1b. notice that the locations of the segment-ids in the intersection may not form clusters any more at some positions of pcand. this is why we have to call validate pattern  in order to identify the valid patterns included in pcand. observe that  the segment-id corresponding to the lowermost location of the first position is eliminated from the cluster as an outlier. then  while clustering at position 1  we identify two dense clusters  which define the final patterns r1ar1br1c
and r1dr1er1f.

	1 x	1 x
	 a  1-length patterns	 b  generated 1-length patterns
figure 1: example of stpmine1
1.1 a two-phase  top-down algorithm
　although the algorithm of figure 1 can find all partial periodic patterns correctly  it can be very slow due to the huge number of region combinations to be joined. if the actual patterns are long  all their subpatterns have to be computed and validated. in addition  a potentially huge number of candidates need to be checked and evaluated. in this section  we propose a top-down method that can discover long patterns more efficiently.
　after applying clustering on each ri  as described in section 1.1   we have discovered the frequent 1-patterns with their segment-ids. the first phase of stpmine1 algorithm replaces each location in s with the cluster-id it belongs to or with an 'empty' value  e.g.  *  if the location belongs to no cluster. for example  assume that we have discovered clusters {r1 r1} at position 1  {r1} at position 1  and {r1 r1} at position 1. a segment {l1 l1 l1}  such that l1 （ r1  l1 （/ r1  and l1 （ r1 is transformed to subsequence {r1*r1}. therefore  the original spatiotemporal sequence s is transformed to a symbol-sequence s.
　now  we could use the mining algorithm of  to discover fast all frequent patterns of the form r1 ...rt 1  where each ri is a cluster in ri or *. however  we do not know whether the results of the sequence-based algorithm are actual patterns  since the contents of each non-* position may not form a cluster. for example  {r1*r1} may be frequent  however if we consider only the segment-ids that qualify this pattern  r1 may no longer be a cluster or may form different actual clusters  as illustrated in figure 1 . we call the patterns p which can be discovered by the algorithm of  pseudopatterns  since they may not be valid.
　to discover the actual patterns  we apply some changes in the original algorithm of . while creating the maxsubpattern tree  we store with each tree node the segment-ids that correspond to the pseudopattern of the node after the transformation. in this way  one segment-id goes to exactly one node of the tree. however  s could be too large to manage in memory. in order to alleviate this problem  while scanning s  for every segment s we encounter we perform the following operations.
  first  we insert the segment to the max-subpattern tree  as in   increasing the counter of the candidate pseudopattern p that s corresponds to after the transformation. an example of such a tree is shown in figure 1. this node can be found by finding the  first  maximal pseudopattern that is a superpattern of p and following its children  recursively. if the node corresponding to p does not exist  it is created  together with any non-existent ancestors . notice that the dotted lines are not implemented and not followed during insertion  thus  we materialize the tree instead of a lattice . for instance  for segment with   we increase the counter of the corresponding node at the second level of the tree.
  second  we insert an entry  to a file f  where  is the id of the node of the lattice that corresponds to pseudopattern p and s.sid is the id of segment s. at the end  file f is sorted onto bring together segment-ids that comply to the same  maximal  pseudopattern. for each pseudopattern with at least one segment  we insert a pointer to the file position  where the first segment-id is located. nodes of the tree are labeled in breadth-first search order for reasons we will explain shortly.

figure 1: example of max-subpattern tree
　now  instead of finding frequent patterns in a bottom-up fashion  we traverse the tree in a top-down  breadth-first order. for every pseudopattern with at least min sup segmentids  we apply the validate pattern function of figure 1 to recover potential valid patterns. all segment-ids that belong to a discovered pattern are removed from the current pseudopattern. the rationale is that we are interested in patterns that are not spatially contained in some superpattern  so we use only those segment-ids that are not included in a pattern to verify subpatterns of it.
　thus  after scanning the first level of the lattice  we may have discovered some patterns and we may have shrunk segmentid lists of the pseudopatterns. then  we move to the next level of the lattice. the support of a pseudopattern p at each level is the recorded support of p plus the supports of all its superpatterns  recall that a segment-id is assigned to the maximal pattern it complies with . the supports of the superpatterns can be immediately accessed from the lattice. if the total support of the candidate is at least min sup  then the segment-ids have to be loaded for application of validate pattern. the segment-ids of a superpattern may already be in memory from previous level executions. if not  they are loaded from the file f. after validation  only the disqualified segment-ids are kept to be used at lower level patterns. traversal continues until there are no more patterns or it is not possible to find more patterns at lower levels of the lattice.
　the fact that segment-ids are clustered in f according to the breadth-first traversal of the lattice  minimizes random accesses and restricts the number of loaded blocks to memory. the segment-ids for a superpattern remain in memory to be used at lower level validations. if we run out of memory  the segment-ids of the uppermost lattice levels are rewritten to disk  but this time possibly to a smaller file if there were some deletions.
　a pseudo code for stpmine1 is shown in figure 1. initially  the tree and the segment-ids file are created and linked.
then for each level  we find the support of a pseudopattern  at level k by accessing only the supports of its superpatterns at level k + 1  since we are accessing the tree in breadth first order. if  we validate the pattern as in stpmine1 and if some pattern is discovered  we remove from p all those segment-ids that comply with the discovered pattern. thus  the number of segmentids decrease as we go down the levels of the tree  until it is not possible to discover any more patterns  or there are no more levels. notice that the patterns discovered here are only maximal  as opposed to stpmine1  which discovers all frequent patterns. however  we argue that maximal patterns are more useful  compared to the huge set of all patterns. in addition  as we show in the experimental section  stpmine1 is much faster than stpmine1 for data  which contain long patterns.
algorithm stpmine1 l1  t  minand pattern-filesup ;	f; 1 . build max-subpattern tree t
1 .1 . sortfor k = t downto 1and connect it to the nodes of t ;
1 .1 .	for each	k of t
1 .	 then
1 .	;

1 .1 .1 .1 .	validateif premove fromhas changedpatternpthen pthosecand sidsl minin new patterns ofsup ;	p;
if unassigned sids less than minsup then
1 .	return p;
1 . return p;
figure 1: top-down pattern mining
1 mining shifted/distorted patterns
　we have discussed how to deal with non-rigid pattern instances in space  using clustering. however  pattern instances may be also shifted/distorted in time. for example  even though bob follows more or less the same route from his house to his work  some days he may delay  because he wakes up later than usual  or due to traffic. shifted/distorted pattern instances can be counted by our algorithms  as follows. for a single object location at offset position i  instead of generating a single point in the corresponding ri  as before  we generate a point at all neighbor offset positions r i τ  mod t  r i τ+1  mod t  ...  r i+τ  mod t  where τ is a maximum shifting/distortion threshold. consider  for instance  the 1th position of day 1  in figure 1a and assume that τ = 1. instead of generating a single '' point at that location  we generate one '' point  to file r1   one '+' point  to file r1   and one '〜' point  to file r1 . all these points have the same coordinates  but they are considered part of multiple periodic positions. in other words  there is a data replication with a factor 1 ， τ + 1  however  this ensures that shifted patterns will be counted in the supports of the actual positions. in practice  most of the replicated points will be discarded as noise  after the discovery of the 1-patterns  thus the overhead will not increase significantly. obviously  segment-ids that appear multiple times in the same pattern  due to point replication   are counted only once. as a variant of this idea we can weigh the replicated points with a number anti-proportional to their distance from their actual temporal positions  in order to penalize distortion and increase accuracy.
1. indexingusingperiodicpatterns
　the aim of a good spatio-temporal index structure is to manage the trajectories of a set of m moving objects s = {p1 p1 ... pm}  in order to efficiently process spatiotemporal range queries  like  find all objects which were in central district between 1 p.m. and 1 p.m. yesterday . in this section  we present an indexing method that exploits the discovered periodic patterns. first  we present the proposed index structures and then we discuss query processing algorithms that use them.
1 indexing scheme
　for each object p （ s  we first apply the mining techniques to extract their periodic patterns and then organize all of them  for all objects  into a special index structure called period index  pi . only objects that follow periodic patterns are stored in the pi and each pattern is stored only once. in particular  the pi consists of the following two structures;  i  a structure called pattern index that stores  for each object p （ s a concise representation of its periodic pattern s  p and  ii  an index called location index that stores for each object p with some pattern s  in pi  the actual locations of p. furthermore  we use a traditional spatiotemporal index  e.g.  a 1d r-tree   to store the locations of objects that do not follow any periodic movement  outliers . we call this structure the exception index  ei . we expect that ei is small  compared to the database size ; otherwise the dataset is not periodic  in which case our technique degrades to a traditional spatiotemporal indexing method. next  we discuss possible implementations of the pattern and location indexes.
pattern index: consider a periodic pattern p = r1 ...rt 1 for an object p. let us assume for now that there is no * position in p and the patterns for all periodic objects have the same length t  we discuss the more general case later . for each valid region ri （ p  we compute the two dimensional region mbr mi that encloses this region  e.g.  see figure 1 . the area of each mi is expected to be small  depending on the density parameters  and minpts that are used in the clustering phase. an important property of each mi is that it encloses all locations with offset i that belong to segments which comply with p. that is  for each location lj of p at timestamp j  we have lj （ mi  where i = j mod t. of course that is true only if lj belongs to a periodic segment. the pattern index is a two dimensional index  in our case a 1d r-tree   that contains all the region mbrs mi for all periodic objects. in addition  with each mi of an object p  we store the offset i and the object-id p.oid.
location index: in this index  we store the locations of all the periodic objects in the database. one approach is to implement it using a hash table indexed on the object ids. each entry h p.oid  in the hash table contains the period t of the object p and a pointer to the first disk page that contains the locations of p. the locations are organized as an array ordered by the location timestamps and stored in sequential disk pages  e.g.  in the following order: l1 l1 l1 ... ln 1. therefore  to find the location lt of p at a specific timestamp t  we just need to calculate the disk page that contains this entry  which can be done in constant time. the size of the hash table is proportional to the number of objects and for typical applications this table can be easily kept in main memory.
　in general  the patterns discovered by the data mining algorithms may contain * positions. all these locations are considered outliers and they are inserted into ei. therefore  no mbrs for these elements are inserted into pi. in addition  the locations of the segments of periodic objects that do not comply with the periodic pattern are inserted into ei. note that if the location index is implemented using the hash-based approach  the above insertions introduce some replication since they are stored in both indexes. however  the redundancy is expected to be small  especially if the discovered patterns have high support.
1 query processing
　here we discuss how to evaluate spatiotemporal range queries using the period and exception index structures discussed above. given a query region in space qr and time interval qt =  ts te   we are interested in finding the objects that are contained in qr at some point during qt.
　the query processing algorithm first runs the  spatiotemporal  query on the exception index and retrieves the objects that satisfy the query. let a be the set of these objects. the next step  is to run the query on the pattern index using only the spatial extent qr. for each region mbr that intersects the query  we keep the object id and the offset of this mbr. let b be the set of objects that correspond to these mbrs. we compute the set c = b   a  set difference . this set contains all the objects that must be checked using the location index in order to validate if a particular object satisfies the query. indeed  if an object appears in a  it means that it has already been discovered using the exception index  and therefore it does not need to be checked again. using the hash table  for each object p （ c  we compute the disk page that contains the location of p at ts. next  we examine the consecutive locations of this object sequentially  starting from ts until a qualifying location is found or the end of the query time interval te is reached. finally  the answer is the union of a and the objects from c that pass the verification step.
1 other compression/indexing schemes
　in some applications the vast amount of historical spatiotemporal data can render their storage in secondary memory devices impractical. typically  very old data are deleted  or in the best case simply archived in sequential tertiary storage devices  e.g.  tapes   making efficient search impossible. instead of storing the actual object movements  we can compress this information by keeping only the patterns  their occurrences  and the exception movements. more specifically  for each object we keep  i  the periodic patterns   ii  the segment-ids that comply with each pattern  and  iii  the exception movements. this information can be managed using the structures described in the previous section  but now the exact locations corresponding to periodic positions  i.e.  the location index  are discarded. this can greatly reduce the storage requirements. essentially  query evaluation becomes inexact since a set of locations corresponding to a non-* offset position are approximated by their mbr  but the error is small due to the descriptiveness of the patterns.
　another  more aggressive approach is to discard the exceptions  as well. the lightweight pattern index described in section 1 can be used by itself to provide approximate answers to queries referring to the past movements of objects. if for each periodic pattern of an object we also store its validity lifetime  the period index could filter objects not only based on their spatial relationship with the query  but using the temporal dimension as well.
1. experimental evaluation
　we implemented and evaluated the mining and indexing techniques presented in the paper. the language used was c++ and the experiments were performed on a pentium iii 1mhz workstation with 1gb of memory  running unix.
　in order to test the effectiveness and efficiency of the techniques under various conditions  we designed a generator for long object trajectories which exhibit periodicity according to a set of parameter values. these parameters are the length n of the time history  in timestamps   the period t  the length ! of the maximal frequent patterns followed by the object  ! ＋ t   and a probability f for a periodic segment in the object's movement to comply with no hidden patterns  i.e.  the movement during this segment is irregular .
　before generating the movement  the approximate regions for the maximal periodic patterns are determined. let p be a generated pattern. a random circular route is generated in space and for each non-* position i in p  a spatial location lpi  i.e.  point  on that route is determined  such that the distance between two non-* positions on the route is proportional to their temporal distance in the pattern. afterwards  the movement of the object is generated. for every periodic segment s  we initially determine whether s should be a noise  i.e.  irregular  segment or not  given the probability f.
　if s is a regular segment  a random maximal pattern p is selected and the object's movement is generated as follows. if the next segment location to be generated corresponds to
　
a non-* position i of p  the location li is generated randomly and within a distance e from the spatial location lpi of the non-* position. e ranges from 1 to 1% of the map size. otherwise  i.e.  l corresponds to an * position   li is generated randomly  but such that the movement is  targeted  to the next periodic location. in other words   i  li  moves  with respect to the previous segment location li 1 towards the next non-* position j and  ii  its distance from the previous location li 1 is the spatial distance between li 1 and lpj divided by j   i + 1  i.e.  the temporal distance between these two positions. in order to prevent regular movements  both the distance and direction angle are distorted. in specific  we add to the angle  in radians  a random number in   1  and the distance is multiplied by a number between  1 1 . 
　if s is a noise segment  the object can move everywhere in space. the movement is determined by a random direction angle  with respect to the previous location  and a random distance in  1 maxwalk   where maxwalk is used to control the maximum  walking  distance of the object between two timestamps. in order to avoid extreme jumps  after half of the movements in a noise segment  the rest are generated to  target  to the next periodic position  using the method described above.
1 mining effectiveness
　the first experiment demonstrates the effectiveness of the mining techniques proposed in section 1. we generated a small problem  with n = 1  i.e.  there are only 1 locations in the object's trajectory . t is set to 1 and the object follows a single periodic pattern p at 1 out of 1 segments  whereas the movement is irregular in 1 segments. figure 1a shows the objects trajectory  where the periodic movement can roughly be observed. for this dataset ! = 1  i.e.  there are 1 non-* positions in p. figure 1b shows the locations of the object if we consider only the last position in each of the 1 periodic segments. this corresponds to file r1. a cluster  corresponding to a frequent 1-pattern  can easily be spotted on the figure.
　figure 1c shows the maximal frequent pattern p of length 1  successfully discovered by stpmine1 and stpmine1  when min sup = 1. the non-*positions are 1  1  1  1  1  1  1  1  1  and 1. we plot the object's movement  interpolated using only the non-* positions. the discovered pattern is identical to the generated one. the dense regions are successfully detected by the clustering module  and the spatial extents of the pattern are minimal.
　we also developed and tested a technique that applies directly the data mining algorithm for event sequence data . the space is divided using a regular m 〜m grid. then  each location of s is transformed to the cell-id which encloses the location. for instance  if we assume that all locations are in a unit  1 〜 1  space  a location is transformed to a cell with id . then  we use the algorithm of  to find partial patterns that are described by cell-ids. we call this the grid-based mining method.
　figure 1d shows a maximal pattern p discovered by this grid-based technique  when using a 1 〜 1 grid. p has the largest length among all discovered patterns  however it is only 1  whereas the actual pattern p has 1 non-* positions . the non-* positions of p are 1  1  1  and 1  captured by

 these values were tuned to match realistic object movements and at the same time to disallow falsely generated periodic patterns.
	1.1.1.1.1.1.1.1.1.1	1.1.1.1.1.1.1.1.1.1
	 c  p by stpmine  |p| = 1 	 d  a grid-based
figure 1: example of a dataset and discovered patterns  n = 1 minsup = 1 
cells c1  c1  c1  and c1  respectively. most frequent positions are lost because the locations in the respective clusters are split into more than one cells. for instance  the cluster of figure 1b is split between cells c1 and c1. neither of these cells has higher support than min sup for position 1  thus the frequent 1-pattern is missed. other grid size/position settings also produce similar results; the pattern regions are either split and missed or found and overestimated by larger cells. from this small example  we can see the importance of discovering the periodic patterns and their descriptive regions effectively.
1 mining efficiency
　in the next set of experiments  we validate the efficiency of the proposed techniques under various data settings. first  we compare the cost of the  ineffective  grid-based method  stpmine1  and stpmine1 as a function of the length of the maximal hidden pattern. we generated a sequence s of n=1m object locations  and set t = 1 and min sup = 1，n. for this and subsequent experiments we used and minpts = 1 in the clustering module.
　figure 1a plots the results. naturally  the grid-based approach is the fastest method  since it performs no clustering and no refinement of the discovered regions. however  as exemplified in the previous section  it misses the long patterns in all tested cases. moreover  its efficiency is due to the fact that a large fraction of actual 1-patterns are missed and the search space is pruned. stpmine1 is very slow  when the hidden patterns are long. like most bottom-up mining techniques  it suffers from the huge number of candidates that need to be generated and validated  and therefore it is inap-

	 a  cost vs. max-pattern length	 b  cost vs. period length	 c  cost vs. database size
figure 1: mining efficiency under various conditionsplicable for the tested cases where the hidden patterns have more than 1 non-* positions. stpmine1 is very efficient because it uses the first phase to identify fast large patterns that are potentially useful. even when re-clustering fails for the maximal candidate patterns  the actual patterns are discovered usually only after few hops down the max-subpattern tree. observe that  even though stpmine1 performs clustering a large number of times  it is not significantly slower than the ineffective grid-based approach. interestingly  it outperforms the grid-based method when there is a single hidden pattern with length equal to t. in this case  the grid method spans many actual clusters between grid cells and splits the actual pattern to multiple maximal frequent patterns  the support of which is expensive to count in the large lattice.
　in the next experiment  we test the effects of period length on the same database size  but with different values of t. the length of the maximal hidden pattern is 1 ， t in all cases. again  n=1m and min sup = 1，n. figure 1b compares the costs of the grid-based approach and stpmine1; we do not include the cost of stpmine1  since this method is very slow for long patterns. the figure shows that the costs of the two methods are almost invariant to t for a constant database size n. if t is small  then there are few  but large files to be clustered by stpmine1. on the other hand  for large t  there are many but small ri to be clustered. in the final experiment  we test the scalability of stpmine1 to the length n of the spatiotemporal sequence s. figure 1c shows the costs of stpmine1 and the grid-based approach as a function of n  when t = 1 and the maximal pattern length is 1. observe that stpmine1 is scalable  since the database size is only linearly related to the cost of finding and validating the maximal patterns. in summary  stpmine1 is an effective and efficient technique for mining periodic patterns and their accurate descriptive regions in spatiotemporal data.
1 indexing effectiveness
　to test the effectiveness of the period index scheme  we generated synthetic datasets of up to 1 objects. for every object we set n = 1  whereas  unless otherwise specified  1% of the objects follow a single periodic pattern with period t = 1 and length l = 1. the rest of the objects follow random walks. we also generated an assortment of query workloads. every set consists of 1 range queries uniformly distributed in space that cover a fixed area qr equal to 1% of the universe. we varied the temporal predicate qt of the queries from 1 up to 1 time instants.
　we implemented the periodic index  pi  by using a 1d r- tree as the pattern index  and a 1d r-tree as the exception index. we used a main memory hash table with pointers to the stored object data on disk for the location index. for comparison  we also implemented a 1d r-tree that indexes the trajectories without considering the periodic patterns.
　to compare the two approaches we count the average i/o cost per query for all query workloads. first  we ran a scaleup experiment for increasing dataset sizes. in figure 1a we observe that pi scales well  yielding less than a 1-fold increase in average query i/o when doubling the size of the dataset. on the other hand  the 1d r-tree degrades slightly as the size of the database increases. for all cases  pi has at least 1 times fewer i/os than the 1d r-tree.
　figure 1b shows how the index adapts to datasets with increasing number of object segments  1%-1%  that exhibit periodicity. clearly  pi incurs much fewer i/os compared to the 1d r-tree even for datasets that do not contain a very large number of periodic segments. next  we tested how the algorithms adapt to datasets with increasing numbers of periodic objects. we generated datasets where 1% up to 1% of the objects follow periodic patterns  while the rest do random walks. figure 1c plots the average query i/o. from the trend we can see that the fewer the periodic objects  the closer pi tends to the 1d r-tree and vice versa.
　the next experiment tests the efficiency of the indexes with increasing query lengths qt  see figure 1d . it is apparent that pi is not affected at all from the length of the query time interval. on the other hand  the 1d r-tree degrades linearly. for |qt| = 1  pi gives a 1-fold improvement over the 1d r-tree. this is expected  since the period index is a 1-dimensional r-tree that is independent of the time dimension. in contrast  the 1d r-tree needs to access an ever increasing number of nodes on the time dimension as the query becomes larger.
　finally  figure 1e plots the total size of both structures  main memory and disk resident parts for pi  versus the percentage of periodic segments contained in the dataset. furthermore  we plot the size of only the pattern index. as expected pi's size decreases as periodicity increases. the 1d r-tree  of course  is oblivious to the existence of object periodic patterns. the pattern index is orders of magnitude smaller than the total database size  1 mbs vs. 1gbs . it is worth pointing out that the pattern index is a small approximate  lossy  representation of the dataset and can be used by itself to answer approximate queries with some error guarantees based on the support of the object patterns.
　to conclude  pi yields a consistent improvement over the straightforward 1d r-tree  1-fold in the best case . for longer periodicities we expect pi's performance to further improve  since there are more chances for compressing hidden patterns.

 a  cost vs. # of periodic objects	 b  cost vs. pattern support	 c  cost vs. % periodic objects

  d  cost vs. length of qt  e  size vs. % periodic objects figure 1: comparison between period index and 1d r-tree1. conclusions
　in this paper we presented a framework for mining partial periodic patterns from historical spatiotemporal data and use them to build an effective index for object movements. our contributions can be summarized as follows:   we define the important problem of periodic pattern mining in spatiotemporal databases. we identify several important applications of the mined patterns  including data management  data compression  approximate query processing  and probabilistic future movement prediction.
  we propose effective techniques for discovering the periodic patterns and their descriptive spatial regions from a long history of object movements. a top-down technique  stpmine1   in specific  is very efficient  having cost comparable to  ineffective  methods for eventsequence data.
  we propose an indexing scheme that uses the discovered patterns to effectively manage spatiotemporal data. as shown in the experiments  it is much faster compared to a conventional index that does not take periodicity into account.
