support vector machines  svms  have been promising methods for classification and regression analysis because of their solid mathematical foundations which convey several salient properties that other methods hardly provide. however  despite the prominent properties of svms  they are not as favored for large-scale data mining as for pattern recognition or machine learning because the training complexity of svms is highly dependent on the size of a data set. many real-world data mining applications involve millions or billions of data records where even multiple scans of the entire data are too expensive to perform. this paper presents a new method  clustering-based svm  cb-svm   which is specifically designed for handling very large data sets. cb-svm applies a hierarchical micro-clustering algorithm that scans the entire data set only once to provide an svm with high quality samples that carry the statistical summaries of the data such that the summaries maximize the benefit of learning the svm. cb-svm tries to generate the best svm boundary for very large data sets given limited amount of resources. our experiments on synthetic and real data sets show that cb-svm is highly scalable for very large data sets while also generating high classification accuracy.
categories and subject descriptors
i.1  pattern recognition : design methodology-classifier design and evaluation
keywords
support vector machines  hierarchical cluster
1.	introduction

 the work was supported in part by u.s. national science foundation nsf iis-1  univ. of illinois  and an ibm faculty award.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigkdd' 1  august 1  1  washington  dc  usa copyright 1 acm 1-1/1 ...$1.
　support vector machines  svms  have been promising methods for data classification and regression  1  1  1  1  1  1 . their success in practice is drawn by its solid mathematical foundations which convey the following two salient properties:
margin maximization: the classification boundary functions of svms maximize the margin  which in machine learning theory  corresponds to maximizing the generalization performance given a set of training data.  see section 1 for more
details. 
nonlinear transformation of the feature space using the kernel trick: svms handle a nonlinear classification efficiently using the kernel trick which implicitly transforms the input space into another high dimensional feature space.
　the success of svms in machine learning naturally leads to its possible extension to the classification or regression problems for mining a huge amount of data. however  despite the prominent properties of svms  they are not as favored for large-scale data mining as for pattern recognition or machine learning because the training complexity of svms is highly dependent on the size of data set.  it is known to be at least quadratic to the number of data points. refer  for more discussions on the complexity of svms.  many real-world data mining applications involve millions or billions of data records. the following example shows how unscalable a standard svm is on a large data set.
　example 1. the forest cover type data set from uci kdd archive1 is composed of 1 data instances with 1 attributes - 1 quantitative and 1 binary attributes. figure 1 shows the training time of an svm on different numbers of training data randomly sampled fron the original data set. from the graphs  we can infer that it would take years for an svm to train a million data.  we used libsvm1 version 1  and run the svm with the rbf kernel which gave fairly good results among others. we ran them using a
pentium iii 1mhz with 1mb memory. 
　researchers have proposed various revisions of svms to increase the training efficiency by mutating or approximating it. however  they are still not feasible with very large data sets where even multiple scans of the entire data set are too expensive to perform  or they end up losing the benefits of using an svm by the over-simplifications.  see section 1 for the discussions on related work. 

1 http://kdd.ics.uci.edu/databases/covertype/covertype.html
1
http://www.csie.ntu.edu.tw/	cjlin/libsvm

figure 1: non-scalability of svms. x-axis: # of data points; yaxis: training time in hours
　this paper presents a new approach for scalable and reliable svm classification. the method  called clustering-based svm  cb-svm   is specifically designed for handling very large data sets. when the size of the data set is large  svms tend to perform worse with training from the entire data than training from a fine quality of samples of the data set . selective sampling  or active learning  techniques with svms try to sample the training data intelligently to maximize the performance of svms  but they normally require many scans of the entire data set  1  1   section 1 . our cb-svm using the similar idea applies a hierarchical micro-clustering algorithm that scans the entire data set only once to provide an svm with high quality samples that carry the statistical summaries of the data such that the summaries maximize the benefit of learning the svm. cb-svm is scalable in terms of the training efficiency while maximizing the performance of svms.
　the key idea of cb-svmis to use a hierarchical micro-clustering technique to get finer description closer to the boundary and coarser description farther from the boundary  which can be efficiently processed as follows: cb-svm first constructs two micro-cluster trees from positive and negative training data respectively. in each tree  a node in a higher level is a summarized representation of its children nodes. after constructing the two trees  cb-svm start training an svm only from the root nodes. once it generates the  rough  boundary from the root nodes  it selectively decluster only the data summary near to the boundary into lower  or finer  levels using the tree structure. the hierarchical representation of the data summaries is a perfect base structure for cb-svm to perform the selective declustering effectively. cb-svm repeats this selective declustering to the leaf level.
　cb-svm can be used for linear classification or regression analysis for very large data sets  including streaming data or data in large data warehouses  especially where random sampling hurts the performance because of infrequently occurring important data or irregular patterns of incoming data  which causes different probability distributions between training and testing data. we discuss this more in section 1.1.
　our experiments on the network intrusion data set  section 1   a good example which shows that random sampling could hurt  show that cb-svm is scalable for very large data sets while also generating high classification accuracy. based on the best of our knowledge  the proposed method is currently the only svm for very large data sets which tries to generate the best results given limited amount of resources.
　the remainder of the paper is organized as follows. we first provide an overview of svms in section 1. in section 1  we introduce a hierarchical micro-clustering algorithm for very large data sets  originally exploited by t. zhang et al. . in section 1  we present the cb-svm algorithm that applies the hierarchical microclustering algorithm to a standard svm to make the svm scalable for very large data sets. section 1 demonstrates experimental results on artificial and real data sets. we discuss related work in section 1 and conclude our study in section 1.
1.	svm overview
　in machine learning theory  the  optimal  class boundary function  or hypothesis  given a limited number of training data set   is the label of   is considered the one that gives the best generalization performance which denotes the performance on  unseen  examples rather than on the training data. the performance on the training data is not regarded as a good evaluation measure for a hypothesis because the hypothesis ends up overfitting when it tries to fit the training data too hard. when a problem is easy to classify and the boundary function is complicated more than it needs to be  the boundary is likely overfit. when a problem is hard and the classifier is not powerful enough  the boundary becomes underfit. svms are excellent examples of supervised learning that tries to maximize the generalization by maximizing the margin and also supports nonlinear separation using advanced kernels  by which svms try to avoid overfitting and underfitting  1  1 . the margin in svms denotes the distance from the boundary to the closest data in the feature space.
　in svms  the problem of computing a margin maximized boundary function is specified by the following quadratic programming  qp  problem:

the number of training data is denoted by   is a vector of variables  where each component corresponds to a training data      . is the soft margin parameter controlling the influence of the outliers  or noise  in training data.
　the kernel for linear boundary function is   a scalar product of two data points. the nonlinear transformation of the feature space is performed by replacing with an advanced kernel  such as polynomial kernel or rbf kernel  . the use of an advanced kernel is an attractive computational short-cut  which forgoes an expensive creation of a complicated feature space. an advanced kernel is a function that operates on the input data but has the effect of computing the scalar product of their images in a usually much higher-dimensional feature space  or even an infinite-dimensional space   which allows one to work implicitly with hyperplanes in such highly complex spaces.
　another characteristic of svms is that its boundary function is described by the support vectors  svs  which are the data the closest to the boundary. the above qp problem computes a vector   each element of which specifies the weight of each data  and the svs is the data whose corresponding is greater than zero. in other words  the other data rather than the svs do not contribute to the boundary function  and thus computing an svm boundary function can be viewed as finding the svs with the corresponding weights to describe the class boundary.
　there have been many attempts to revise the original qp formulation such that it can be solved by a qp solver more efficiently  1  1 .  see section 1 for more details.  we do not revise the original qp formulation of svms. instead  we try to provide a smaller but high quality data set that is beneficial to computing the svm boundary function effectively by applying a hierarchical clustering algorithm. our cb-svm algorithm substantially reduces the total number of data points for training an svm while trying to keep the high quality of svs that describes the boundary the best.
1. hierarchicalmicro-clustering algorithm for large data sets
　the hierarchical micro-clustering algorithm we present here and will apply to our cb-svm in section 1 was originally exploited by t. zhang et al. at 1   which is named birch. the concept of a  micro-cluster  is similar to those in  1  1   which denotes a statistically summarized representation of a group of data which are so close together that they are likely to belong to the same cluster. our hierarchical micro-clustering algorithm has the following characteristics.
it constructs a micro-cluster tree  called cf  clustering feature  tree  in one scan of the data set given a limited amount of resources  i.e.  available memory and time constraints  by incrementally and dynamically clustering incoming multidimensional data points. since the single scan of the data does not allow backtracking  localized inaccuracies may exist depending on the order of data input. however  the cf tree captures the major distribution patterns of the data and provides enough information for cb-svm to perform well.
it handles noise or outliers  data points that are not part of the underlying distribution  effectively as a by-product of the clustering.
　further improved hierarchical clustering algorithms have been developed including cure  or chameleon . chameleon has shown to be very powerful at discovering arbitrarily shaped clusters of high quality  but its complexity is in the worst case where is the number of data points. cure produces highquality clusters with complex shapes  and its complexity is also linear to the number of objects  but its parameter setting in general has a significant influence on the results. the cf tree of birch carries the spherical shapes of hierarchical clusters and captures the statistical summaries of the entire data set. thus it provides an efficient and effective structure for cb-svm to run.
1	clustering feature and cf tree
	we start from defining some basic concepts. given	-dimensional
data points in a cluster: where   the centroid and radius of the cluster are defined as:
		 1 
		 1 
is the average distance from member points to the centroid.
　the concepts of clustering feature  cf  tree is at the core of the hierarchical micro-clustering algorithm which makes the clustering incremental without expensive computations. a cf is a triple which summarizes the information that a cf tree maintains for a cluster.
	definition 1	 clustering feature .  t. zhang et al.  
given d-dimensional data points in a cluster: where = 1  1      the cf vector of the cluster is defined as a triple:   where is the number of data points in the cluster  is the linear sum of the data points  i.e.    and ss is the square sum of the data points  i.e.  .
	theorem 1	 cf additivity theorem .  t. zhang et al.
  assume that	and
are the cf vectors of two disjoint clusters. then the cf vector of the cluster that is formed by merging the two disjoint clusters is:
 1 
refer to  for the proof.
　from the cf definition and additivity theorem  we know that the cf vectors of clusters can be stored and calculated incrementally and accurately as clusters are merged. the centroid and the radius of each cluster can be also computed from the cf of the cluster.
　the cf is a summary of a cluster-a set of data points. managing only this cf summary is efficient  saves spaces significantly  and is sufficient for calculating all the information for building the hierarchical micro-clusters which will facilitate computing an svm boundary for a very large data set.
1.1	cf tree
　a cf tree is a height-balanced tree with two parameters: branching factor and threshold . a cf tree of height is showing in the right side of figure 1. each nonleaf node consists of at most entries of the form   where  1     1  is a pointer to its -th child node  and  1  is the cf of the subcluster represented by this child. a leaf entry  the entry in a leaf node  only has a without a child pointer. so  a leaf or a nonleaf node represents a cluster made up of all the subclusters represented by its entries. the threshold is a constraint for the leaf entries to satisfy such that the radius of an entry in a leaf node has to be less than .
　the tree size is a function of . the larger is  the smaller the tree is. the branching factor can be determined by a page size such that a leaf or nonleaf node fit in a page.
　this cf tree is a compact representation of the data set because each entry in a leaf node is not a single data point but a subcluster  which absorbs many data points with radius under a specific threshold  .
1	algorithm description
　a cf tree is built up dynamically as new data objects are inserted. the ways that it inserts a data into the correct subcluster  merges leaf nodes  and manages nonleaf nodes are similar to those in a b+-tree  which can be sketched as follows:
1. identifying the appropriate leaf: starting from the root  it descends the cf tree by choosing the child node whose centroid is the closest.
1. modifying the leaf: if the leaf entry can absorb the new data object without violating the threshold condition  updates just the cf vector of the entry. if not  add a new entry. if adding a new entry causes a node split  split by choosing the farthest pair of entries as seeds  and redistributing the remaining entries based on the closest criteria.
1. modifying the path to the leaf: it updates the cf vectors of each nonleaf entry on the path to the leaf. node split in the leaf causes an insertion of a new nonleaf entry into the parent node  and if the parent node becomes split  a new entry is inserted into the higher level node. likewise  this occurs recursively to the root.
　due to the limited number of entries in a node  a highly skewed input could cause two subclusters that should have been in one cluster split across different nodes  and vice versa. these infrequent but undesirable anomalies can be handled in the original birch algorithm by further refinement with additional data scans. however  we do not perform this further refinement because the infrequent and localized inaccuracy do not impact the performance of cbsvm much.
1.1	determination of threshold
　the choice of the threshold is crucial for building the tree in the right size which fits in the available memory because if is too small  we run out of memory before all the data are scanned. the original birch algorithm initially sets very low  and iteratively increases until the tree fits in the memory. t. zhang proved that rebuilding the tree with a larger requires a re-scan of the data inserted in the tree so far and at most extra pages of memory  where is the height of the tree . the heuristics for updating is also provided in . due to space limitations and to keep the focus of the paper  we skip the details of those. in our experiments  we set the initial threshold intuitively based on the number of data points and dimensions and the value range of each dimension such that is proportional to   and the tree of mostly fits in the memory.
1.1	outlier handling
　after the construction of a cf tree  the leaf entries that contains far fewer data points than average are considered to be outliers. a low setting of outlier threshold can increase the classification performance of cb-svm especially when the number of data is relatively large compared to the number of dimensions and the type of boundary functions are simple  which is related to having a low vc dimension in machine learning theory  because the non-trivial amount of noise in the training data which may not be separable by the simple boundary function prevents the svm boundary from converging in the quadratic programming. for this reason  we enabled the outlier handling with a low threshold in our experiments in section 1 because the type of data we are targetting is of large number of data points with relatively low dimensions  and the type of the boundary functions is linear with vc dimension where
is the number of dimensions. see section 1 for more details.
1.1	analysis
　a cf tree that fits in a memory can have the  nodes at maximum where is the size of memory and is the size of a node. the height of a tree is  which is independent of the size of data set. however  if we assume that memory is unbounded and the number of the leaf entries is equal to the number of data points due to a very small threshold   then .
　insertion of a node into a tree requires the examination of entries  and the cost per entry is proportional to the dimension . thus  the cost for inserting data points is . in case of rebuilding the tree due to the poor estimation of   additional re-insertions of the data already inserted has to be added in the cost. then the cost becomes where is the number of the rebuildings. if we only consider the dependence of the size of data set  the computation complexity of the algorithm is . experiments from the original birch algorithm have also shown the linear scalability of the algorithm with respect to the number of objects  and good quality of clustering of the data.
1.	clustering-based svm  cb-svm 
　in this section  we present the cb-svm algorithm which trains a very large data set using the hierarchical micro-clusters  i.e.  cf tree  to construct an accurate svm boundary function.
　the key idea of cb-svm can be viewed being similar to that of selective sampling  or active learning   i.e.  selecting the data which maximizes the benefit of learning. the selective sampling for svms selects and accumulates the low margin data at each round that are close to the boundary in the feature space because the low margin data have higher chances to become the svs of the boundary for the next round  1  1 . appreciating this idea  we decluster the entries near the boundary to get finer samples nearer to the boundary and coarser samples farther from the boundary. in this way  we induce the svs  the description of the boundary  as fine as possible while keeping the total number of training data points as small as possible.
　while selective sampling needs to scan the entire data set at each round to select the closest data point  cb-svm runs based on the cf tree which can be constructed in a single scan of the entire data set and is carrying the statistical summaries that facilitates constructing an svm boundary efficiently and effectively. the sketch of the cb-svm algorithm follows:
1. construct two cf trees from positive and negative data setindependently.
1. train an svm boundary function from the centroids of theroot entries - entries in the root node - of the two cf trees. if the root node contains too few entries  train from the entries of the nodes in the second levels of the trees.
1. decluster the entries near the boundary into the next level and the children entries declustered from the parent entries are accumulated into the training set with the non-declustered parent entries.
1. construct another svm from the centroids of the entries inthe training set  and repeat from step 1 until nothing is accumulated.
　the cf tree is a suitable base structure for cb-svm to perform the selective declustering efficiently. the clustered data also provides better summaries for svms than random samples of the entire data set because the random sampling is susceptible to a biased  or skewed  input  and thus it may generate undesirable outputs especially when the probability distributions of training and testing data are not similar  which is common in practice.  the network intrusion data set from the uci kdd repository that we experiment on in section 1 is a good example of having substantially different distributions in training and testing data set due to the fact that in the real world  the patterns of network intrusions are very irregular. 
1	cb-svm description
　without loss of generality  let us consider linearly separable cases for the convenience of explanation.
　let positive tree and negative tree be the cf trees built from the positive data set and the negative data set respectively. we first train an svm boundary function from the centroids of the root entries of and . note that each entry  or cluster  contains the cf information from which we can efficiently compute the center point and the radius of the cluster. figure 1 shows an example of the svm boundary with the root clusters and the corresponding positive tree.

figure 1: example of the svm boundary trained from the root entries of positive and negative trees.　with the boundary function and the root entries  we determine the low margin clusters that are close to the boundary and thus needs to be declustered into the finer level. let support clusters be the clusters whose center points are the svs of the boundary   e.g.  the circles of bold lines in figure 1. let be the distance from the boundary to the centroid of a support cluster  and let be the distance from the boundary to the centroid of a cluster . then  we consider a cluster which satisfies the following constraint as a low margin cluster.
 1 
where	is the radius of the cluster	.

figure 1: declustering of the low margin clusters.
　the clusters that satisfy the constraint  1  have chances for their subclusters to be the support clusters of the boundary as illustrated in figure 1 where five clusters initially satisfied the constraint  1   three of them were the support clusters  and thus were declustered into finer levels  which results in the right picture of figure
1. the subclusters whose parent clusters do not satisfy constraint  1  would not be the support clusters of the boundary because the surfaces of the parent clusters are farther than the svs of the boundary. thus we have the following remark.
　remark 1  declustering hard constraint . let and be the radius of a cluster and the distance from the boundary to the centroid of the cluster respectively. given a separable set of positive and negative clusters and the svm boundary of the set  the subclusters of have the possibilities to be the support clusters of the boundary only if
　　　　　　  where is the distance from the boundary to the centroid of a support cluster.
　the example we illustrated was a separable case with the hard constraints of svms. in practice  the soft constraints are necessary to cope with noise in the training set. using the soft constraints generates the svs having different distances to the boundary. for the declustering condition with the soft constraints of svms  we replace with   the maximum distance of all   which would include all the clusters whose subclusters have the possibilities to be the support clusters of the soft boundary .
 1 
the subclusters whose parent clusters do not satisfy constraint  1  would not be the support clusters of the soft boundary because the surfaces of the parent clusters are farther than the most distant sv of the boundary.
　remark 1  declustering soft constraint . for the soft constraints of svms  the subclusters of have the possibilities to be the support clusters of the boundary only if   where is the maximum distance from the boundary to the centroids of all the support clusters.
　figures 1 and 1 describe the cb-svm algorithm with the soft constraints of the declustering.
1	cb-svm analysis
　building a cf tree from number of data points costs where is the number of dimensions  the number of entries in a node  the height of the tree  and the number of rebuildings. once the cf tree is built  the training time of cb-svm becomes dependent on the number of entries instead of the number of data points.
　let us assume where is the training time of algorithm .  note that is known to be at least quadratic to and linear to the number of dimensions. refer to  for more discussion on the complexity of svms.  the number of the leaf entries is at most . thus  from the leaf entries becomes .
　let support entries be the svs when the training data are entries in some nodes. assume that is the average rate of the number of the support entries among the training entries. namely  where is the number of training entries and is the average
number of support entries among the training entries  e.g. 
for and . normally and for standard svms with large data sets.
　theorem 1  training complexity of cb-svm . if the number of the leaf entries of a cf tree is equal to the number of input: - positive data set   negative data set output: - a boundary function
notation:
- : a clustering algorithm that builds a hierarchical cluster tree	from a data set
- getrootentries 	 : return the root entries of a tree
- getchildren   : return the children entries of an entry set - getlowmargin   	 : return the low margin entries from a set	which are close to the boundary	 see figure 1 
algorithm: 1.	;	;
1. := getrootentries 	 	getrootentries 	 ;
1. do loop
1. := svm.train   ;
1. := getlowmargin   	 ; 1.	:=	; 1.	:= getchildren 	 ;
1. exit if	= ;
1. :=	;
1. return	;
figure 1: cb-svm

training data points   then cb-svm trains asymptotically times faster than standard svms given the cf tree  where is the average rate of svs and the height of the tree .
proof. if we approximate the number of iterations in cb-svm
　　　 the height of cf tree   then the training complexity of cbsvm given the cf tree is:
where	is the training complexity of the -th iteration of cb-svm. the number of training data points	at the -th iteration is:

where	is the number of data points in a node  and	is the number of the svs among the data. if we assume	  by approximation of	 

if we accumulate the training time of all iterations 

input:	- a boundary function	  a entry set output:	- a set of the low margin entries
algorithm:
1. := getmaxdistanceofsvs   ;
// return the maximum distance of the support vectors from the boundary
1. := getlowermargindata 	 	 ;
// return the data whose margin is smaller than
1. return	;
figure 1: getlowmargin   

if we replace	with	since	 
therefore  trains asymptotically times faster than which is for . 
　theorem 1 states that cb-svm trains asymtotically times faster than a standard svm given a cf tree. the training time of cb-svm is asymptotically equal to that of a standard svm only if all the training data points become the svs. the rate of the svs is variant  depending on the type of problems  the type of kernels  the number of dimensions  the number of data points  and the svm parameters. however  mostly   especially for very large data sets. so  the performance difference between cb-svm and a standard svm goes higher as the data set becomes larger.
1.	experimental evaluation
　in this section  we provide empirical evidence of our analysis on cb-svm using synthetic and real data sets  and we discuss the results. all our experiments are done in a pentium iii 1mhz machine with 1mb memory. 1 synthetic data set
1.1	data generator
　to verify the performance of cb-svm in realistic environments while providing visualized results  we perform binary classifications on two-dimensional data sets we generated as follows.
1. we randomly created clusters such that for each cluster   1  the center point is randomly chosen in the range for each dimension independently   1  the radius
is randomly set in the range of	  and  1  the number of points	in each cluster is also randomly set in the range of	.
1. we labeled the clusters based on the -axis value of each cluster such that cluster is labeled as if
       and if   where is the -axis value of the center   and is the threshold value between and . we removed the clusters not assigned to either of positive or negative which lie across the threshold on -axis. in this way  we drive the clusters to be linearly separable.

	figure 1: synthetic data set in a two-dimensional space. ' ': positive data; '	': negative data1. once the characteristics of each cluster are determined  the data points for the cluster are generated according to a 1-d independent normal distribution whose mean is the center   and whose standard deviation is the radius . the class label of each data is inherited from the label of its parent cluster. note that due to the properties of the normal distribution  the maximum distance between a point in the cluster and the center is unbounded. in other words  a point may be arbitrarily far from its belonging cluster. we refer to the points that belongs to cluster but located farther than the surface of as  outsiders . due to the outsiders  the data set becomes not completely linearly separable  which is more realistic.
1.1	svm parameter setting
　we use the libsvm version 1 for svm implementation and use -svm with linear kernel. we enabled the shrinking heuristics for fast training . -svm has an advantage over standard svms: the parameter has a semantic meaning which denotes the upper bound of the noise rate and the lower bound of the sv rate in training data . in our experiments  we set very low   or   which usually performs very well when the size of data set is large and the noise is relatively small.
1.1	results and discussion on a  large  data set
　figure 1 a  shows an example of the data set generated according to the parameters of table 1. the data generated from the clusters in the left side and in the right side are positive  ' '  and negative  ' '  respectively.
　figure 1 b  shows 1% randomly sampled data from the original data set of figure 1 a . random sampling could hurt the svm performance in the following ways:
from figure 1 b   we know that random sampling reflects the unstable data distribution of the original data set  which includes non-trivial amount of the unnecessary data points for training an svm. the dashed ellipses on the figure indicating densely sampled areas that reflects the original data distribution are mostly not very close to the boundary. in practice  the areas around the boundary tends to be less dense because cluster centers which are very dense are unlikely to

1
http://www.csie.ntu.edu.tw/	cjlin/libsvm
parametervaluesnumber of clusters1range of	 	  1  1 range of	 	  1  1 range of	 	  1  1 1table 1: data generation parameters for figure 1
cross over the boundary of multiple classes. thus the unnecessary data only increases the training time of the svm without contributing to the svs of the boundary.
random sampling hurts more when the probability distributions of training and testing data are different because random sampling that only reflects the distribution of training data could miss significant regions of the testing data. for instance  in the network intrusion detection data set used for the kdd cup at 1  the testing data is not from the same probability distribution as the training data. this is because they were collected in different times of periods  which makes the task more realistic.  see section 1 for more de-
tails. 
　figure 1 c  shows the training data points at the last iteration in cb-svm. we set and   and set the outlier threshold with the standard deviation. it generated a cf tree of   and cb-svm iterated three times.
　note that the training data points of cb-svm are not the actual data but the summary of the clusters of them  so they tend not to have narrowly focused data points as it does in the random sampling. also  the areas far from the boundary thus not likely to contribute to the sv will have very sparse data points because the clusters representing those areas would not be declustered in the process of cb-svm.
　figure 1 a  and  b  show the intermediate data points that cbsvm generated at the first and second iterations respectively. the data points in figure 1 a  are the centroids of the root entries  which are very sparse. figure 1 b  shows dense points around the boundary which are declustered into the second level of the cf tree. fi-

1 http://kdd.ics.uci.edu/databases/kddcup1/kddcup1.html

 a  data distribution at the  b  data distribution at the first iteration     second iteration    
figure 1: intermediate results of cb-svm. ' ': positive data; ' ': negative data
originalcb-svm1% samplesnumber of data points11svm training time  sec. 111sampling time  sec. 111# of false predictions11 # of fp  # of fn  1  1  1  1  1  1 table 1: performance results on synthetic data set  # of training data = 1  # of testing data = 1 . fp:false positive; fn:false negative; sampling time for cb-svm: time for contructing the cf tree
nally  figure 1 c  shows a better data distribution for svms by declustering the support entries to the leaf level.
　for fair evaluation  we generated a testing set using the same clusters and radiuses but different probability distributions by randomly re-assigning the number of points for each cluster. we report the number of false predictions  # of false negative + # of false positive  on the testing data set because the data size is so big compared to the number of false prediction that the accuracy itself does not show much difference between them.
　table 1 shows the performance results on the testing data set. cb-svm based on the clustering-based samples outperforms the standard svm with the same number of random samples. the  number of data points  for cb-svm in table 1 denotes the number of training data points at the last iteration as shown in figure 1 c . the  training time  for cb-svm in the table indicates the svm training time on that data  which is almost equal to that of 1% random samples since both generated similar number of data points. the  sampling time  for cb-svm denoting the time to the construction of the 1 data points of figure 1 c  definitly takes longer than the random sampling because it involves the construction of a cf tree.  the long construction time of the cf tree is partly caused by our non-optimized implementation of the hierarchical micro-clustering algorithm. 
　however  as the data size grows  the random sample size that generates similar accuracies as that of cb-svm also increases  for which the svm training time     becomes dominating over the  sampling time  for cb-svm   with a fixed    and thus the total training time of the svm with random sampling ends up longer than that of cb-svm.  see the next section. 
1.1	results and discussion on a  very large  data set
　we generated a much larger data set according to the parameters of table 1 to verify the performance of cb-svm compared to ran-
parametervaluesnumber of clusters1range of	 	  1  1 range of	 	  1  1 range of	 	  1  1 1table 1: data generation parameters for the very large data set
s-rate# of data# of errorst-times-time1%1111%1111%1111%1111%1111%111asvm11cb-svm111table 1: performance results on the very large data set  # of training data = 1  # of testing data = 1 . s-rate: sampling rate; t-time: training time; s-time: sampling time; asvm: selective sampling
dom sampling and asvm  selective sampling or active learning with svms  for very large data sets. table 1 shows the performance results of random sampling  asvm  and cb-svm on the  very large  data set. we did not run an svm on the entire data set since it will take years to finish training. note that due to the simple linear boundary on the very large amount of training data  random sampling does not increase the performance of svms at some point as the sample size increases. asvm and cb-svm showed the error rates around 1% lower than the random sampling of the highest performance. the training time of cb-svm in total  t-time + stime  was shorter than that of asvm or the random sampling of the highest performance. asvm  showed the similar results as ours since the basic idea is similar  which implies that for large data sets  svms perform better with a fine quality of samples than a large amount of random samples. however  asvm takes much longer than cb-svm for very large data sets that do not fit in the memory because it needs to scan the entire data set at each round to select the closest data point  thereby generating too much i/o cost to undergo as many rounds as it needs to get enough training data. in this experiment  we ran the asvm with  starting from one positive and one negative sample and adding five samples at each round   which gave fairly good results among others.   is commonly set below ten. if is too high  its performance converges slower which ends up with larger amount of training data to achieve the same accuracy  and if is too low  asvm may need to undergo too many rounds  1  1 .  it underwent 1 rounds resulting in 1 times of data scans to sample 1 training data  which took 1 seconds in total for training. we discuss asvm further in section 1.
1	real data set
　in this section  we experiment on the network intrusion detection data set from the uci kdd archive which was used for the kdd cup at 1. this data set consists of about five millions of training data and three hundred thousands of testing data. as previously noted  cb-svm works for very large data sets including streaming

1 http://kdd.ics.uci.edu/databases/kddcup1/kddcup1.html data or data warehouse analysis especially where random sampling hurts the performance due to infrequent occuring important data or irregular patterns of data incoming which causes different probability distributions of training and testing data. the network intrusion data set is a good application for cb-svm because the testing data is not from the same probability distribution as the training data  and it also includes specific attack types not in the training data.  the datasets contain a total of 1 training attack types  with an additional 1 types in the test data only.  this is because they were collected in different times of periods  which makes the task more realistic.  some intrusion experts believe that most novel attacks are variants of known attacks and the  signature  of known attacks can be sufficient to catch novel variants.  our experiments on this data set show that our method based on the clustering-based samples significantly outperforms the random sampling having the same number of samples.
1.1	experiment setup
　each data object consists of 1 features  1 continuous features and 1 symbolic features . we normalized the continuous feature values into between zero and one by dividing them by their maximum values. we created one independent  zero-one   predicate  feature for each value of the symbolic features such that  one  indicates the existence of the value. our way of combining multivariable features may not be the best way for svms. using more sophisticated techniques for pre-processing the features could improve the performance further.
　we set for the cf tree because the total number of features in this data set becomes about 1 times larger than that in our synthetic data set and the range of each value is the same. the outlier threshold in this data set was tuned with a lower value because the outliers in the network intrusion data set could have valuable information. however  tuning the outlier threshold involves some heuristics depending on the type of data set and the type of boundary function. further definition and justification on the heuristics for specific types of problems is a subsequent future work.
　we used the same svm implementation with the same way of optimizing parameters as in the experiments on the synthetic data sets. linear kernel also showed good performance  over 1% accuracy  in this experiment  which implies the classification on this network intrusion data set is likely separable by a linear function. we briefly discuss the usage of nonlinear kernel in cb-svm in section 1.
1.1	results
　our task is to distinguish normal connections from attacks. table 1 shows the performance results of random sampling  asvm  and cb-svm on the network intrusion data set. running the svm with the larger amount of samples did not improve the performance much for the same reason as discussed in section 1.1. asvm and cb-svm also generated better results than the random sampling  and the total training time of cb-svm is much faster than that of
asvm.  we run asvm with the same parameters as in section
1.1. 
1.	discussion on related work
　our work is in some aspects related to:  1  svm fast implementations   1  svm approximations   1  on-line svms or incremental and decremental svms for dynamic environments   1  selective sampling  or active learning  for svms  and  1  random sampling techniques for svms.
　many algorithms and implementation techniques have been developed for training svms efficiently since the running time of the
s-rate# of data# of errorst-times-time1%1111%1111%1111%1111%111asvm11cb-svm111table 1: performance results on the network intrusion data set  # of training data = 1  # of testing data = 1 . s-rate: sampling rate; t-time: training time; s-time: sampling time; asvm: selective sampling
standard qp algorithms grows too fast. most effective heuristics to speed up svm training are to divide the original qp problem into small pieces  thereby reducing the size of each qp problem. chunking  decomposition  1  1   and sequential minimal optimization  are most well-known techniques. our cb-svm algorithm runs on top of these techniques to handle very large data sets by condensing further the training data into the statistical summaries of large data groups such that coarse summary is made for  unimportant  data and fine summary is made for  important  data. svm approximations have been attempted to improve the computational efficiency of svms by altering the qp formulation to the extent that it keeps a similar semantic of the original svm while it is faster to be solved by a qp solver  1  1 . however  their new formulations are still not proven to be efficient and reliable enough to work with very large data sets.
　on-line svms or incremental and decremental svms have been developed to handle dynamically incoming data efficiently  1  1  1 . in this senario that an svm model is incrementally constructed and maintained  the newer data have a higher impact on the svm model than older data. in other words  recent data have a higher chance to be the svs of the svm model than older data. thus  for the analysis of an archive data which should treat all the data equally  they would generate undesirable outputs.
　selective sampling or active learning is to intelligently sample a small number of training data from the entire data set that maximizes the degree of learning  i.e.  learning maximally with a minimum number of data points  1  1  1 . the core of the active learning technique is to select the data intelligently such that the degree of learning is maximized by the data. a common active learning paradigm iterates a training and testing process as follows:  1  construct a model by training an initially given data   1  test the entire data set using the model   1  by analyzing the testing output  select the data  from the entire data set  that will maximize the degree of learning for the next round   1  accumulate the data to the training data set  and train them to construct another model  and  1  repeat from  1  to  1  until the model becomes accurate enough.
　the idea of selective sampling for svms is to select the data close to the boundary in the feature space at each round because the data near the boundary have higher chances to be svs in the next round  i.e.  a higher chance to move the boundary further  1  1 . they iterate until there exists no data nearer to the boundary than the svs. however  an active learning system needs to scan the entire data set at every round to select the data  which generates too much i/o cost for very large data sets.
　some random sampling techniques  1  1  developed to reduce the training time of svms for large data sets are also based the same idea as the selective sampling which samples the data near the boundary with higher probabilities. they also need to scan the entire data set at each round when the samples are add in. another method using random sampling  was developed for nonlinear svms using the random sampling technique in the kernel trick.
　based on the best of our knowledge  our proposed method is currently the only svm for very large data sets which tries to generate the best results given limited amount of resource.
1.	conclusions and further work
　this paper proposes a new method called cb-svm  clusteringbased svm  that integrates a scalable clustering method with an svm method and effectively runs svms for very large data sets. the existing svms are not feasible to run such data sets due to their high complexity on the data size or frequent accesses on the large data sets causing expensive i/o operations. cb-svm applies a hierarchical micro-clustering algorithm that scans the entire data set only once to provide an svm with high quality micro-clusters that carry the statistical summaries of the data such that the summaries maximize the benefit of learning the svm. cb-svm tries to generate the best svm boundary for very large data sets given limited amount of resource based on the philosophy of hierarchical clustering where progressive deepening can be conducted when needed to find high quality boundaries for svm. our experiments on synthetic and real data sets show that cb-svm is very scalable for very large data sets while generating high classification accuracy.
　cb-svm is currently limited to the usage of linear kernels since the hierarchical micro-clusters would not be isomorphic to a new high-dimensional feature space once the space is transformed by a nonlinear kernel. in other words  the statistical summaries of data such as radius and distances computed in the input space will not be preserved in the transformed feature space. constructing effective indexing structures for nonlinear kernels is an interesting direction of future work since it has high practical value especially for pattern recognition of large data sets  such as classifying forest cover types or the pictures from a huge amount of satellite data.
