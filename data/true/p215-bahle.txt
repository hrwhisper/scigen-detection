search engines need to evaluate queries extremely fast  a challenging task given the vast quantities of data being indexed. a significant proportion of the queries posed to search engines involve phrases. in this paper we consider how phrase queries can be efficiently supported with low disk overheads. previous research has shown that phrase queries can be rapidly evaluated using nextword indexes  but these indexes are twice as large as conventional inverted files. we propose a combination of nextword indexes with inverted files as a solution to this problem. our experiments show that combined use of an auxiliary nextword index and a conventional inverted file allow evaluation of phrase queries in half the time required to evaluate such queries with an inverted file alone  and the space overhead is only 1% of the size of the inverted file. further time savings are available with only slight increases in disk requirements.
categories and subject descriptors
h.1  information storage and retrieval : systems and software evaluation- efficiency ; e.1  data : storage representations
general terms
algorithms  performance
keywords
indexing  query evaluation  phrase query evaluation  inverted index  nextword index  evaluation efficiency  index representation  stopping
1. introduction
　search engines are used to find data in response to ad hoc queries. on the web  most queries consist of simple lists of words. however  a significant fraction of the queries include phrases  where the user has indicated that some of the
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigir'1  august 1  1  tampere  finland.
copyright 1 acm 1-1/1 ...$1.
query terms must be adjacent  typically by enclosing them in quotation marks. phrases have the advantage of being unambiguous concept markers and are therefore viewed as a valuable retrieval technique  1  1  1  1 
　in this paper  we explore new techniques for efficient evaluation of phrase queries.
　a standard way to evaluate phrase queries is to use an inverted index  in which for each index term there is a list of postings  and each posting includes a document identifier  an in-document frequency  and a list of offsets. these offsets are the ordinal word positions at which the term occurs in the document. given such a word-level inverted index and a phrase query  it is straightforward to combine the postings lists for the query terms to identify matching documents. this does not mean  however  that the process is fast. even with an efficient representation of postings   the list for a common term can require several megabytes for each gigabyte of indexed text. worse  heuristics such as frequencyordering  or impact-ordering  are not of value  as the frequency of a word in a document does not determine its frequency of participation in a particular phrase.
　a crude solution is to use stopping  as is done by some widely-used web search engines  the google search engine  for example  neglects common words in queries   but this approach means that a small number of queries cannot be evaluated  while many more evaluate incorrectly . another solution is to index phrases directly  but the set of word pairs in a text collection is large and an index on such phrases difficult to manage.
　in recent work  we proposed nextword indexes as a way of supporting phrase queries and phrase browsing  1  1  1 . in a nextword index  for each index term or firstword there is a list of the words or nextwords that follow that term  together with the documents and word positions at which the firstword and nextword occur as a pair. the disadvantage of a nextword index is its size  typically around half that of the indexed collection. also  as described originally  nextword index processing is not particularly efficient  as the nextwords must be processed linearly and  compared to an standard inverted index  for rare firstwords the overhead of the additional layer of structure may outweigh the benefits. in this paper we propose that phrase queries be evaluated through a combination of an inverted index on rare words and a form of nextword index on common words. we explore the properties of phrase queries and show experimentally that query evaluation time can be halved if just the three most common firstwords are supported through a nextword index. while phrase browsing is not possible with such an arrangement  the disk overheads of the partial nextword index are small and the benefits are substantial.
　we have observed that many ordinary queries - those without quotation marks - nonetheless resolve successfully if processed as a phrase query  a phenomenon that search engine users are familiar with  as the most popular engines highly rank matches in which the query terms are adjacent. this suggests that phrase querying is a potential method for a fast  first cut  evaluation method  as it allows more rapid identification of documents in which the terms occur as a phrase.
1. properties of queries
　with large web search engines being used daily by millions of users  it has become straightforward to gather large numbers of queries and see how users are choosing to express their information needs. some search engine companies have made extracts of their query logs freely available. in our research  we have made extensive use of query logs provided by excite dating to 1 and 1  as well as more recent logs from other sources. these logs have similar properties  with regard to our purposes   and we report primarily on the excite logs in this work. in the excite log  after sanitizing to remove obscenity there are 1 1 queries  including duplicates . of these  1 or 1% are explicit phrase queries  that is  they include a sequence of two or more words enclosed in quotes. amongst the rest of the queries-those without a phrase- about 1% contain a word that does not occur at all in the 1 gigabytes  gb  of data we use. however  almost exactly 1% of the remaining non-phrase queries actually match a phrase in the 1 gb dataset we use in our experiments.
　a surprising proportion of the phrases include a common term. amongst the explicit phrase queries  1 or 1% include one of the three words that are commonest in our dataset   the    to   and  of . 1% of the phrase queries include one of the 1 commonest terms. in some of these queries the common word has a structural function only  as in tower of london  and can arguably be safely neglected during query evaluation. in other queries  however  common words play an important role  as in the movie title end of days or the band name the who  and evaluation of these queries is difficult with the common words removed  especially when both  the  and  who  happen to be common terms .
　taken together  these observations suggest that stopping of common words will have an unpredictable effect. stopping may yield efficiency gains  but means that a significant number of queries cannot be correctly evaluated. we experimented with a set of 1 phrase queries that between them match 1 〜 1 documents. stopping of common words means that a query such as tower of london must be evaluated as tower -- london: the query evaluation engine knows that the two remaining query terms must appear with a single term between them. if the commonest three words are stopped  there are 1 〜 1 total matches for all queries extracted from the log. however  these are distributed extremely unevenly amongst the queries: for some queries the great majority of matches are incorrect. the figure rises to 1 〜 1 for the commonest 1 words  and 1〜1 for the commonest 1 words  while a significant number of queries  containing only stopped words  cannot be evaluated at all.
　it can be argued that stopwords are often insignificant  and that even a document that is technically a mismatch- due to the wrong stopword being present-may be just as likely to be relevant as a document where the match is correct. however  it is worth emphasising that there are many queries in which stopwords do play an important role. the words  to  and  from  are often stopped  for example  but mismatches to the query flights to london are likely to be incorrect. another instance is that the word  the  often forms part of a description  thus the moon should not match websites about a moon of jupiter  keith moon  or a book publisher.
　amongst the phrase queries  the median number of words in a phrase is 1  and the average is almost 1. about 1% of the queries have three words or more  and 1% have six words or more. a few queries are much longer  such as titles: the architect of desire beauty and danger in the stanford white family by suzannah lessard.
　another point of interest is where in a phrase the common words occur. in english  the common words rarely terminate a phrase query. only 1% of phrase queries with  the    to   or  of  have these words at the end. almost all of these queries are short: virtually no queries of four words or more terminate with one of the commonest terms. in the short queries ending in a common term  the other query terms are themselves usually common. we take advantage of these trends in the methods for phrase query evaluation proposed in this paper.
1. inverted indexes
　inverted indexes are the standard method for supporting queries on large text databases; there are no practical alternatives to inverted indexes that provide sufficiently fast ranked query evaluation. an inverted index is a two-level structure. the upper level is all the index terms for the collection. for text databases  the index terms are usually the words occurring in the text  and all words are included. the lower level is a set of postings lists  one per index term. following the notation of zobel and moffat   each posting is a triple of the form:

where d is the identifier of a document containing term t  the frequency of t in d is fd t  and the o values are the positions in d at which t is observed. an example inverted file is shown in figure 1. in this example  there is a vocabulary of five words  each of which has a postings list.
in memory
vocabularyon disk
vectors
1   1  1 1  ... 
1   1  1   
1   1    1   ... 
1   1    1   ... 
1   1  1    ... hampshirehistoricinnewrailroadsfigure 1: an inverted file for a collection with a vocabulary of five words.　it is straightforward to use an inverted index to evaluate a phrase query. consider the query magdalene sue prentiss. of these terms   magdalene  is the rarest  and its inverted list is fetched first. the postings are decoded and a temporary structure is created  recording which documents contain this word and the ordinal word positions in each document at which it occurs. the term  prentiss  is the next rarest  and is processed next. for each document identifier and word offset in the temporary structure created earlier  a posting is sought to see whether  prentiss  is in the document two words later. if the search fails  that word position is discarded from the temporary structure  as is the document identifier if no word positions for that document remain. as both the structure and the postings are sorted  this process is a linear merge. then the postings list for  sue  is fetched and decoded  and used to further delete entries from the temporary structure. the remaining entries are documents and word positions at which the phrase occurs.
summarizing  phrase queries are evaluated as follows.
1. sort the query terms from rarest to commonest  keeping note of their original position in the phrase.
1. fetch the postings list for the first  rarest  query term.decode this list into a temporary structure of document identifiers and word offset positions.
1. for each remaining query term  decode its postingslist  merging it with the temporary data; this merge process discards from the temporary structure all document identifiers and word offsets that do not match any entry in the postings list.
　in this query evaluation model  processing of the first query term establishes a superset of the possible locations of the complete phrase  which are maintained in a temporary structure; as the subsequent query terms are evaluated  this structure is pruned  never added to. it is thus essential to begin processing with the rarest query term  to avoid creation of an excessively large temporary structure  or of having to process the inverted lists in stages to stay within a memory limit .
　a simple heuristic to address this problem is to directly merge the inverted lists rather than decode them in turn. on the one hand  merging has the disadvantage that techniques such as skipping  cannot be as easily used to reduce processing costs  although as we discuss later skipping does not necessarily yield significant benefits . on the other hand  merging of at least some of the inverted lists is probably the only viable option when all the query terms are moderately common.
　whether the lists are merged or processed in turn  the whole of each list needs to be fetched  unless query processing terminates early due to lack of matches . for ranked query processing it is possible to predict which postings in each inverted list are most likely to be of value  and move these to the front of the inverted list; techniques for such list modification include frequency-ordering  and impact-ordering . with these techniques  only the first of the inverted lists need be fetched during evaluation of most queries  greatly reducing costs.
　in contrast  for phrase querying it is not simple to predict which occurrences of the term will be in a query phrase  and thus such reordering is unlikely to be effective. offsets only table 1: size of inverted index  mb  after stopping of common words.
number ofindex sizewords stopped mb 111111have to be decoded when there is a document match  but they still have to be retrieved.
　other techniques do have the potential to reduce query evaluation time  in particular skipping   in which additional information is placed in inverted lists to reduce the decoding required in regions in the list that cannot contain postings that will match documents that have been identified as potential matches. on older machines  on which cpu cycles were relatively scarce  skipping could yield substantial gains. on current machines  however  disk access costs are the more important factor  and in other experiments we have observed that the increase in length of lists required by skipping outweighs the reduction in decoding time. we therefore do not use skipping in our experiments.
　we have implemented a phrase query evaluator based on inverted lists  using compression techniques similar to those employed in mg  to reduce costs  and have used it to test the efficiency of phrase query evaluation. our test data is 1 gb of html containing about 1 gb of text  drawn from the trec large web track  .
　table 1 shows the size of the index with a range of levels of stopping. as can be seen  the three commonest words account for around 1% of the index size  and only small space savings are yielded by stopping. however  as table 1 shows  the impact of stopping on query evaluation time is dramatic. just removing the three commonest words reduces average time by about 1%  and by a factor of 1 for longer queries. for these longer queries  the savings continue to increase as more common words are stopped. it is the scale of these savings that make stopping attractive  despite the fact that they are at the cost of inaccurate query results.
table 1: times for phrase query evaluation  seconds  on an inverted index after stopping of common words. results are shown for all queries; 1word queries only; and 1-word queries only.
number ofoverall1-word1-wordwords stoppedtime  sec queriesqueries1.1.1.11111.1.1.11111.1.1.11111. nextword indexes
　inverted indexes allow evaluation of phrase queries  but faster evaluation is possible with phrase-oriented indexes. one possibility is to use a conventional inverted index in which the terms are word pairs. another way to support phrase based query modes is to index and store phrases directly  or simply by using an inverted index and approximating phrases through a ranked query technique  1  1 . greater efficiency  with no additional in-memory space overheads  is possible with a special-purpose structure  the nextword index   where search structures are used to accelerate processing of word pairs. the nextword index takes the middle ground by indexing pairs of words and  therefore  is particularly good at resolving phrase queries containing two or more words. as noted above and observed elsewhere  the commonest number of words in a phrase is two .
　a nextword index is a three-level structure. the highest level is of the distinct index terms in the collection  which we call firstwords. at the middle level  for each firstword there is a data structure  such as a front-coded list  or for fast access a structure such as a tree  of nextwords  which are the words observed to follow that firstword in the indexed text. for example  for the firstword  artificial   nextwords include  intelligence    insemination   and  hip . at the lowest level  for each nextword there is a postings list of the positions at which that firstword-nextword pair occur.
　an example nextword index is shown in figure 1. in this example  there are two firstwords   in  and  new . some of the nextwords for  in  are  all    new   and  the . for each firstword-nextword pair  there is a postings list.  a nextword index is of course a form of inverted index  but for consistency with other work we use  inverted index  solely to refer to a standard word-level inverted file. 
　in nextword indexes  the postings lists are typically short  because most pairs only occur infrequently. for example  the postings list for the firstword-nextword pair  the ， who  is orders of magnitude smaller than the postings lists for these words in an inverted file. it follows that phrase query evaluation can be extremely fast.
　nextword indexes also have the benefit of allowing phrase browsing or phrase querying  1  1 ; given a sequence of words  the index can be used to identify which words follow the sequence  thus providing an alternative mechanism for searching text collections. however  we do not consider phrase browsing further in this paper.
for phrase queries of more than two words  multiple postings lists must be fetched from the nextword index to resolve the query. selection of which listings to fetch requires a little care. for example  with the query boulder municipal employees credit union
the query can be resolved by fetching the postings lists for the firstword-nextword pairs  boulder ， municipal    employees ， credit   and  credit ， union . alternatively  it would be possible to get the lists for  boulder ， municipal    municipal ， employees   and  credit ， union . which is most efficient depends on which is shorter: the list for  employees ， credit  or the list for for  municipal ， employees . unfortunately  establishing which is shorter requires two disk accesses  to retrieve the nextwords for  employees  and  municipal . however  we have observed that the frequency of a firstword closely correlates to the lengths of its nextword lists.
thus in the query historic railroads in new hampshire
we can with confidence choose  railroads ， in  in preference to  in ， new   because  railroads  is much less common than  in . we have considered algorithms for choosing order of evaluation elsewhere . an efficient algorithm for evaluating phrase queries with a nextword index is as follows.
1. if the number of query terms n is even  the query can consist of n/1 disjoint firstword-nextword pairs. if the number of query terms n is odd   firstwordnextword pairs must be chosen. however  in both cases it is more efficient to choose more than the minimum number of pairs  if doing so avoids choice of a common word as a firstword.
1. the method we use is to choose all n   1 firstwordnextword pairs; then sort them by increasing firstword frequency; then discard from the list the pairs that are completely covered by preceding selections. this approach can lead to processing of more than pairs  but experimentally was shown to reduces costs overall.
1. the selected word pairs are sorted by increasing frequency of the firstwords  then their postings lists are processed as for inverted file phrase query processing.
the nextword index for our web collection is 1 mb in size  almost exactly twice that of an inverted file. for phrase queries  the savings in query evaluation time are dramatic. average query evaluation time is reduced to 1 seconds  faster than inverted files by a factor of 1. for two-word queries  the time falls to 1 seconds  which is faster by a factor of 1. the time for 1-word queries is 1.
　an interesting possibility suggested by these results is that-given space for a nextword index-all queries be evaluated as if they were phrases. we observed above that a significant fraction of all queries successfully evaluate  and indeed on browsing the query logs it is obvious that many of the queries without quotation marks are nonetheless intended to be phrases. spink et al.  suggest that most two-word queries should be treated as a phrase query even if they were entered as a ranked query. given that search engines return as highest matches the pages in which the
in memory
vocabularyon disk
nextword listson disk inverted vectorsinall1   1    1  1 1    1   new1   1   the1   1    1    1  1 1 1 1    ... ...newage1   1  1 1    1  1    hampshire1   1  1    1    ... house1   1    1   ...figure 1: a nextword index with two firstwords.query words appear in sequence  use of a nextword index provides a rapid mechanism for finding these pages.
　much of the speed improvement for phrase queries yielded by nextword indexes is for queries involving a non-rare word. indeed  for queries of rare words there may be little gain  as query processing with nextword indexes involves more complex structures than does processing with inverted indexes. as the two approaches to phrase query processing appear  then  to have complementary advantages  it is attractive to try to combine their strengths.
1. combined query evaluation
　we have observed above that inverted indexes are the least efficient for phrases involving common words  the case where nextword indexes yield the greatest speed advantage. we therefore propose that common words only be used as firstwords in a stripped-down nextword index  and that this new index be used where possible in evaluation of phrase queries. we call this a top frequency based scheme  since only the most frequent words are indexed in the nextword index. we have explored other schemes based on the frequency of words in the indexed collection  or based on the frequency of words in the query log. none of the investigated schemes offered a better space and time trade-off  so we report only results from the top frequency scheme.
　an example of a top frequency combined index is shown in figure 1. at the left there is a vocabulary of five words. each word has an inverted list  together constituting a complete inverted file for these words. in addition  the common words  in  and  new  have a nextword index.
　with a combined index  processing involves postings lists from both the inverted index and the nextword index. consider again the query:
historic railroads in new hampshire
neither  historic  nor  railroads  is a common word  so establishing that these terms occur in the phrase involves fetching their postings lists from the inverted index and processing in the usual way. however   in  and  new  are both common. the posting list for the firstword-nextword pair  in ， new  from the nextword index must be fetched and processed. then there is a choice. on the one hand  the nextword index postings list for  new ， hampshire  cannot be longer than the inverted index postings list for  hampshire  and in all likelihood is a great deal shorter. on the other hand  compared to the inverted index  an extra disk access is required to fetch a postings list from the nextword index. in our implementation  we process using the nextword index if possible  and resort to the inverted index only for terms that are not in an indexed firstwordnextword pair.
in summary  we use the following process:
1. identify all pairs in the list in which the first term isan indexed firstword. sort these terms  and prune the list as for standard evaluation of phrase queries via a nextword index.
1. for all terms not in a firstword-nextword pair  sort.
1. process the postings lists in increasing order of firstword frequency  so that processing of nextword index lists and of inverted file lists is interleaved.
in this model  a common word need only be evaluated via its postings list in the inverted file if it occurs as the last word in a query  which in the excite query log is a rare event.
　we have tested other query resolution methods that involved term sorting based on nextword frequency  or nwf  the number of nextwords for a firstword   inverted document frequency  or idf  the number of documents in which a word occurs   or both. we also experimented with resolving nextword entries of a given query always first  or always last. we found overall that these different resolution methods did not significantly vary in query speed and behaved almost identically to sorting by idf only. we therefore sort inverted index terms and nextword terms based on idf since we do not need to keep another statistical value per index term and sorting is straightforward.
1. experimental results
　all experiments were run on an intel 1 mhz pentium iii-based server with 1 gb of memory  running the linux operating system under light load. in table 1 we show sizes of nextword indexes in which only the commonest terms are allowed as firstwords. the table shows that a nextword index that contains only the three commonest terms consumes 1 mb  that is  just over 1% of the space of the inverted index or around 1% of the size of the original html collection.
　query evaluation time with a combined index is shown in table 1.  the  1  line is repeated from table 1.  as can be seen  use of a nextword index allows evaluation of all phrase queries  and much more rapidly than was previously possible. use of a partial nextword index of 1% of the html collection halves query evaluation time; a partial nextword
in memory
vocabularyon disk
nextword listson disk inverted vectorshampshire1   1  1 1   ... historic1   1    1  1   in1   1    1   ... all1   1    1  1 1    1   new1   1   the1   1    1    1  1 1 1 1   ... ...new1   1  1    1  1 1   ... age1   1  1 1    1   hampshire1   1  1    1   ... 1 1 1 1   ... house1   1    1   
1   1    1    1  1 ...railroadsfigure 1: a combined inverted file and nextword index.table 1: size of nextword index  mb  containing only common firstwords.
number ofindex sizecommon words mb 11111index of less than 1% of the size of the collection cuts time to a third.
　these are substantial savings at low cost. phrase query processing time with a nextword index is only slightly greater than with a stopped inverted file  and no answers are lost.
　such combined processing can be integrated with other heuristics for phrase query evaluation. for example  a strategy that is likely to be successful in the context of a web search engine is to maintain indexes  perhaps for a limited time only  on phrases  or word pairs from phrases  that are commonly posed as queries. amongst our 1 queries  1 are distinct. the commonest phrase query  thumbnail post  occurs 1 times and involves no common words. the queries themselves contain 1 distinct word pairs; the commonest pair occurs 1 times. indexing of common query pairs has the potential to yield significant further savings.
1. conclusions
　we have proposed that phrase queries on large text collections be supported by use of a small auxiliary index. in this approach  all words in the text are indexed via an inverted file; in addition  the commonest words are indexed via an auxiliary nextword index  which stores postings lists for firstword-nextword pairs. we have shown that the cost of evaluating phrase indexes can be cut by a factor of three  with an auxiliary index that is only 1% of the size of the table 1: times for phrase query evaluation  seconds  on a combined index  with different numbers of common words used in the nextword index. results are shown for all queries; 1-word queries only; and 1-word queries only.
number ofoverall1-word1-wordcommon wordstime  sec queriesqueries1.1.1.11111.1.1.11111.1.1.1111indexed data.
　these results show that there is no need to use stopping in phrases. indeed  the statistics on the number of matches indicate that such stopping leads to significant error rates. while it can be argued that mistakes in matching due to stopping of common words are in many cases unimportant  there are numerous queries where the stopwords are significant; moreover  we have demonstrated that there is no reason to make such mistakes at all.
　our schemes have scope for improvement. in particular  choosing of pairs during query evaluation requires further exploration  and we are further investigating structures for representing nextword lists. however  our results show that evaluation of phrase queries can be dramatically accelerated with only a small additional index  and that stopping of phrases leads to errors and is not necessary for efficiency.
acknowledgements
this research was supported by the australian research council. we thank amanda spink  doug cutting  jack xu  and excite inc. for providing the query log.
