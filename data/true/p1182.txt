　we propose extensions to existing web protocols that allow proofs of authenticity of http server responses  whether or not the http server is under the control of the publisher. these extensions protect users from content that may be substituted by malicious servers  and therefore have immediate applications in improving the security of web caching  mirroring  and relaying systems that rely on untrusted machines  1 . our proposal relies on merkle trees to support 1 and 1 response authentication while requiring only a single cryptographic hash of trusted data per repository. while existing web protocols such as https can provide authenticity guarantees  in addition to confidentiality   https consumes significantly more computational resources  and requires that the hosting server act without malice in generating responses and in protecting the publisher's private key.
categories: h.1  online information services : data sharing
general terms: security
keywords: merkle hash tree  web content distribution  authenticity
1. merkle trees for web content
　merkle hash trees  have been proposed as a model for authenticating query results from untrusted database servers using only a small amount of trusted information . one can view each web repository as a database  and each http get request a query for an individual resource. we explore the feasibility of authenticating both 1  ok  and 1  not found  responses from untrusted web servers through appropriately exploiting merkle hash trees over web repositories. the appeal of merkle trees is that they require only that the root hash value be obtained over a trusted channel in order to authenticate arbitrary requests to a
　particular repository. we believe this property makes them applicable for efficient authentication of most http get responses  excepting only those involving highly dynamic content.
　for a given site  our scheme involves computing a merkle tree structure that consists of hashes of both resources and their canonical web paths. a canonical web path is a normalized form of the resource url whereby the scheme and hostname portion are removed  escape sequences decoded  and so on. its arrangement is as follows: leaf nodes represent resources  and store cryptographically secure hashes of the resource itself and its canonical web path. the value of a leaf node is the result of hashing these two hash values using a cryptographically secure binary hash function. leaf nodes are ordered from left to right according to the canonical web path hash value  order can be imposed by treating this value as an unsigned integer.  this ordering provides a mechanism for generating a proof that a specified path name is not present in the directory without disclosing the path names of the files that are present. internal nodes consist of pointers to left and right children that enforce the ordering. the value of each internal node is the result of hashing the values of its left and right children. the figure in the next column depicts such a tree over a site consisting of five resources f1  f1  f1  f1 and f1 . 

copyright is held by the author/owner s .
www 1  may 1  1  chiba  japan. 1-1/1
jeffrey sorensen
ibm watson research center
yorktown heights  ny sorenj us.ibm.com

　the client must obtain the tree's root hash value from a trusted source  and thereafter it need only verify that each response is consistent with this root value in order to determine response authenticity. for example  consider the case where the client requests the resource identified by canonical web path c1 in the figure. the authentication path of this resource is the set of nodes from the resource leaf to the root  and is depicted by the nodes with bold outlines. in addition to returning the resource f1   in order to support 1  found  response authentication  the server must return the values of the indicated children of each node on this path  as depicted by shading. this auxiliary authentication information and the resource itself provides the client with all information necessary to compute the values along the authentication path from leaf to root. if the computed root hash matches that obtained from the trusted source  the response is authentic. attempts by the server to corrupt either the response body or the auxiliary authentication information will be detected  assuming hashing is secure.
　next  consider the case where the client issues a request for some resource identified by canonical web path c1 that does not exist in the site. to support authentication of the resulting 1  not found  response  the server must somehow prove that there is no such resource present. this is accomplished by returning values along the two authentication paths that originate at the leaves whose canonical web path hashes immediately precede and follow the value h c  1  in the before-mentioned leaf ordering. in our example  we assume these two leaves are those for resources f1 and f1 . the server must thus return h f  1    h c  1    h f  1    h c  1    and the values of the children of nodes along the two authentication paths. to prove authenticity  the client verifies that both of the authentication paths are consistent with the root hash as in the 1  ok  case above. additionally  it must verify that  1  h c  1    h c  1    h c  1  and  1  no other leaf exists between the leaves that terminate the authentication paths based on their rightleft structure.
　auxilliary authentication information can be returned base1 encoded through a special http response header. for both the 1 and 1 cases  the amount of such information is proportional to the height of the merkle tree  which is logarithmic in the number of resources assuming the tree is balanced.
1. root hash distribution
1　a remaining problem is that of securely delivering the root hash value  which authenticates all of the content. already established web protocols provide three elegant methods for distribution of this small item. these techniques are not mutually incompatible  and may all be simultaneously used in accordance with a particular client's policies.
　dns-sec: the dns system  with its distributed automatic caching  dynamic update capability  and design for small data records would seem to be an excellent mechanism for publishers to use to distribute the root hash value. the hash could be published using either the existing txt dns records  or through a format extension to a new type of dns record. unfortunately  dns itself lacks authentication mechanisms. while this has not made the internet unusable  it certainly is one of its most cited weakness. fortunately  dns-sec  the next generation of dns  incorporates public-key based digital signatures to authenticate the data records returned by each query. no modification of existing protocols is needed to support distribution of the root hash as a specially formatted txt dns record  and the dns time-to-live  ttl  property naturally supports expiration of root hashes to handle repository updates. 
　unfortunately  dns-sec remains relatively undeployed at the time of this writing. we therefore present two other approaches which may be more feasible in the near term as dns-sec matures.
　https to content provider server: transport layer security  tls  is an approach for authenticating and securing tcp/ip communications through public-key cryptography. tls is the basis of the https web protocol  thus https itself could be used as a distribution mechanism for root hash information. this approach must involve a standardized scheme for transforming the uri for the requested resource into the name of a trusted server for obtaining the root hash. this is because if a uri of http:// www.popularsite.org/ is mapped to multiple mirror servers by multiple dns a records  then requests for https:// www.popularsite.org/ would also connect to these servers  which we presume lack sufficient trust to answer https requests on behalf of the publisher. a standardized hostname extension such as httpa.www.popularsite.org could be created with a dns a records that point only to the publisher's servers  and which have the appropriate tls credentials to allow https connections.
　certified pki signed root hash: distributing the root hash as a file is subject to the attack of a malicious mirror altering content arbitrarily  computing the new root hash  and serving the malicious root hash instead of the true root hash. this attack can be prevented if the root hash is digitally signed using the publisher's private key  the public key of the publisher is made available  and the public key of the publisher is certified by one of the certificate authorities recognized by the client browser. while this technique can authenticate the content  it cannot assure the freshness of the content. this can be ameliorated through the use of digitally signed validity periods. the protocol could specify a standard location within a mirrored repository where the signed root hash information is to reside.
1. implementation overview
　we now sketch the roles and responsibilities needed to implement the proposed protocol in practice and end with a summary of protocol overhead.
