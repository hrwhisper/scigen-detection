mobile software agents are an increasingly important programming model within the world wide web  www . typically programmed in java or another machine- independent language  the code and associated data have the ability to move their execution from machine to machine  often revisiting the same machine multiple times. in such a case  caching the agent's binaries can lead to a significant improvement in performance. however  existing agent systems generally do not address the issue of cache control via w1c standards. in this paper  we show the need for such systems and demonstrate this through combining ibm's aglets agent system with the squid proxy cache. we give experimental results indicating that a loosely coupled system adds only approximately 1 ms. to agent invocation in cache control overhead  while giving speedups of almost 1 percent in certain network configurations through the use of the www caching infrastructure.
keywords
agents caching http squid aglets java
1. introduction
mobile intelligent agents are autonomous units of logic that move themselves at will from host to host and communicate with the local resources and agents. one task agents perform well is parallel programming  where an agent is started and clones itself onto other free machines for processing. when the clones are done with their task  they move back to their parent and return their data. agents can also reduce wasted network bandwidth . typical network interactions involve a user's querying a remote system for information  processing that information  and then querying the system again. this loop continues until the user is satisfied. much of the bandwidth used is wasted on information that is irrelevant to the user. an intelligent agent  on the other hand  moves itself out to the remote system  executes the queries  and then moves itself back home with its results. this introduces a new performance issue: how much bandwidth is being used to move the agent around  if the agent is large  then it will exhibit worse performance with small queries due to the extra overhead. potentially  more bandwidth will be used for moving the agent than for queries. only when the query is big enough  and the agent small enough  will an agent be more efficient. to counter this problem  a caching proxy can easily be put in front of the agent system. now  only the state of the agent will have to be transferred out on the internet; the actual code for the agent can be found on the local cache.
1. architecture
some agent systems  such as ibm's aglets  have their own caching mechanism for code . unfortunately  they may not be designed to take advantage of w1c cache coherency protocols. when code is put into a system's cache  it may never be refreshed. only when the cache is manually cleared will new code be downloaded. this approach drastically reduces the system's flexibility. we have been studying the effectiveness of using the coherency controls of http in an agent system's cache. specifically  we are using the aglet agent system provided by ibm in conjunction with the squid open-source caching project to explore the implementation of a system combining intelligent agents with a standards-compliant hierarchical caching system  1  1 .
we added an attribute to the cache entries containing the date the object was last modified. when an object is fetched via http  the server returns the date that its object was last modified in a header directive  specifically the  last modified  directive  in the response. that date is then stored with the object in the cache and saved for further use.
we changed aglets to allow for standards-compliant updating of its cache. when a class needs to be loaded  the cache is checked to see if it is present  but the server that holds the code will still be checked to see if it needs a new version. using the http header directive  if-modifiedsince   aglets will request that server return code only if the code has been updated. opening a connection to the server every time significantly affects performance  even if no class is downloaded. to help compensate  a squid cache is placed on the same machine as the aglets server. when aglets needs to check with a code server for new code  it will be processed through the squid caching proxy. because most of the caching responsibilities are offloaded onto squid  only minimal changes are necessary to aglets for full cache coherency support.
1. experimental results
in our experiments  we tested to verify that the changes we made to aglets actually altered the way that agents are loaded. we also measured the performance impact with respect to latency and processing times. all test results are averaged over 1 runs.
the first test determined whether a change to an aglet's code would be noticed by the software. to perform this test  we started up one aglet environment. an aglet was put on a remote http server. we created an instance of the aglet to ensure the http server was set up properly. without shutting down aglets  we modified the code on the server and instantiated a new instance of the aglet. the newly created aglet was an instance of the modified code  which verified that our changes were effective.
we created four aglets that would ping themselves between two aglet environments a limited number of times and track the time it took to complete the task. we made the aglets different sizes to see how the server responded to varying loads. the experimental configuration consisted of a fast ethernet lan connected to the internet via cable modem  and an http server residing on the internet.
the second set of tests  figure 1  measured the latency of aglets under certain configurations. we compared the original version of aglets with and without caching against the modified version with and without caching. the results show that the modified version of aglets that included cache coherency ran at a nearly equivalent speed to the original version without caching. with agents that were 1kb  the original version ran at most 1 percent  1 ms.  faster than our modified system. unless time is a critical factor  the difference in performance should not be an issue. when tested using an agent that was 1kb  the modified aglets actually performed slightly faster  1 ms. . we also removed class caching from the original version of aglets to see how the aglets environment would perform without caching. when only a 1kb aglet is moving around  it takes 1 ms. for each hop. the added time is taken by opening a connection to the class server  downloading the class  and creating an instantiation of the class object. the performance drops significantly for a 1 kb aglet; requiring 1 ms. for each move. the test was performed using broadband access  so downloading 1kb took a small amount of that time. parsing the large class file and creating a class object for it took the majority of the time. under this configuration there was no caching for the classes  which explains the time values. our version of aglets without a web cache outperformed aglets with its cache disabled  indicating squid is not the sole reason for our performance advantage.
we also compared the use of a squid-based system to the standard aglets configuration  which cannot take advantage of a cache hierarchy  but must download any necessary code from the original server. using a 1kbs analog modem and a 1kb aglet  with a current version of the aglet on a local machine and the original host behind the modem connection  the time required for the agent to move between the two local systems was nearly seven times larger  1 s. vs. 1 s.  for the original aglets system. not surprisingly  utilizing the www cache hierarchy considerably improves the performance.
the primary contributors to system overhead are establishing a connection to the class server and fetching the results. connecting to squid and fetching the results takes on average between 1 and 1 ms.  about 1 percent  as shown in table 1. the time squid requires to process the

aglet size  kb 
figure 1: performance comparison with and without caching.
query is minimal; on average it takes no longer than 1 ms. memory and cpu usage for squid are also minimal    1 percent of cpu and memory usage.
sizeconnectsquidget resultstotal1kb11111kb11111kb11111kb1111table 1: overhead of cache coherency  ms 
1. conclusions
we have presented a w1c standards-compliant system for caching code for mobile intelligent agents. our modifications made it possible to update the internal cache of aglets with new code  allowing up-to-date agents to be created without shutting down the system. furthermore  pre-existing agents can have their code updated when they move to a different aglets server. the new functionality makes aglets more desirable for real-world implementations. the performance gap between our version of aglets and the original is small  a minor penalty for significantly enhanced flexibility and access to the web caching hierarchy. the original never performs more than 1 percent better with aglets that are 1kb or larger  and ours performs better when using a 1kb aglet. when slow internet connections are used  our configuration can significantly outperform  by over 1 percent in our case  the original version.
