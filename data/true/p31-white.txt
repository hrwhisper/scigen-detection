we introduce scalability for computer games as the next frontier for techniques from data management. a very important aspect of computer games is the artificial intelligence  ai  of non-player characters. to create interesting ai in games today  developers or players have to create complex  dynamic behavior for a very small number of characters  but neither the game engines nor the style of ai programming enables intelligent behavior that scales to a very large number of non-player characters.
모in this paper we make a first step towards truly scalable ai in computer games by modeling game ai as a data management problem. we present a highly expressive scripting language sgl that provides game designers and players with a data-driven ai scheme for customizing behavior for individual non-player characters. we use sophisticated query processing and indexing techniques to efficiently execute large numbers of sgl scripts  thus providing a framework for games with a truly epic number of non-player characters. experiments show the efficacy of our solutions.
categories and subject descriptors
d.1  programming languages : language classifications- specialized application languages
general terms
languages  processing
keywords
games  scripting  aggregates  indexing
1. introduction
모computer games are becoming the next frontier for social interaction between humans. the entertainment software association estimates that computer and video game software sales in 1 were $1 billion dollars . while graphics have always motivated the growth of the game industry  we believe that the database community also has the opportunity to make significant contributions to this field.

 work done while visiting cornell university.
 supported by a sloan foundation fellowship.
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod'1  june 1  1  beijing  china.
copyright 1 acm 1-1-1/1 ...$1.
모a computer game is a virtual environment where players interact with digital objects or each other for entertainment. one of the keys to developing rich playing experiences is the creation of complex and interesting artificial intelligence  ai . in game development  ai has a slightly different meaning than it does in the academic context. game ai is the system that controls the behavior of nonplayer characters  npcs  - entities created by the game designer and controlled by the computer. while this system may use classic ai algorithms  game ai includes all routines that control behavior  be they intelligent or not.
모broadly speaking  there are two approaches to improving game ai. the first is to create complicated  detailed  dynamic behavior for a few particularly important npcs  like the player's archnemesis or sidekick. this approach is ideal for games that do not have many npcs in need of interesting behavior. for this type of behavior  classic ai is relevant  and has been employed to various degrees in existing games . expert systems have been used for choosing plays in sports games; natural language processing has been used for character interaction in fac ade ; machine learning has been used for creature behavior in black & white .
모however  these techniques are often too computationally expensive or labor intensive to be practical for more than a handful of npcs. increasingly  having just a few intriguing npcs is insufficient for many categories of games. strategy games  massively multiplayer online games  and open world games all frequently require large numbers of interesting characters. hence  the second approach to game ai is to enable interesting but relatively simple behavior for a large number of npcs. for example  character behavior may be controlled by a simple finite state machine. in the aggregate  even simple game ai can lead to complex emergent behavior  so populating a game world with many npcs can create compelling gameplay. however  there is a trade-off between having complex npcs and having many npcs. when the game demands too many npcs  developers may have no choice but to employ simple game ai. but if the ai is too simple  the game will exhibit predictable uniformity. this trade-off is not addressed by the classic areas of research in artificial intelligence.
모a further complication in creating large numbers of npcs is the actual design of the ai for each npc. even if the processing power is available  creating ai is very labor intensive. to solve the problem of content creation  developers employ the use of data-driven ai. in this paradigm  the ai system is heavily parameterized by data files stored outside the code. in the simplest case  these parameters may be numerical values affecting transitions in state machines. however  more generally  they are scripts that are read and processed by the game's ai engine. this approach works for de-

figure 1: expressiveness versus number of npcs
signing large numbers of npcs because these scripts are simple but flexible enough to be adapted to many kinds of characters. in addition  a data-driven ai scheme offloads much of the burden of creating ai from the programmers to the game designers  allowing the game ai to be modified rapidly without recompiling.
모the ability to produce interesting data-driven ai depends on the expressive power of these scripts. the scripting languages used in games vary widely  and are often customized to meet the specific needs of a game. generally  the more expressive the scripting language  the smaller the number of npcs that can be processed at any given time. figure 1 illustrates this trade-off in existing data-driven games. neverwinter nights  with its versatile aurora  scripting engine  supports intricate behaviors but only for a handful of units. the sims 1  with a more restrictive system for its characters  can support a few dozen sims pursuing their lives' objectives . warcraft iii can support a couple hundred units  but it only allows relatively simple battle decisions for each unit . finally  rome: total war supports thousands of soldiers  but its system is extremely limited  as large groups of soldiers must have identical behavior . if the expressiveness of neverwinter nights were possible in a game on the scale of rome: total war  this would provide new opportunities for gameplay not currently possible.
1 scaling data-driven ai
모our goal is to create a data-driven ai system that is both highly expressive and capable of supporting large numbers of npcs. as the number of npcs with distinct behaviors grows  the maximal complexity of those npcs must decrease to maintain performance. however  when large numbers of npcs are making individual decisions  they may be acting on distinct but very similar sets of information. by treating game ai as a data management problem  we can leverage this fact to dramatically boost performance. in particular  we have developed a new functional scripting language  sgl  scalable games language   that allows us to analyze scripts written by users and to use query rewrite techniques from the database community to factor out expensive function evaluation that is common to a large number of scripts. we use sophisticated query processing techniques to pre-compute the results of these expensive functions and we use indexing techniques to quickly access them within the scripts. this novel type of multi-query optimization in game ai significantly improves performance of the execution of the scripts.
모the language itself is functionally quite similar to those used in existing games  and accessible to game designers. the ai system is designed to fit with typical game architecture without disrupting the usual structure of the other systems. fundamentally  it is simply an optimization and generalization of data-driven ai schemes already employed by developers  and integrating it should be natural for both programmers and designers. as a result  designers are able to add more and more intelligent npcs to their games while retaining the same development processes.

figure 1: data-driven game system architecture
contributions and outline of the paper
모in section 1  we start by describing the basic architecture for data-driven games  and identifying those subsystems for which data management is most important. after this introduction  we make the following contributions in this paper.
  in section 1  we introduce a specific data management problem that must be solved in order to scale games to large numbers of interesting npcs. we also present a case study using real-time strategy  rts  games to analyze the effectiveness of our approach.
  in section 1  we describe sgl  a novel and expressive scripting language for game ai. we demonstrate that the semantics of sgl allows us to process non-player characters set-at-atime instead of individually.
  in section 1  we show how to optimize sgl with rewrite rules and specific query plans. we also present several index structures to efficiently compute a large class of aggregate functions used in games.
  in section 1 we present an experimental evaluation demonstrating the effectiveness of our query optimization and query processing techniques.
we discuss related work in section 1 and conclude in section 1.
1. data-driven games
모loosely defined  a data-driven game is any game that separates the game content from the game code . this design has several advantages. it allows the game studio to separate development between the programmers and the game designers  two groups with important but not necessarily overlapping skills.
모historically  games have long had some form of separation between content and code. media such as character models  textures  or sounds are often kept in data files separate from the game engine. however  recently  the trend has been to move as much game content as possible out of the engine. the data used to define the characters or story-line is increasingly being stored in xml files . modern design even separates logic specific to the game play from the code  through the use of scripting languages; these scripting languages may either be custom tailored to the game engine  or a standard language like stackless python  1  1 .
1 architecture of data-driven games
모while data-driven games may have different architectures depending on their genre  they all have roughly the same design. figure 1 represents the architecture of a typical data-driven game. three different groups of actors interact with this system. the largest group of actors are the game players. they primarily interact with the game through the input and display devices.
모the next group are the game programmers  who have designed the  game engine . the engine is not specific to any one game  and can be reused for other games. in some cases  like epic games' unreal engine 1   the engine may even be licensed to other companies for development. the engine consists of several different generic components common to all games. the rendering and audio engines comprise the media experience of the game. the physics engine is a library of algorithms that simulate physical effects like gravity and collisions. the ai engine is a library of algorithms for solving classical ai problems like pathfinding or natural language processing. all of these are connected together through the discrete simulation engine. this part of the game controls actions of the characters and objects  instructing the rendering and audio engines how to generate output. the discrete simulation engine takes cues from the physics and ai engines  but it is largely directed by the content of the game.
모the game content is created by the game designers. the designers are responsible for creating the game world. this includes a lot of the artistic elements like character models and sounds. however  it also includes any game specific logic. the character objects are stored in data files outside of the game engine. the behavior of these character objects is defined by the character scripts. these scripts are read by either a compiler or an interpreter  and processed by the discrete simulation engine.
모this separation is particularly important for game ai  as character behavior must be constantly adjusted during game testing for reasons of  game balance   i.e. ensuring that there is no single optimal strategy  so that game play does not become monotonous . for example  seven years after its first publication  blizzard continues to update starcraft with balance changes based upon observations of games played on their battlenet server .
모this separation is also important to players  as they can also interact with the content as game  modders . a modder is player who modifies a commercially released game to create a game variant. the new and challenging experiences provided by modders can often extend the lifetime of a game. for example  both starcraft and the subsequent 1 strategy game warcraft iii1 store their game data and ai as scripts in mpq files  a proprietary compression format that is similar to zip. the amai project  has tools for extracting the scripts from these mpqs and replacing them with new scripts to improve the combat ai in warcraft iii.
모games like neverwinter nights and second-life show that user-created content is a vibrant  growing aspect of the gaming world . therefore  we believe that the boundary between players and modders is closing  as more and more games embrace the idea of user-created content.
모while the entire data management layer is an interesting area of research for the database community  our primary focus is the discrete simulation engine; before games can render large numbers of characters  they first must process their behavior. the sims 1 is an example of a game whose performance is determined primarily by the simulation bottleneck. a character in a room with a large number of objects can slow the game down perceptibly  even if the screen is not rendering the room; this is because the game is querying each of the objects in the room to determine which one currently satisfies the character's needs. this performance problem is so significant that the console version of the sims 1 introduced a  feng shui meter  as a gameplay element to keep a player from adding too many objects to a room .
1 the discrete simulation engine
모almost all computer games are architected so that the ai engine processes its objects in clock ticks . in turn-based games 

1
 warcraft iii was the inspiration for the famous massively multiplayer online game world of warcraft  but is not the same game. these ticks are controlled by player input; the game will not proceed to the next tick until the player ends his or her turn. in realtime games  these ticks are controlled entirely by the game  and progress proportional to the frame-rate of the graphics engine.
모each clock tick  the simulation engine processes the actions of one or more characters. each character can perform at most one action per tick  but since we want the number of npcs to be determined by the data and not the game engine  our architecture should allow more than one unit to act per clock tick. a particular action may span more than an a single clock tick  as the game takes time to render the action. however  this is modeled by performing the action in a single tick  and assigning the character a  cooldown  period until it can act again. as a result  some characters may be inactive during a clock tick  as they are still in the cooldown period from their last action. our model will assume that those characters just perform an empty action. therefore  on each clock tick  we process exactly one action for every character in the game. as we show in section 1  characters performing the empty action are eliminated by a selection operation  and so this assumption will not have any adverse effect on performance  given the appropriate index structures.
모each action  in turn  may produce several effects. an effect is simply an update to the data which defines an object. for example  movement is an action that has a single effect - it alters the position of that unit. on the other hand  mortar-fire in a combat game is an action that may affect several units  damaging every npc in its blast radius.
모at each clock tick  the simulation engine reads the data  determines the actions of each of the characters  and determines the effects of this actions  and then updates the game data for the next tick. it is traditional practice in game design that when multiple characters act during a clock tick  they act simultaneously. this keeps the engine from having to read the data more than once during a clock tick  as no action can depend on the action of another character in the same tick. it also allows us to cleanly separate each clock tick into three stages:
  a query stage  where we read the contents of the game data.
  a decision stage  where we choose the actions of each npc based on the data read.
  an update stage  where we update the game data according to the effect of these actions.
모since the actions are all updating the game data simultaneously  we need a transaction model for how these updates are processed. in games  this is relatively easy  because effects typically increment or decrement numerical values in the character data. for example  damage decrements an npc's health value  while healing increments it. games additionally separate effects into stackable and nonstackable. in stackable effects  like damage  all of the effects for that tick are cumulative. for nonstackable effects  only one effect of that kind can apply - typically the most beneficial  or disadvantageous  depending on the context . in warcraft iii  witch doctors can create healing wards that heal all units in a certain range; this is a nonstackable effect as a unit in range of two wards is only healed once.
모this design in games makes the update phase straightforward. we just combine the effects of all the actions  using sum for stackable effects and max for the nonstackable ones  and increment or decrement the data values accordingly. in a few instances  an effect may set some character data to an absolute value. for example  a freeze spell may set a character's speed to 1. in these instances  the effect is given a priority. thus they are nonstackable effects determined by maximum priority.
1. increasing expressiveness in real-time strategy games
모one of the challenges with trying to increase expressiveness in game ai is that it must have a perceptible  positive  effect on the gameplay. while we believe that our approach will apply to all simulation games  like the sims 1   as demonstrated by the number of units in rome: total war  real-time strategy  rts  games are the ideal genre to scale to large numbers of characters1. in these games  a player does not control a single character  but instead controls armies of characters  which are called units. the player controls units by selecting them and issuing commands  which they then execute. however  the way in which a unit executes a command is controlled by the game ai. for example  if a human player instructs a character to attack a specific enemy unit  the game ai may first instruct it to attack other nearby enemy units just so that it can maneuver into range. most of the gameplay consists of issuing a command to a unit  and then scrolling to another portion of the map to command other units  while the first unit executes its orders. thus these games can scale by orders of magnitude without advances in rendering technology.
모because of this gameplay  rts games should ideally have scripts defining the behavior of each individual. a player wants a unit to execute its command correctly without further instruction; that way the player can issue commands to large numbers of units  effectively controlling massive armies. however  unit behavior in rts games is relatively primitive; they are typically modeled as simple finite state machines . as a result a player must directly control the units if there is to be any coordination between units. for example  a standard tactic in strategy games is to have archers stay behind armored troops in order to protect them; if the armored troops move  the archers need to move as well to retain their cover. even achieving this relatively simple level of coordination requires the human player to neglect all other troops and repeatedly issue instructions to these two.
모the problem is that processing individual ai scripts can be very expensive as each unit is typically processed separately. game ai is a main efficiency bottleneck in such games. suppose the game designer wants a certain type of unit to run in fear from a large number of marching skeletons. if the number of skeletal troops is on the order of n  the total number of units  then it takes o n  to count the number of skeletons. furthermore  if all the units can see the skeletons  then each unit performs an o n  count aggregate  for a total time of o n1  to process all of the units.
1 processing units as a group
모the typical solution to this problem in rts games is to handle all coordination in centralized ai scripts. in centralized ai  a script controls the actions of a large number of units. for example  each computer player in warcraft iii has two invisible commanders to control all the units: one for attacking  and one for defense. centralized ai controls units by querying the environment  and then issuing a simple command to each unit. this solves the problem in our skeleton example since the centralized script can count the number of skeletal troops in o n  time and issue the  run away  instruction to each unit again in o n  time.
모however  centralized ai has three major problems. because one script controls all of the units of a faction  it is difficult to write scripts that control more than one geographic cluster of units at a time. the limitation of warcraft iii to two commanders means the computer is unable to defend and fight a multiple-front war at the

1
 while massively multiplayer online games have more characters  relatively few interact with each other at any moment.
same time; human players use limitations like this to their advantage. another problem is that it is difficult to separate individual behavior from herd behavior. when the centralized ai script sees the skeletal warrior  it issues the run away command to all units. thus the units flee uniformly  ignoring issues such as which units can see the skeletons. changing the centralized script to account for this makes the script harder to design and read.
모most importantly  however  centralized ai is really only designed to run the computer player. it is of no help to the human player because he or she controls individual units  and not a central commander. therefore  sophisticated individual ai scripts would be a massive improvement to rts games.
모note that centralized ai is a crude form of set-at-a-time processing  explicitly implemented by the game designer. the designer knows that all of the units will compute the same aggregate and places this in the centralized script. however  it should not be necessary for the game designer to do this explicitly. if we construct a scripting language that allows us to use sophisticated rewrite rules to group calculations together  then we can do this in the script compiler.
모the primary difficulty in designing such a query language is iteration; if the language only has conditionals  we can easily convert our language to a declarative language like sql and optimize it accordingly. fortunately  an analysis of the scripts in rts games like warcraft iii  reveals that iteration is only used in the following contexts.
  computing an aggregate value about a set of units or the local environment. examples include summing up the strength of visible units  or finding the weakest unit in range.
  applying an update to a set of units or the environment.
  processing an array whose size is fixed and determined at compile time  e.g. an array representing the  strength  of each troop type in warcraft iii .
  reimplementing functionality that exists already in the game  but is not open to modders  e.g. the pathfinding algorithms in the amai file common.eai  .
the first two cases can easily be handled by a declarative language. the third case is also either an aggregate computation or an update to the array  and can be processed similarly. the final case is simply a matter of opening up more of the api to the scripting language  which is an orthogonal problem. therefore  we can get the most important functionality of these scripting languages with a purely functional language with aggregate functions on sets. at each step  the ai script performs a declarative query on the environment and uses the result to perform an update. we define this language explicitly in section 1.
모to provide true individualized behavior  it is not enough that our optimization pull out common aggregate expressions. for example  the units counting the number of skeletons may not be able to see exactly the same number of skeletons. however  if the units are clustered together - as they normally are in combat - the skeletons they see should overlap. to take advantage of this overlap  we would like to construct indices that efficiently compute the number of skeletons for each visible region  and process each script as a look-up in this index. however  the type of index that we make depends heavily on the type of aggregate and our query plan. we investigate this further in section 1.
1 case study: a battle simulation
모rts games have non-combat aspects to them such as economics and building. however  in these games these aspects are highlyabstracted and do not feature large numbers of individuals. therefore they are relatively easy to process. hence  we will evaluate our approach by focusing on the combat simulation of an rts.
모our battle simulation is structured like that of the typical rts. the state of each unit consists of at least three values: the x and y position of the unit  and its health. health is modeled as an integer; when it is reduced to 1  the unit is dead and is removed. there are only three types of actions: a unit can either move  to change its x and y value   damage an enemy unit  reducing its health   or heal a friendly unit  restoring its health . which of these actions are available depends on the type of the unit.
  knights: these units can only move and attack. they are armored  and hence take less damage from the attacks of others. they also do the most damage in their attacks. however  they can only attack units that are in arm's reach.
  archers: these units can only move and attack. unlike knights  they are not armored  so they take more damage from the attacks of others. their arrows also do less damage than the swords of the knights. however  they have a much larger range in which they damage an enemy unit.
  healers: these units can only move and heal. like archers  they are not armored  and so take more damage from the attacks of others. they heal units by casting a  healing aura  that restores health to all friendly units within the circle of this aura. the health of a unit can never be restored beyond the initial health of the unit. healing auras are nonstackable  so a unit can only be healed once per clock tick.
모for modeling specifics such as determining damage  the effects of armor  and so on  we use the game mechanics in the pen-andpaper d1 system. this system is the foundation for all computer game combat simulations  and thus is a reasonable model. this system has the added advantage that its rules are not designed according to the limitations of computer games. in warcraft iii  a typical unit can only see an area capable of holding 1 other units. therefore  processing a query like  count the number of skeletal units  is really just o 1  with a large constant. on the other hand  visibility in the d1 system allows characters to see and make judgments about areas containing up to 1 other units. thus these mechanics allow for interesting scaling to large numbers of units.
모in our case study  we want our scripting language to support interesting coordination between units. for example  we want the archers to use the knights as cover. to do this  the scripts compute the centroids of the enemy  the knights  and the archers  and moves the archers so that these three points are in a line with the knights in the center. as another example  we want the knights to close ranks to keep the enemies from going through. to do this the knights compute their approximate density by computing the standard deviation of all the troop positions  and then counting the number of troops in two standard deviations. if they are too spread out  they move towards their centroid.
모in general  our scripting language will support a much larger class of aggregates than these examples. however  they are enough to exhibit interesting behavior not found in current rts games. furthermore  they will serve as useful examples when we define our language in the next section.
1. the sgl language
모our game data is abstractly modeled as a relation e. we assume that this table is a multiset; it need not have keys. each row in the table represents a unit or object  and contains information such as the unit's health  speed  attack damage  and so on. it may also include data representing messages from other units of the system  like the pathfinding subsystem  or the time remaining in the unit's cooldown period.
모the language sgl  scalable gaming language  is a scripting language for specifying individual unit behavior. an sgl script represents a single action for a single unit. informally  an sgl script is a function that  at each clock tick  takes the environment e and returns a new environment table eu. however  since there are several individuals acting  we need to be able to combine the environments eu to produce the final environment at the end of our clock tick.
모we do this by separating the schema of e into attributes representing the state of the each unit and the attributes representing the effects on the unit. for example  one possible schema for our battle simulation is
e key player posx posy health cooldown  weaponused movevectx movevecty 	 1 
damage inaura 
the attributes key ... cooldown in  1  represent the state of the unit. these attributes cannot be modified directly by an sgl script. the remaining  auxiliary  attributes represent the effects applied to the unit  such as how far the unit will move  or the strength of the nearest healing aura. these are the values altered by an sgl script; we combine these values together to calculate the final effect on each unit using the rules outlined in section 1.
모only once we have combined all of the individual environments eu together into a single environment do we actually apply the effects and change the state of the units. this is done by a postprocessing step outside of the sgl scripts  and is considered as part of the game mechanics.
모example 1. for the schema in  1  the post-processing step consists of performing the following sql query to get the new environment.
select u.key  u.player 
u.posx + u.movevect x * norm as posx 
u.posy + u.movevect y * norm as posy 
u.health - u.damage + u.inaura as health 
u.cooldown - 1
+ u.weaponused* time reload as cooldown 
1 as weaponused 
1 as movevect x  1 as movevect y 
1 as damage  1 as inaura
from e u
모모where u.health   1; # remove the dead where norm is a shortcut forwalkdistpertick / sqrt u.movevectx1 + u.movevecty1 . for example  at the end of the tick  we take the total damage done to a unit and subtract it from the health  as well as restore the amount provided by the healing aura . it is also at this point that we remove units with 1 health from the table.
모we spend the rest of this section formalizing this processing model so that we can optimize it in section 1.
1 syntax of sgl
모informally  sgl scripts consist of sql together with conditionals  if-then-else statements   let-statements to  temporarily  add new attributes to the current unit  and a special keyword perform for invoking other scripts or applying built-in actions. a perform statement specifies an update to the environment. to help with readability  the programmer can decompose a script into several functions.
모because individual unit behavior must be tailored to the unit  each ai script has access to the current unit tuple u  which holds its own state  from the environment. furthermore  it has a function random for generating random values. to get a random number  the script provides a number as a seed. for any number i  random i  will always return the same number within a single clock tick  but not necessarily between clock ticks.
main u  {
 let c = countenemiesinrange u u.range    let away vector =  u.posx  u.posy  -
모모모모centroidofenemyunits u  u.range   { if  c   u.morale  then
모perform moveindirection u away vector ; else if  c   1 and u.cooldown = 1  then
 let target key = getnearestenemy u .key  { perform fireat u  target key ;
} } }
figure 1: an sgl script
in detail  the syntax of action functions is given by the grammar
action ::    let attributename = term  action action; action
if cond then action if cond then action else action
|perform actionfnname
 conditions are boolean combinations of atomic conditions. atomic conditions are comparisons of two terms  using =     뫞  =  . terms are constructed using arithmetics over constants  attributes of the unit  random numbers  and aggregate functions.
모example 1. figure 1 shows an example of a simple script that fires an arrow if there is a unit in range  but runs away if there are too many enemies. if neither case is true  or it is waiting on the weapon cooldown  then it does nothing. note that
countenemiesinrange  centroidofenemyunits  and nearestenemy are all aggregate functions that compute a value from e. the functions moveindirection and fireat  on the other hand  are action functions and update the environment. these functions are provided as sgl built-ins  but we show how to define them explicitly in section 1.
1 combining effects in environment tables
모as we described in section 1  the way in which we combine effects depends on whether they are stackable or nonstackable. therefore  we tag the attributes of our environment e to keep track of how we combine effects on this attribute  i.e. sum for stackable effects  min or max for nonstackable effects . formally  our environment e has schema e k a1 ... ak . each attribute ai of e is tagged as the type 뷉i which is either const  max  min  or sum. attributes of type  const  never change and can never be the direct subject of an effect; the type of k is always const. for example  in the schema in  1   the first line of attributes are all of type const. the attribute inaura has type max  since healing auras are not stackable; all other attributes have type sum.
모to combine output of the sgl scripts  we define a combination operation  on a relation r whose schema r k ai1 ... aim  is a subschema of that of e. we let k ai1 ... ail be precisely the const-typed attributes of r. we define r as
select k  fi1 ai1  as ai1 ... fim aim  as aim from r group by k ai1 ... ail;
where  abusing notation and identifying type 뷉j with the aggregate function of the same name 
	fj aj  :=aj	...	뷉j = const	 1 
	뷉j aj 	...	otherwise
when attribute k is a key for table r  we will sometimes write r to highlight this; note that in this case r = r. we use r  s as a shortcut for  where  denotes the multiset union operation.
모because  is defined in terms of min  max  and sum  it is associative and commutative. furthermore  given two environment tables e1 and e1 
	.	 1 
in the case e1 =    this in particular implies idempotence of the combination operator    e1   =  e1   and by applying the equivalence twice we obtain.
this property will be useful in generating our query plans.
모example 1. if the schema in  1  is tag with types as described above  then
select key  player  posx  posy  health  cooldown  max weaponused  as weaponused  sum movevect x  as movevect x  sum movevect y  as movevect y  sum damage  as damage  max inaura  as inaura
from e
group by key  player  posx  posy  health  cooldown computes the environment 뇬.
1 semantics of sgl
모the goal of the sgl language is to support the specification of character actions. it is intended to be expressive  but to have a simple semantics that can be easily mapped to query evaluation techniques nevertheless. for this reason it is a functional language with a somewhat imperative surface syntax. each expression in our language is called an action function.
an action function is a function of signature
f : env 뫄 multiset env  뫄 1env뫄n뫸n 뫸 multiset env 
for some constant c. thus an action function takes
  a tuple from the environment table  the current unit  
  the environment itself  and
  a function that maps any pair consisting of a tuple from the environment and a natural number to a natural number
as input and returns an updated environment table. the function env 뫄 n 뫸 n is used to simulate random numbers inside our functional language.
모the semantics of sgl action functions is given by the semantics functions   몫      몫  cond    몫  term for action functions  conditions  and terms  respectively. we define this semantics as follows
   let v := t  f  e r u 	:=	  f  e r u v :   t  term u e r  
	  f1;f1  e r u 	:=	  f1  e r u     f1  e r u 
  if 뷋 then
	  perform g  e r u 	:=	  g  e r u 
	  perform h  e r u 	:=	h u e r 
 where f1 f1 and g are sgl action functions  g is the name of defined function g  h is the name of built-in action function h  and v is an attribute not yet present in record u. we will consider if 뷋 then f1 else f1 a shortcut for if 뷋 then f1; if  뷋 then f1. note that our definition of let means that we extend the current unit record by value of term t.
모the semantics of conditions   몫  cond commutes with the boolean operations  and   몫  term commutes with the usual arithmetic operations. there are only three interesting types of terms. we define an attribute access in a tuple by   u.v  term u e r  = u.v. our random function is defined as   random i   term u e r  = r u i ; finally  for an aggregate function name a we assume that
function countenemiesinrange u  range  returns select count * 
from e
where e.x  = u.posx - range and	e.x  = u.posx + range
	and	e.y  = u.posy - range
	and	e.y  = u.posy + range
	and	e.player    u.player;
function centroidofenemyunits u  range  returns
select avg x  as x  avg y  as y
from e
where e.x  = u.posx - range and	e.x  = u.posx + range
	and	e.y  = u.posy - range
	and	e.y  = u.posy + range
	and	e.player    u.player;
figure 1: aggregate function definitions
there is an external functionand we define
  a   u e r  := a u e r .
모while the built-in aggregate and action functions could be arbitrary computable functions of appropriate signature  it appears that in practice it causes no loss of generality to assume that they are expressible in sql  more specifically of the following form.1
  each built-in action function h u e r  is of the form
select e.k  h1 u e r  as a1  ...
	hk u e r  as ak	 1 
from e e where 뷋 u e r .
  each built-in aggregate function a u e r  is of the form
select a1 h1 u e r    ...  ak hk u e r  
	from e e where 뷋 u e r .	 1 
here the tuples u and r are assumed to hold constants  h1 ... hk are terms over u  e  and r  and a1 ... ak are sql aggregates.
모figure 1 shows definitions of the aggregates used in the sgl script of figure 1 and figure 1 defines some built-in action functions  both using the sql fragments indicated above.
모to process a complete sgl script  each script has a main action function called main. given a function 뷈 : e 뫸 e 뫸 n 뫸 nc  the semantics of an sgl script is
	tick e 뷈  := main눥  e   e	 1 
where  here and in the following  f뷈 e  is a shortcut for
	  {  f  e 뷈 u  u  | u 뫍 e} .	 1 
the function 뷈 contributes the random element to the evaluation of the script. note  however  that this formalization is completely deterministic. since below we will only discuss the computation done within a single tick  we usually omit the subscript 뷈 and simply write f. further note that f is a unary relational operation.
모now that we have our formal definitions  we review our processing model once more. in a single tick  the processing model first initializes the auxiliary attributes introduced by the scripts. then it produces the environment table eu for each script  which encodes the effects but does not apply the effects. these all combined into a single table tick e 뷈 . finally  we apply effects using a special post-processing query defined by the game mechanics as shown in example 1.

1
 for example  the warcraft iii common.ai can be fully expressed under these restrictions.
function fireat u  target key  returns
select e.key e.player e.posx e.posy e.health 
e.cooldown  1 as weaponused 
e.movevect x  e.movevect y 
e.damage+  arrow hit damage -  armor  *
 random e 1  mod 1  as damage 
e.inaura
from e e
where e.key = target key;
function moveindirection u  x  y  returns
select e.key e.player e.posx e.posy e.health 
e.cooldown  e.weaponused  x - e.posx as movevect x  y - e.posy as movevect y  e.damage  e.inaura
from e e
where e.key=u.key;
function heal u  returns
select e.key e.player e.posx e.posy e.health 
e.cooldown  e.weaponused 
e.movevect x  e.movevect y  e.damage  nonsql max e.inaura  heal aura  as inaura
from e e
where u.player = e.player
and	abs u.posx - e.posx     healer range and	abs u.posy - e.posy     healer range;
figure 1: action functions implemented in sql
1. query optimization
모in this section we address the efficient processing of sgl scripts using data management techniques. we first show how sgl scripts can be translated in a natural way into a relational algebra-like language. then we discuss the algebraic optimization of such queries and the determination of query plans including the use of indexes. finally  we give efficient algorithms for computing index structures for aggregate functions and area-of-effect actions which in total improve the running time of tick   from time o n1  to o nlogd n   where d depends on the query plan.
1 bag algebra
모we use a fragment of the relational algebra on multisets  using operations projection 뷇  selection   product 뫄  and multiset union   extended by a combination operation . the multiset algebra operations are defined by a mapping to sql:
	훥 r 	:= select * from r where 뷋;
 select  as b from r;
	r 뫄 s	:= select * from r  s;
모모모 r union s; agg	select 
from r group by a;
here stands for f1   asb1 ... fn   asbn  where the fi are terms built using the attributes of the input relation  constants  arithmetics  and external functions  and each gi is an sql aggregate function  e.g. min  max  count  sum  avg .
모the natural join 	is defined in analogy to relational algebra using the above multiset operations. below  we will use algebraic expressions interchangeably with sql queries. we will only apply the natural join on pairs of relations whose schema overlaps on exactly the attribute k  and use the notation to make this clear.
	뷇1. 1. 	뷇1. 1. 
	act	act1	1	act	1
	뷇  agg    	  agg1   	뷇  agg    	  agg1   
		
뷇  agg    
	e	e	e	e
	 a 	 b 	 c 	 d 
figure 1: example query plans. example 1 translates  a  via  b  and  c  into  d .

figure 1: some rules involving denotes extended environment relations.모we assume that sgl scripts are in a normal form in which aggregate functions only occur in let-statements  but in no other terms. it is easy to see that this is a normal form for sgl and that this assumption causes no loss of generality. for example  if agg u.health  = 1 then f is equivalent to  let v
= agg u.health   if u.v = 1 then f.
모by the following translation  each sgl script can be turned into an equivalent expression in our algebra.
모모모모  f1;f1   e  =   f1   e     f1   e    if 뷋 then f   e  =   f   훥 e  
   let .
these translations follow immediately from the sgl semantics definition. using these equivalences  we can rewrite the overall semantics function tick    see eq.  1   into an expression of our bag algebra. note that extensions of the schema of an environment relation effected by  let  add untyped columns  which however are eliminated by the built-in action functions. these by definition always return environment relations of schema k a1 ... ak.
모if the built-in action function fi u e r  is in the fragment of sql specified in eq.  1   we can express fi r  in our algebra as
 뷇e.k g1 ... gk 훥i r 뫄 e   .
each aggregate of the form of  1  applied to a set of units e1 can be written in the bag algebra as 뷇u fa u  e1  := agg
which can also be computed by an index nested loop join indagg e  with a precomputed index structure indagg e  = agg. the efficient computation of such index structures is discussed in section 1.
1 algebraic optimization
모we can now rewrite the queries obtained from sgl scripts using the algebraic laws that hold in our algebra. these are to the greater part known from relational algebra1  but some additional rules hold for  and its interaction with the other operations.
모example 1. consider the script of figure 1. for clarity of exposition  the names of aggregation functions  built-in action functions  and conditions are abbreviated as agg1 agg1 agg1  act1 act1  and 뷋1 뷋1  respectively.  the ordering is as they appear in the script. 
모by our rewrite rules that take sgl to our algebra  we obtain the query plan of figure 1  a . this query plan is actually already quite good. while the sgl script suggested an evaluation one unit at a time  the query plan employs set-at-a-time processing.
모one optimization that we can achieve is to push 뷇  agg1    up across the selections. in the right branch of the expression  agg1  in the form of the attribute awayvector  is not used and can be removed. the aggregate index for agg1 will only have to be computed for the units that satisfy condition 뷋1. we obtain the query plan of figure 1  b .
모next we optimize the combination of the result of main with e. this combination takes place to ensure that each unit in e is also present in the result even if no action is taken on this particular unit in the current tick. there are two actions being carried out  moveindirection or fireat. the first modifies each of the units on which it is applied; for these units we do not need to combine with e.
this optimization can be effected as follows.
1. using rules  1    1   and  1   we can turn the plan of figure 1  b  into the plan of figure 1  c .
1. by definition act is of the form

which can be simplified to. but then
act.
this yields the plan of figure 1  d . 1
 for the monotonic operations that we introduce - those that do not perform aggregation - the laws are basically the same as for relational algebra with set semantics.
1 indexes and geometric algorithms
모as we saw in section 1  the most expensive part of a unit's script is often the processing of the aggregate functions. if every friendly unit is processing the aggregate to count the number of skeletal warriors  and all the enemy units are skeletal warriors  then the naive computation is o n1 . as we noted in the previous section  we can optimize this behavior by sharing the computation for agg across several units and processing 뷇  agg    with an index nested loop join. of course  to do this  we have to be able to construct the index for the aggregate.
모our choice of index structure does not just depend on agg. it also depends on the selection 훥; this selection appears outside the join in our index look-up optimization. for example  the index structure to count the number of skeletal warriors is not the same as the index structure to count the number of units belonging to the blue player.
모in traditional databases  it would be prohibitively expensive to create indices for each individual query plan. however  sgl queries do not change rapidly over the course of the game; the player issues a command  and that command performs the same query for many clock ticks. in that regard  sgl queries are similar to continuous queries in streaming databases. we can afford to construct an index specifically tailored to each query plan.
모note that our indices are used to share computation between units  not between clock ticks. it is usually the case that the number of index probes in each clock tick is comparable to the number of entries in the index. therefore  we are still likely to see significant performance gains even if  at each clock tick  we discard the index and build a new one from scratch. for data that is updated often - such as unit positions - it may even be more efficient to do this than to maintain a dynamic index.
모in constructing our indices  we assume that 뷋 is a conjunctive query. this is commonly the case in games and is evident in all of the aggregate queries in amai file common.eai . moreover  it is true for all of the examples in this paper. given this assumption  we can ignore those conjuncts of 뷋 that are not part of joins. for example  suppose we want to count the number of moderately wounded units  without regard to location . we typically define a unit u as moderately wounded if u.health   1*u.maxhealth. this particular selection can be pushed into the index nested loop join  and so we do not have to consider it when building the index. on the other hand  if we want to count the number of visible enemy units  then determining whether an enemy unit is visible requires both the position of the enemy unit and the position of the unit performing the query. thus this selection condition must be factored into the index.
모given that we have reduced 뷋 to those conjuncts necessary for the join  we now present index structures for aggregates commonly found in games. these aggregates include all of the ones in our examples  as well as ones that appear in the scripts for warcraft iii.
1.1 orthogonal range queries
모the most common type of selection condition 뷋 in a game script is an orthogonal range query. conditions such as whether the unit can penetrate the armor of the enemy or can move faster than the enemy are inequalities comparing one value to another. for categorical data  this may be a degenerate range query  such as determining if a unit is of a certain type. even determining if a unit is in range can be an orthogonal range query. for performance reasons  games often choose to use rectangles  not circles  to determine area of effect as is demonstrated in figure 1. this is evident by the prevalence of functions in the ai scripts for warcraft iii that select units in a rectangle  like groupenumunitsinrect  . other games optimize by using circles with an l1 norm; however  these are just squares rotated 1  and so they can be modeled as orthogonal range queries as well.
모in the case where all of 뷋 is an orthogonal range query  we can process it with a layered range tree . we order the levels of the layered range tree according to the volatility of each axis. attributes that do not change often  such as the type of the unit or its maximum health  form the top layer of the index  while data that is constantly updated  such as position  is at the bottom. this way we can reuse as much of the index as possible across clock-ticks. in particular  we can preserve the upper layers that do not change  but dispose of the lower ones  which do.
모we can build a layered range tree in o nlogd n  time  and for each unit  we can enumerate those elements that satisfy 뷋 in o logd n + k  time  where d is the dimension of the orthogonal range query and k is the number of elements selected by 뷋. in determining the dimension d  we can ignore all degenerate  i.e. categorical  range components  as those levels of the tree can be replaced by a hashtable with o 1  look-up. as we mentioned above  it is not necessary for this index to be dynamic  see  for the additional cost of dynamic algorithms . therefore  we can use fractional cascading  to reduce the time to o nlogd 1 n  and o logd 1 n + k   respectively.
모however  a layered range index by itself still does not give us the performance we want. if the units are all clustered together  as is often the case in combat  then the value k in o logd 1 n + k  can be significantly large. if k is close to n  then the join will still be o n1 . however  recall that we are not actually interested in the orthogonal range query 뷋. what we really want is the value of agg on the elements returned by this query. if k is large  then there will be a high degree of overlap between the elements selected for each unit  and so we can share this computation in computing the aggregate.
모we do this in one of two ways  depending on the nature of agg. the simplest case is when agg is divisible.
모definition 1. an aggregate agg is divisible if there is a function f such that agg a   b  = f agg a  agg b  
whenever b   a. the aggregate sum is an example of such an aggregate  since sum a b  = sum a  sum b  whenever b   a. the aggregate count is also divisible  as are all the statistical moments. however  min and max are not.
모when the aggregate agg in 뷇  agg    is divisible  we can improve the performance by replacing the last layer of the layered range tree with an index that contains the aggregates  not the elements. for example  suppose we have an orthogonal range query on just the position of the units. normally  we would construct a layered range tree on the x and y values; assume for the purposes of this example that we layer these ranges x then y. in this layered range tree  each x node would contain the y-index of nodes with x values in that range. however  instead of placing the units at the leaves of the y-index  we put the aggregate value of all of units whose y value is less than or equal to the value at that leaf. this idea is illustrated in figure 1. the fact that our aggregate is divisible means that we can recover the aggregate of any range in a fixed number  1d  of queries of the tree. furthermore  this technique is compatible with fractional cascading. therefore  in this case  we can compute the index nested loop join for 뷇  agg    in time o nlogd 1 n   where d is the number of continuous attributes in the orthogonal range query. this is a definite improvement over o n1 .
모many of the aggregates in our case study in section 1  such as centroid or the number of units  are divisible aggregates over orthogonal range queries. the amai file common.eai contains

figure 1: divisible aggregates in a layered range tree
other examples  such as the use of sums weighted on troop type to measure the strength of an army. in some cases  such as our centroid query  the aggregate is really a tuple of aggregates over the same selection 훥. in that case  we can combine these aggregates into one index structure by replacing the list of aggregates in figure 1 with a list of aggregate tuples.
모however  two very important aggregates - maximum and minimum - are not divisible. these aggregates are necessary for queries such as finding the weakest  i.e. least healthy  unit in range. for these aggregates  we cannot use the technique illustrated in figure 1 to get rid of the value k in the o logd 1 n + k  look-up for an orthogonal range tree.
모one option is to build a multi-resolution aggregate tree  for the entire space  and then query this tree for each unit. unfortunately  these trees return only approximate results  and there is no guarantee on their query performance. however  there is another possible optimization. in many instances  the size of the range will be constant in one of the dimensions of the orthogonal range query. for example  units of the same type all have the same weapon and visibility range. if  as before  we assume that this visibility range is represented as a box  this means that all of these units have the same size for their x and y range queries. when this is the case  we can compute max and min using a sweep-line algorithm . in two dimensions  the procedure is as follows:   choose an axis for which the size of the range is constant. call this axis y and let the size of the range be r.
  construct a binary tree ordered on the remaining axis x.
  use this tree to perform a variant of a sweep-line algorithm on axis y.
- initially annotate each leaf of the tree with a default value:  for min or   for max.
- sweep with a range of r. when a unit moves into range r  replace the default value with the actual value. when a unit reaches the center of the range  use the tree to compute the aggregate within the unit's x range  this takes o log n  time . when a unit moves out of the range r  replace the actual value with default value   or   .
- at each step of the sweep  percolate any changed leaf values up the tree so each interior node is labeled with the aggregate of its leaf descendants.
모this technique is illustrated in figure 1. the technique generalizes to d dimensions  with performance o nlogd 1 n   a total of n items enter and exit the sweep  and it costs o logd 1 n  time to percolate the aggregate values for each unit that enters or exits.

figure 1: sweep-line of min on constant region size
1.1 spatial aggregates
모while many of our aggregates are p  max  and min on orthogonal range queries  not all of them are. for example  we frequently use the aggregate that returns the nearest unit. the amai file common.eai contains other interesting spatial aggregates  like searching for the unit that can reach location  x y  in the shortest amount of time. many of these aggregates have been studied extensively in the area of computational geometry  and there exist specialized indices designed to solve many of them quickly. for example  an efficient way to find the nearest unit is to use a kdtree . designing these types of indices is beyond the scope of this paper.
모however  note that for many of these spatial aggregates  the nonspatial part of the query is still an orthogonal range query. we do not just want the nearest unit; we want the nearest unit that is an archer  or the nearest unit whose armor we can penetrate. therefore  to process these type of queries  we place the spatial indices as the lowest level of a layered range tree. for example  to find the nearest unit whose armor we can penetrate  we create a tree for the armor values  and attach a kd-tree to each node in this tree. this structure can be created in o nlog1 n  time and space; each probe requires o log1 n  time.
1 processing the combination operator
모the combination operator  serves two purposes: it allows us to combine different types of effects  and it allows us to combine several effects of the same type from different actions. when we look at  in the latter case  we can view  as an aggregate. indeed  this is often the definition of . for example  in the case of attacks   sums up all of the attacks on each unit to determine the total damage to apply. in this case of a nonstackable effect like our healing aura   computes the maximum aura for each individual  so that we can perform that much healing.
모for many actions  the effect of the action only applies to a single unit. each move action only effects the unit itself; each archer can only fire at some target. however  some actions  like the healer's healing aura shown in figure 1  can affect multiple units. in this case  we again may need to be concerned about o n1  behavior; if roughly n units perform area of effect actions that apply to n units  then combining them is o n1 . in practice  this is unlikely. for reasons of game balance  while unit observations cover large areas  the area affected by an action is typically very small. there are exceptions to this rule  like the nuclear weapons in starcraft;

모모모figure 1: comparison of naive versus indexing however  only one nuclear weapon can be fired per clock tick  so this not an example of o n1  update behavior.
모with that said  our goal is to have a processing model that is generic enough for scaling games of the future  not just games of the past. therefore  we want to optimize  so that it is as efficient as the rest of our operations. if  is just attribute-wise sum or max  as is commonly the case in games  then we can optimize this operation further.
모we observe that all area-of-effect actions of the same type commonly have the same range. for example  all healers exude an aura of the same size. this means that determining all of the units in the range of an effect is the same as fixing a range and determining all of the effects in the range of each unit. therefore  to optimize   we arrange our query plan to group together all actions of the same type. for each such action we construct an index that contains their centers of effect. applying  now consists of performing an aggregate on this index; for stackable effects this action is sum  and for nonstackable effects it is max. hence we can use the techniques of section 1 to perform this optimally.
1. experiments
모to validate our ideas we have built a preliminary version of the discrete simulation engine component of the data-driven game system architecture as described in section 1. this is not  yet  a general framework - the index structures we build are tailored to the particular game example we have chosen - but it demonstrates that our techniques are practical and can greatly increase the scalability of a game engine.
모for our tests  we built a faithful implementation of the battle simulation game described in section 1. every npc unit executes a simple but decidedly nontrivial script. on each clock tick  each unit evaluates about 1 aggregate queries. many of these are divisible aggregates  like  count the enemy archers  or  compute the centroid of enemy troops in my region   others are nearest-neighbor queries  like  find the nearest healer   and a few are min queries  such as  find the weakest unit in range. 
모there are two  pluggable  versions of our aggregate query evaluator. one executes aggrate queries naively  using straightforward o n  algorithms  for a total cost of o n1  per tick. the other uses in-memory indexing as described above to reduce the complexity to o n log n   per epoch.
모all divisible queries  count  sum  higher moments  are implemented using a layered range tree with fractional cascading. all such queries share the same range tree. since the game has only two players and three unit types  we push selection on player and/or unit type to the top  giving us a total of 1 range trees-one for each player/unit type combination - to implement all the divisible aggregate queries. these six trees are completely rebuilt for each tick.
모nearest neighbor queries are implemented with a kd-tree. again there is one such tree for each player/unit type combination. the kd-trees share some structure with the range trees. max style aggregates are implemented using the sweepline technique discussed in section 1.1. we sweep in the y direction  and share the toplevel  x-sorted  tree of the layered range tree to implement an o log n  dynamic interval aggregate index. all the data structures share the work of  re- sorting the units by position at the beginning of each clock tick. processing for each clock tick proceeds in several phases:
  a preliminary index building phase  in which we build most of indices described above to support aggregate queries in the next phase.
  a decision phase: each unit evaluates a number of aggregate queries and decides on its next action  possibly setting some per-unit state. for example  there is a per-healer variable that is set to the amount of healing energy the healer wants to broadcast in this tick.
  a second index building phase  which can depend on values generated during the decision phase. for example  a sweepline implementation of  max healing in range  is done in this phase.
  an action phase  for example to determine the result of an attack.
  a movement phase: units attempt to move in directions they have decided on earlier. this is done in random order  with collision detection and very simple pathfinding rules.
모to facilitate our experiments  and since we wanted to measure performance faithfully   we added a simple rule to prevent the game from finishing prematurely: whenever a unit dies  it is  resurrected  at a position chosen uniformly at random on the grid.
1 results
모our engine is written in c++  and we compiled it using gcc on macos x. we ran our experiments on a 1ghz intel core duo with 1 gb of ram. timings were obtained simply using the macos  time  command running the simulator with a given set of parameters. the number of clock ticks simulated has been chosen to be high enough that setup time is negligible. the times reported are the number of seconds of real time required to simulate 1 clock ticks on an otherwise unloaded machine. these numbers are repeatable  and are proportional to the number of ticks simulated  to within one percent. thus  we do not provide error bars.
scalability with the number of units. for both the naive and the indexed strategies  we ran experiments varying the number of units  and varying the size of the playing grid to maintain a constant density of 1 percent of game grid squares occupied. the results are shown in figure 1. the quadratic behavior of the naive algorithm is clearly evident. note that the overhead of index construction is quite low: the indexed algorithm dominates the naive algorithm even for very small numbers of units  and it is an order of magnitude faster by 1 units. if we assume a game engine should be able to simulate at least 1 clock ticks per second  the naive system does not scale to 1 units on this processor  while the indexed system scales to more than 1 units.
varying unit density. for both the naive and the indexed strategies  we ran experiments fixing the number of units at 1  and varying the unit density between 1 and 1 percent. neither algorithm is particularly sensitive to this parameter; we omit the full results due to space constraints.
모in summary  our experimental results show that our techniques are very successful  leading to an order of magnitude improvement in capacity on current hardware.
1. related work
모to the best of our knowledge  this is the first paper to treat computer games as a data management problem  with its own set of problems and solutions. previous work on games in the academic literature has focused on classic ai problems  such as machine learning and pathfinding  or on network issues  such as jitter and latency. papaemmanouil et al.  have examined the issue of message dissemination in games; however  this work is part of a general study of overlay dissemination trees  and does not address the specific needs of games.
모work in the game developer literature  on the other hand  has focused on leveraging database systems to solve problems in games. tozour  has designed a game architecture that uses spatial databases to aid the ai engine in runtime spatial analysis. in the case of classic board games like chess  databases are used to manage a knowledge base for strategy evaluation . however  most of this work uses existing technology  and does not suggest new areas for data management research.
1. conclusions
모innovation in game design occurs in tandem with innovations in game architecture. the upcoming game spore  is a perfect example of this. spore is able to provide players with an unprecedented level of character customization by leveraging the power of new techniques for procedurally generating animations. at the surface  those new techniques are a means to increase the effectiveness of development in traditional settings  offloading the burden of art creation to the game code. when used to their full potential  those techniques enable a new gameplay paradigm.
모the power of our ai architecture follows this two-fold path as well. it enables existing development to be greatly enhanced with substantial performance improvements  but also opens up possibilities for new kinds of games. given a robust  expressive ai system that is individualized rather than centralized  developers are free to expose that ai to the player in ways previously not possible. games could be made where the central player experience is about creating an exciting game experience through interesting ai.
모restricting the expressive power of the player is a relic of traditional computational limitations. with our ai architecture that supports expressive ai without reducing the number of characters  developers can enable much more sophisticated choices for players. players will then be empowered by the game's ai  instead of hindered by it.
