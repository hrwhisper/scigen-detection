1.	the bp-mon system
　the bp-mon  business processes monitoring  system presented in this demonstration addresses these issues. it makes the following contributions.
query language the system is based on an intuitive graphical query language that allows for simple description of the execution patterns to be monitored. a tight analogy between the graphical interface used by commercial vendors for the specification of bp and our graphical query interface allows intuitive design of monitoring tasks. the execution patterns in bp-mon extend string regular expressions to  nested  dags. they can describe sequential and parallel execution of activities  possibly with repetitions and/or alternatives  and allow to indicate the granularity levels to be employed for different components of a monitoring task. the bp-mon reporting facility allows to notify users of occurrences of the monitored patters  report relevant data  including relevant execution paths   and possibly invoke corrective actions.
implementation to support flexible deployment  our system compiles a bp-mon query q into a bpel process specification s  whose instances perform the monitoring task. as for all standard bpel specifications  s can now be automatically compiled into executable code to be run on the same bpel application server as the monitored bp. our experiments prove that the resulting monitoring is extremely efficient and incurs only very minimal overhead.
query evaluation and optimization users should be notified as soon as their patterns of interest occur. bp-mon uses an efficient automatabased algorithm that finds the first match of a query  execution pattern  in a given process trace. a novel optimization technique that prunes redundant monitoring activities based on an analysis of the process bpel specification  allows to speed up computation  by focusing on the relevant parts of the trace.
in summary  bp-mon allows to design complex monitoring tasks
that deal with both events and flow; it offers easy  user-friendly design of such tasks; and it compiles these tasks into standard bpel processes  thus providing easy deployment  portability  and minimal overhead.
related work and discussion. in a previous work  we proposed to use a graphical query language for querying bp specifications. there  the goal was to be able to retrieve specifications with certain properties  e.g. that an execution path from activity a to activity b is possible   and the solution relied on modeling specifications and queries as graph grammars. in contrast  our work here is concerned with querying the actual execution of process instances  e.g. to find when an execution path that started at activity a arrives to activity b   and the solution is based on automata construction. indeed the two works are complementary: the query language of  can be used to focus on parts of the pbs that require monitoring  while monitoring can be used to to check at runtime properties that cannot be statically determined by querying the specification.
　we have mentioned above that events are sent to monitoring systems in standard xml format. a natural question is why not use xquery  coupled with some xml stream-processing engine  1  1  1  1   to process this stream of events  a key observation is that the xml elements in this stream describe individual events. to express any non-trivial query about a process execution flow  one needs to write a fairly complex xquery query  that performs an excessive number of joins  and can hardly  if at all  be handled by existing streaming engines 1  1 . furthermore  standard xml stream processing would still be inadequate for the task  even if a more query-friendly nested xml representation  that reflects the flow  had been chosen for the data: xml stream engines manage tree-shaped data and not dags. more importantly  they expect to receive the tree elements in document order and process siblings sequentially  as they arrive 1  1 . but the events flow in bps does not necessarily follow this order since parallel activities interleave. here  parallel processing  that processes each event according to its position in the flow is called for; this is provided by bp-mon .
1.	demonstration
　to illustrate the features of bp-mon we will consider a set of bpel business processes used by a web-accessible auctioning business. the processes include seller and buyer services as well as accounting  credit  and price comparison facilities. they reside and operate on three peers  three computers  in our demo . we will show how the intuitive graphical bp-mon query interface is used to define monitoring queries for a variety of critical tasks such as fraud detection  sla  service level agreement  maintenance  and general business management. the ease of query formulation will be illustrated by comparing our graphical query interface to that used by commercial vendors for the specification of business processes  e.g.  ; there is a tight analogy between how processes are specified and how they are monitored.
　the system runs on windows xp professional  jboss as 1.1. oracle bpel process manager 1.1. with oracle 1i database. the system architecture is depicted in fig. 1. the demonstration will illustrate each of the components and their interaction. the visual interface is implemented as an eclipse plug-in  similarly to oracle bpel designer; both products can run simultaneously in the same framework.
visual editor. bp-mon queries are written via a visual editor  in one of two modes. the user can draw the query patterns that she wishes to monitor from scratch  using a drag-and-drop items palette. or  starting from a bpel specification of a bp p  use a wiz-

figure 1: architecture.
ard to create a query to monitor p  as follows: the user marks the nodes of the specification that she wishes to include in the query. then by one click a query pattern  draft is created  where non selected nodes are omitted and the selected nodes are connected with special edges that reflect their flow and zoom-in relationship in the specification. the user can then add conditions on the node values  detail the report data she wishes to see  make some final adjustment  and click a button to deploy the query on a bpel server.
　we will illustrate in the demonstration each of these two modes and show how  starting from the bpel specification of the auctioning bp  one can easily formulate monitoring queries for it. as an example  figure 1 shows  part of  the bpel specification of the auctioning bp with the nodes selected  in this part  by the user. the generated monitoring query  after some user adjustments  is shown in figure 1  ready to be deployed. we do not discuss the syntax here  but will naturally detail it in the demonstration. query translator. as mentioned in section 1  to support flexible deployment  the system compiles bp-mon queries into bpel specifications. this is done by the query translator module. the specification s p  generated for a query pattern p describes a process  essentially a sophisticated automaton  that will perform the monitoring task for p. s p  is called the query process  qp for short  of p. the qp is deployed onto the bpel server where the instances of p are executed. several qps  monitoring the same or different processes  may be deployed on a server. note that in principle one may even have queries that monitor the execution of other queries! in the demonstration we will show the bpel specification generated for the defined queries and the deployment of the corresponding qp. we will demonstrate how these monitoring tasks can be themselves monitored  e.g. to follow their progress. dispatcher. now that the qps are deployed onto the bpel server  we will demonstrate what happens at runtime. the dispatcher module is responsible for the run-time mapping between the events of bp instances and the qps. it subscribes to relevant events of the queried bps when a query is deployed  and receives the relevant events generated by instances of these bps  as described in section 1 . the first event from a new bp instance causes the dispatcher to create a new instance of relevant qps. further events are delegated to the running qp instances.
report generation. a successful matching for the query pattern associated with a report triggers the generation of a corresponding report or corrective action. two reporting modes are available: local  where an individual report is issued for each process instance  and global  that spans all the bp instances. for each report one can specify when should it be issued  e.g. at the first time that the pattern occurs  at periodic time interval  or when certain conditions are satisfied  and what should be the structure of the output  in xml format  or the actions triggered at this point. reports may include sliding window aggregations like average  max 

figure 1: selection from a bpel specification.

figure 1: edit query.
min  count  sum. we will show how different types of reports can be defined using the system's graphical editor  see above  and be attached to various parts of the query patterns  to be reported on match for the corresponding part.
　to conclude the demonstration  we will briefly present experimental results that demonstrate that the resulting monitoring is extremely efficient and incurs only very minimal overhead for the running pbs.
