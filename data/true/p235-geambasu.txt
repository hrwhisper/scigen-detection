this paper presents homeviews  a peer-to-peer middleware system for building personal data management applications. homeviews provides abstractions and services for data organization and distributed data sharing. the key innovation in homeviews is the integration of three concepts: views and queries from databases  a capability-based protection model from operating systems  and a peer-to-peer distributed architecture. using homeviews  applications can  1  create views to organize files into dynamic collections   1  share these views in a protected way across the internet through simple exchange of capabilities  and  1  transparently integrate remote views and data into a user's local organizational structures. homeviews operates in a purely peer-topeer fashion  without the need for account administration or centralized data and protection management inherent in typical data-sharing systems.
　we have prototyped homeviews  deployed it on a small network of linux machines  and used it to develop two distributed data-sharing applications: a peer-to-peer version of the gallery photo-sharing application and a simple readonly shared file system. using measurements  we demonstrate the practicality and performance of our approach.
categories and subject descriptors
d.1  operating systems : file systems management  security and protection; h.1  information systems : information search and retrieval; h.1  database management : systems - distributed databases  query processing
general terms
design  management  security
keywords
personal information management  access control  capabilities  peer-to-peer  search
permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. to copy otherwise  to republish  to post on servers or to redistribute to lists  requires prior specific permission and/or a fee.
sigmod'1  june 1  1  beijing  china.
copyright 1 acm 1-1-1/1 ...$1.
1.	introduction
　the volume of personal data created by home users far outpaces their ability to manage it. inexpensive storage  powerful multimedia appliances  e.g.  digital cameras  ipods  tivos   and new applications for creating and editing digital content provide home users with tools to generate enormous quantities of digital data. as a consequence  users face several challenges: they need to organize files into directories  search through large volumes of personal data to find objects of interest  and manually share their data with family  friends  and others connected through broadband networks.
　these challenges have motivated applications such as desktop search tools  which help users to locate and organize files using queries and views  1  1  1 . similarly  new peer-to-peer  1  1  and web-based  1  1  file-sharing systems help users to share their data. however  such tools fall short for three reasons. first  they are not integrated with each other or with other applications; therefore users must often employ several independent tools to manipulate  search  organize  and share their data. second  distribution is still visible and heavyweight in most of these tools  requiring manual uploads and downloads. third  many sharing tools do not deal with dynamically changing data collections  forcing users to take action every time they update shared data or add files to a shared collection. overall  using today's data organization  search  and sharing services is far from effortless for users.
　our goal is to simplify the creation of a new generation of personal data management and data sharing applications. to do this  we have designed and implemented homeviews  a middleware layer that provides a set of powerful application services. similarly to a dataspace support platform  dssp   1  1   which provides services to applications operating on a user's or organization's  dataspace   homeviews provides services to applications that operate on a user's personal and shared data files. homeviews' abstractions and services are thus geared toward personal data organization and sharing. specifically  homeviews supports:
  the creation of database-style views over a user's file repository 
  a lightweight protection mechanism for selective granting  and later revocation  of view access to remote users 
  seamless sharing and integration of local and remote data and views  and
  peer-to-peer communication between homeviews instances on peer computers.
　using homeviews  applications can leverage flexible organization and transparent sharing of distributed objects. for example  a photo-album application built on homeviews enables users to create and share dynamic photo albums with their friends  and to integrate their friends' shared photos with their own. the application focuses on high-level abstractions  albums in this case   while issues such as view creation  protection  and distributed query execution are managed by homeviews.
　homeviews' peer-to-peer structure provides direct ad-hoc data sharing between peer nodes. it requires no centralized servers or services  no user identities  and no user registration. all distribution is handled by homeviews and is transparent to the applications. homeviews views are dynamic: users can share views of changing data sets  rather than just static copies of their files.
　a crucial feature of homeviews is its simple  lightweight  and flexible protection mechanism for controlling access to shared views. protection in homeviews is based on capabilities  a protection model developed in the context of object-based operating systems  1  1  1  1 . a capability to a view is a data structure that binds together a global view name with access rights to that view. users grant each other access to their data simply by exchanging capabilities to their views  much like users share access to private web pages by exchanging urls. we show that capabilities are well matched to the goals of ad-hoc sharing in peer-to-peer environments that lack  or shun  the identities and coordinated management of common protection structures  such as user accounts or access control lists  acls .
　to simplify application development and to support sophisticated queries  homeviews provides a declarative query language interface based on sql. we show that a capabilitybased access control model can be easily integrated into sql  requiring only a small set of changes. the resulting language  called sqlcapa  enables definitions of new views atop previously defined local and remote views  and the subsequent sharing of these views without coordinated protection management. capabilities also enable rewriting and optimization of distributed queries  leading to good query execution performance.
　we have prototyped homeviews and built two applications on top of it. our current implementation targets readonly data sharing for medium-sized peer communities  e.g.  hundreds of users . this paper presents the homeviews design  our experience building high-level applications on homeviews  and measurements that validate our approach.
　the rest of the paper is organized as follows. section 1 provides a more in-depth motivation for the features of homeviews. section 1 presents a high-level overview of the system and gives a detailed technical description of its main components: the capability-based access control  the sql-based query language  and the distributed query execution. section 1 describes how to build applications on top of homeviews. we evaluate the performance of homeviews in section 1. section 1 discusses previous work  and we sum-
marize and conclude in section 1.
1.	motivation
as outlined above  personal data management needs are

figure 1: a simple photo organizing and sharing scenario. bob shares his christmas photo album with mom. when mom organizes her photos  some of bob's christmas photos end up in mom's italy album  1  while others go into mom's france album  1 . sharing is dynamic: when bob creates a new photo of christmas in italy  it appears automatically in all appropriate albums.
characterized by three key requirements. first  people need powerful but simple tools to organize their files. traditional organizational structures - static  hierarchical file directories - fall short when users' data collections grow large. as a result  desktop search tools  such as google desktop  or spotlight   have emerged. these tools index the user's files and support keyword or attribute-based search. tools such as spotlight also provide organizational help in the form of smart folders or views  which are dynamic collections of files populated by results from searches. for example  when the user creates a new file  the file appears in all the appropriate smart folders  based on its contents  extended attributes  or other metadata  such as id1 tags for audio files .
　second  people want to share data with friends  family  and colleagues across the internet. however  the ability to share selectively within a small trusted community is limited. while email remains one of the most commonly used data-sharing tools  it is inappropriate for sharing large or dynamically changing data collections. hosting services such as flickr  and youtube  have become popular for photo and video sharing  respectively. but these services are centralized and users must register with them to manually upload content. for protected sharing  recipients must register to view and download content. ultimately  users must trust the service with the storage and control of their data. this issue has become problematic in light of recent government data requests to internet services such as yahoo and google .
　an alternative to centralized services is peer-to-peer  p1p  file sharing  1  1 . p1p systems are designed for data sharing within communities  particularly where data is published to the entire community. however  p1p systems are not usually intended for selective sharing  i.e.  sharing data with restricted sets of users within the community.1
　finally  in a distributed data-sharing environment  people want to seamlessly integrate shared files  i.e.  files made available by other remote users  with their own local files. that is  they want to access data in a location-independent fashion. with current systems  users must manually copy or download shared data onto their home machines in order to include them in their local organizational structures. this is cumbersome  inefficient  and static.
　to make these problems concrete  consider the following simple family photo-sharing scenario. figure 1 shows three members of a family: bob  his mom  and his aunt betty. bob and mom are well-organized people who label their photos as they upload them from their cameras  noting the place  the date  the occasion when the pictures were taken  and other attributes. using their annotations  they choose to organize their photo collections into albums. however  bob and mom organize their albums differently. bob likes to create albums based on occasion: parties  thanksgiving  christmas  and so on. mom prefers to organize her albums based on where the photos were taken: e.g.  home  italy  france  etc. bob and mom would like these albums to be automatically populated  just like smart folders  with results from queries over the photo metadata.
　also  bob wants to share his christmas photos with mom  while keeping his party photos private  sharing them only with his close friends . mom would then like to integrate bob's shared photos into her own photo repository  but she wants to organize her global collection  including bob's photos  according to her own scheme - the place where the pictures were taken. so  when mom looks at the italy photos  she might find bob's photos of their christmas vacation in italy. similarly  her france photos will include bob's photos from another family christmas in france.
　mom knows that aunt betty loves italy and decides to share her italy album with her. aunt betty should then be able to organize all the photos  mom's italy photos and betty's own photos  in whatever way she wishes and further share her albums with her own friends. aunt betty's new organization should include the photos she received from mom  and via mom  from bob .
　finally  everyone in the family wants the photo sharing to be dynamic and transparent. for example  when bob creates a new photo from a christmas vacation in italy  this photo should automatically appear in all the appropriate albums.
　at a high level  then  this scenario suggests several requirements:  a  data is organized into views populated by queries over a base set of files;  b  views must be directly sharable with trusted parties  without the need to register with a service;  c  it should be possible to integrate remote data shared by others with local data; and  d  views are dynamic  their contents must change as underlying data are added or removed.
　our goal is to simplify the implementation of such dynamic personal-data-sharing applications by providing a set of common services for organization  protected sharing  and integration of data. in the next section we describe
homeviews and how it fulfills the requirements listed above.
1.	architecture and implementation
　homeviews provides services that allow applications to create  compose  and query dynamic  location-independent

figure 1: homeviews system architecture.
collections of files and to share them in a peer-to-peer environment. after we present the high-level architecture of our system  we describe in detail our implementation of homeviews  focusing on capability protection  query language  and query processing.
1	architectural overview of homeviews
　figure 1 shows the homeviews system architecture. homeviews sits between applications and the underlying file system. it presents applications a view-based interface to the filesystem. it executes queries over the local file system and communicates with other peers to evaluate distributed queries. more specifically  homeviews performs the following basic functions  which correspond to its internal structure shown in the figure.
　first  homeviews exposes to applications a database view abstraction of the file system. applications use this view abstraction to define dynamic collections of files on top of a user's local file storage. for example  an application can create a view of all party photos. to create or query views  applications issue requests to homeviews using a flexible query language  called sqlcapa  described in section 1 . the homeviews query parser receives requests and parses them into internal data structures.
　second  homeviews provides a lightweight access control scheme for views that is based on capabilities  1  1  1  1 . these functions are managed by the homeviews local capability validation layer. when an application creates a view using sqlcapa  homeviews validates the request  creates the view and a new capability for the view  registers the new view and capability in its local catalog  and returns the capability to the application. with the help of applications  users can grant each other access to views simply by exchanging capabilities. we describe homeviews' capability-based access-control further in section 1.
　for every incoming query  the capability layer determines whether the query is on a local view. if so  it uses the local catalog to validate the request. invalid queries return with an error. if the query is on a remote view  the capability layer forwards it to the distributed query execution layer.
　third  the distributed query execution layer shown in figure 1 is responsible for executing queries. it uses the local query engine to evaluate local queries and communicates with peer homeviews instances to validate and solve distributed queries. in this way  homeviews offers com-
      1 bits             1 bits                 1 bits 
  global view id       password         ip hint
figure 1: capability for a view.
node-local view table  viewtable 
   global view id    view definition     other attributes  
	...	...	...
node-local capability table  captable  global view id password rights ... ... ...
figure 1: capability and view catalog tables.
plete location independence: applications access views in the same way no matter where these views have been defined. homeviews uses a pull-based data access method  similar to that of the www: a user sees updates to a view only after re-evaluating the view. we present homeviews' query execution algorithms in section 1.
　below the distributed query execution layer  homeviews sees the file system as a database with a local query engine that provides indexing and keyword or attribute-based search functions. at this layer  we leverage existing tools for desktop search. our prototype uses beagle   a keywordbased desktop search engine for linux  which is similar to spotlight  or google desktop .
　since homeviews is a middleware layer  users do not interact directly with it. instead  they interact with applications that hide views  capabilities  and the query language behind application-specific abstractions and graphical interfaces. for example  the photo application envisioned in our example scenario displays albums and photos to users. underneath  it uses homeviews views to populate these albums and capabilities to access the views.
1	capability-based access control
　this section describes capability-based access control in homeviews. we introduce capabilities in general  describe homeviews' capability implementation  and discuss data sharing using capabilities. overall  we show that our protection approach is lightweight: it enables selective sharing and revocation while incurring little administrative overhead.
1.1	background
　conceptually  a capability consists of a name  which uniquely identifies a single object in the internet  and a set of access rights for that object. homeviews capabilities protect views and enable view sharing. a capability represents a self-authenticating permission to access a specified object in specified ways. it is like a ticket or door key: possession of a capability is proof of the holder's rights to access an object. without a capability for an object  a user cannot  name  or access the object.
　to be self-authenticating  a capability must be unforgeable. that is  it must be impossible to fabricate a capability  to modify the rights bits in a capability  or to change the  name  field to gain access to a different object. previous systems have guaranteed this property in various ways. these include encryption   storing capabilities in the os kernel   or using hardware tag bits to prevent modification to capabilities in memory . homeviews uses a password-capability model  1  1   in which the integrity of a capability is ensured through the use of sparse random numbers  called passwords  in an astronomically large space.
1.1	naming and access control in homeviews
　a homeviews capability has three parts  figure 1 . first  a 1-bit global view id uniquely identifies an individual view in the internet; no two views have  or will ever have  the same id. to achieve this property  each homeviews instance creates a global view id by concatenating a hash of the local node's mac address1 with a locally unique-forall-time view id. minting of new capabilities is therefore a local operation for the homeviews instance on a node and requires no coordination with other nodes.
　second  associated with each capability is a 1-bit random password that ensures the capability's authenticity. the protection is thus probabilistic  but the probability of guessing a valid capability is vanishingly small. to forge a homeviews capability requires guessing a 1-bit number consisting of both a valid 1-bit view id along with its associated 1-bit password.
　a 1-bit ip hint field in the capability contains the ip address of a node that likely contains or can locate the object addressed by the capability in the p1p network. in general  we expect that objects will not move in our network  and the ip hint will be the address of the node that created the capability and still holds its definition. if the hint fails  we fall back on a conventional distributed hash-table scheme for location . in this case  ip hints serve as entry points for a new node to join the peer-to-peer network.
　figure 1 shows the per-node catalog tables that hold view and capability information. for each view created on a node  there is one entry in a local view table  viewtable . the viewtable entry contains the global view id  the view definition  and other attributes  such as the human-readable view name . while a capability identifies only one view  multiple capabilities for the same view can exist  see section 1.1 .
　a node's capability table  captable  contains one entry for each capability minted to a locally known view. the captable entry stores the global view id of the named view  the password  and the access rights. storing access rights in the system catalog rather than in the capability itself eliminates the need for encryption or other mechanisms to protect the capability's rights from being forged.
　when homeviews receives a capability  it uses the ip hint to determine whether the capability is for a local view. if the capability is local  homeviews checks whether the  global view id  password  pair in the capability matches a  global view id  password  pair in captable. if so  the capability is valid  and homeviews then examines the access rights in captable to see if the requested operation is permitted. if the capability is not found in captable or the operation is not permitted  the request fails. if the capability is for a remote view  homeviews forwards the request to the appropriate node in the peer-to-peer network  which then performs the validation itself.
　to revoke a capability  homeviews simply removes an entry from the captable. once a capability is revoked  all queries issued on that capability will fail. of course  if a

figure 1: solving the photo sharing scenario with views and capabilities. rectangles denote views  e.g.  'christmas' is the view of all bob's christmas photos; circles denote capabilities  e.g.  cc is bob's capability to his 'christmas' view. cc1 is a copy of cc that bob sent to mom to share the 'christmas' view with her. mom's 'italy' view composes two capabilities  cc1 and cm1.
user with a capability has made a local copy of the shared data  revoking the capability cannot prevent them from distributing that copy. it does  however  prevent the holder from executing a query and seeing new or modified files that would result from that query.
　because a capability is independent of the person using it  homeviews' access control scheme requires no user identities. thus  sharing in a capability-based model requires no user accounts  no user authentication  and no centralized protection structures.
1.1	sharing
　capabilities facilitate data sharing because they can be easily passed from user to user as a way to grant access. figure 1 illustrates the use of capabilities for the dynamic album-sharing scenario we previously presented. an album corresponds to a homeviews view; it is is accessed through a capability and populated with results from querying the view. for example  the figure shows that bob has a capability  cc  for his 'christmas' album. bob shared this album with mom by giving her a copy of his capability  shown as cc1   for that album. when mom looks at her italy album  her application uses that capability to query bob's album  integrating the results with those from her local files.
　as previously noted  a capability is a 1-bit data structure  shown in figure 1   which names and protects a view. in this form  a capability would be difficult for users to deal with. however  applications typically store capabilities as part of their internal representation of the abstractions they support  such as albums in our example . applications can then convert capabilities to a different form when passing them to users. this form is a human-readable text string that we call a token. for example  when a user requests a capability from our photo-album application  the application produces a url as a token. the url is simply a text string that includes the capability  encoded as a numeric string  as an embedded parameter. the user can then treat that url as a capability  storing it  passing it to an application  or passing it to others as he wishes.
returning to our previous scenario  to share his christ-
mas album  bob obtains a token for it from his application. he then emails it to mom  just as he would email her a
url to a web page. mom then presents the url to her local photo application as proof of her right to access bob's album. given the url  the application extracts the capability and executes homeviews queries on the remote view to populate the local albums. of course  tokens are best
sent in secure email.1
　as mentioned previously  sharing capabilities is similar to exchanging urls to folders holding a user's private files  except that capabilities enable selective revocation and provide a greater range of access rights  as we discuss in section 1 . like urls  a user must trust his friends not to forward capabilities to people who should not have access to the data. our protection system is intended to enable selective sharing within trusted communities  while preventing access from disconnected third parties; however  it cannot prevent cheating by trusted peers. similar trust assumptions exist for other protection mechanisms  as well. for example  consider an access control list  acl  scheme. when a user adds his friend to an object's acl  nothing stops the friend from copying the object and distributing it further  or from acting as an invisible proxy for unwanted third parties.
　overall  we believe that several features of capability protection make it perfectly suited for our target environment of protected peer-to-peer data sharing. capabilities are easily exchanged using simple channels that users are accustomed to. they are anonymous  require no identities  no global authentication  and no centralized or distributed management of protection structures. in these ways  they are consistent with the goals of a p1p system.
1	query language
　to facilitate application development  homeviews offers a flexible relational query language interface that enables sophisticated queries over files. homeviews' query language  sqlcapa  is a modified version of sql with integrated capability-based access control. our sql modifications are simple and intuitive  and the resulting language is easy to understand and enables seamless view sharing and composition across peers.
　homeviews models the file system as a single relation  called files. each tuple in the relation represents one file. all files that are indexable by a desktop search engine are included in the files relation  e.g.  annotated files  office documents  emails  etc. . the schema of the relation is the set of all known file attributes  e.g.  name  author  date  music genre  photo resolution . file contents are also included in the relation either under the 'text' or 'binary' attributes. if a file does not support an attribute  it has a null value for that attribute. using a single relation permits files of different types to be returned as part of a single query.
　on this relation  applications define views using predicates on file attributes and content. views can also be composed with union  set difference  and intersection operators. table 1 summarizes sqlcapa's modifications to sql. we now describe these modifications in more detail.
1.1	specifying capabilities with queries
　to execute queries on views  homeviews client applications must present appropriate capabilities as proof of authority. this requirement is reflected in sqlcapa. because a capability identifies exactly one view  capabilities are used
new/modified statementreturn typemeaningselect  fromcap	 where ...  relationquerycreate view viewname ascapabilitycreate a view and a capability to the view.select statement union/...select statement select  fromcatalog	of	capcatalog infolook up capability in catalogcreatebaseviewcapabilitycreate the base viewdrop viewcapvoiddrop view associated with capabilityalter viewcap	...voidmodify view associated with capabilityrestrictcaprights	rightscapabilitycreate new capability to same view  possibly with different access rightsrevokecap1using	cap1voidrevoke capability cap1table 1: sql modifications. cap  cap1  and cap1 are capabilities; rights is a string that encodes access rightsdirectly to name views in the from clause of the select statement. with this approach  the semantics of select statements remain unaltered. only the view naming scheme changes. therefore  the query:
select * from cc1
　　where date   '1-1' and place = 'france' returns bob's france christmas photos taken after jan. 1st 1. cc1 is mom's capability to bob's view  see figure 1   date is the file creation date  and place is the attribute indicating the location where the picture was taken. this query selects all attributes  including the file content.
　homeviews also supports keyword queries with a simplified form of the contains predicate used by sql server . in homeviews  the predicate takes the form: contains
 column  'k1  k1  ...  kn'   where column indicates the column to search  and k1 through kn are the keywords that must be present for the result to match the query. for example  if each photo has an attribute description  the query:
select * from cc1
　　where contains  description 'snow'  returns all of bob's christmas photos with snow  or more precisely  those photos that include the keyword  snow  in their 'description' attribute .
1.1	creating views
　views are created using the standard create view statement. once again  capabilities serve to name the underlying views. more importantly  the create view statement returns a capability to the newly created view. this initial capability has all rights enabled. thus  the query:
create view italy as
select * from cm1 where place = 'italy'
union
select * from cc1 where place = 'italy' ★cit
creates the 'italy' view for mom. the right arrow denotes the returned capability  cit  for the new 'italy' view. this view is a seamless composition of a local view  mom's files  specified by cmo  and a remote view  bob's shared files  specified by cc1  . similarly  applications specify capabilities instead of view names to alter or drop views.
　to bootstrap the system  we add a new create baseview statement that creates the first capability and view in the
system for a specific user. the returned capability provides access to the view containing all files in the file system that are visible to the user. the underlying file system's access control determines this set of files. from this initial capability  which has all rights enabled  the user's applications can execute queries and create additional views. as an example  figure 1 shows mom's base view and her initial capability  cm1  to that view.
1.1	capability restriction
　to share access to a view  a client application can directly pass the capability returned by the create view statement to the sharee. in most cases  however  users may want to limit their friends' access rights to a view.
to support this operation  we introduce the statement
restrict. given a valid capability x  restrict x rights rights creates a new capability that refers to the same view as x. the rights clause enumerates all rights to be enabled on the view; only rights already present in x can be carried onto the restricted capability. before mom shares her 'italy' view with aunt betty  she can ask her application to give her a restricted capability  cit1 . the application creates that capability by issuing the following statement to homeviews:
restrict cit rights select ★cit1
mom can then email cit1  instead of cit  to betty; this gives betty the ability to look at the italy photos  but prevents her  for example  from looking up the definition of the view in the catalog. currently  homeviews supports the following rights: select  read   drop  delete the view   alter  modify the view definition   revoke  revoke capabilities defined for the view   and catalog lookup  look up the view definition in the catalog . file creation  removal  and updates are currently performed outside of homeviews  through the file system. hence  only the owner of a file can modify it.1
1.1	capability revocation
　applications can revoke previously created and shared capabilities with the revoke statement. given two valid capabilities  cit and cit1   to the same underlying view  if cit has the revoke right enabled  then the statement: revoke cit1 using cit revokes capability cit1 . any subsequent use of cit1 will fail. this revoke statement would revoke aunt betty's capability to mom's 'italy' view.
　to revoke a capability  an application must have another capability to the same view that has the revoke right enabled. this ensures that arbitrary applications  and their users  cannot revoke capabilities. by default  capabilities returned by the create view statement have all rights enabled. thus  the 'owner' of a view  the user on whose behalf it was created  can revoke all capabilities for that view. a reasonable policy is for applications to restrict the capabilities on behalf of users before sharing them and never enabling the revoke right in these restricted capabilities. homeviews  however  does not enforce this policy.
1.1	catalog information lookup
　views and capabilities are stored in two catalog tables  see section 1 . the catalog lookup right enables the capability holder to access only the attributes corresponding to her capability  x  with a statement of the form:
　　select * from viewtable v  captable c where v.globalviewid = c.globalviewid and v.globalviewid = globalviewid x  where globalviewid x  returns the global view id of capability x.
　to simplify catalog lookups  we introduce the shorthand notation catalog of to refer to the results of the above query. mom's application can look up the definition of bob's view of 'christmas' photos with the statement: select definition from catalog of cc1 .
　in summary  the main change we propose to sql - from which most other changes derive - is the use of capabilities to access and name views. although we currently do not support joins  the query language can easily be extended to include this operator.
1	query processing
　homeviews can process queries in several ways. the choice depends in part on the catalog lookup rights of the capabilities involved in the query.
1.1	query execution algorithms
　recursive evaluation. if capabilities do not have the catalog lookup right  then homeviews evaluates the query recursively. recursive evaluation pushes queries from peer to peer down the view definition tree  validating access on each node in the tree. results are then returned and aggregated hop-by-hop following the same tree. figure 1 shows the detailed algorithm for recursive query evaluation. note that homeviews nodes do not perform arbitrary computation on behalf of other nodes. homeviews drops queries from remote nodes if they access views that are not locally defined. our algorithm is best-effort: it returns as many results as are available at the time of the query execution.
　query rewrite and optimization. if capabilities include the catalog lookup right  homeviews first fetches all view definitions by contacting the nodes where the views are defined. it then rewrites the query in terms of base views and executes the simplified distributed query. in this approach  each capability is validated during the catalog lookup phase. in a typical query  different capabilities have different rights  and query evaluation is a hybrid of the above two schemes. our general model also supports a query optimizer  although we have not yet implemented one. for optimization  the catalog lookup could return statistics in addition to the view definition. a standard cost-based query optimizer could then determine an appropriate query execution plan. the distributed plan could span nodes holding base views  but also other nodes in the system.
input: a query - select * from c1 where q  where c1 is a capability to view v   and q is a selection expression
output: query result
1. determine node where c1 should be evaluated  use ip hint 
1. if c1 can be evaluated locally then
1. look up c1 in local catalog and verify validity  section 1 
1. if c1 is invalid then return error
1. look up view definition in local catalog
1. if v is a base view then
1. forward query to query engine and return result
1. else: view v is defined on capabilities c1 c1 ... cn
1. foreach capability ci do
1. recursively evaluate ci  pushing selections downwards
1. process results from subqueries and return result
1. else
1. forward query remotely and return result	figure 1:	recursive query evaluation algorithm.
1.1	implications of the catalog lookup right
　allowing others to look up view definitions supports query rewrite and optimization  potentially improving query execution performance  as shown in section 1 . there are situations  however  when a user may not want to let others look up a view definition. in our scenario  bob's  christmas  view is defined on a capability to his base view. if bob lets mom look up the definition of the christmas view  she will gain access to bob's base view capability. bob may thus want to prevent mom from looking up catalog information to protect his 'party' photos from her.
1.	applications
　in this section  we show how homeviews supports personal data management and sharing applications. we describe two data-sharing applications that we built on top of homeviews and use our experience to show what features homeviews provides to applications and what features applications need to implement themselves.
1	two data-sharing applications
　we built two applications on top of homeviews: viewgallery and viewfs. viewgallery is a modified version of the well-known centralized photo-sharing application gallery v.1 . viewgallery allows users to organize their photos into distributed dynamic albums and to share them in a p1p fashion. it uses homeviews views to populate photo albums and capabilities to access and share these albums. each photo album is associated with one view. whenever a user opens an album  viewgallery submits a query to homeviews using the capability to the corresponding view. homeviews returns a list of photos that match the query  which the application displays as the album. since viewgallery albums are built on location-independent views  they can be composed of local and remote albums. we support the following features of gallery v.1: gallery and album thumb-level visualization and navigation  album sharing with other people on the internet  album creation  and album naming. our modifications disabled the following features: rating of photos  because we currently support only read-only sharing  and downloading an album  which is no longer needed  since the integration of files into local albums is now transparent .
　viewfs is a simple file system layer that we implemented on an early homeviews prototype. it allows users to create distributed dynamic directories and offers read-only access to the files in these directories. viewfs' directories are dynamically populated by results from querying homeviews location-independent views. users create directories to organize their own files and files shared by other users. viewfs supports directory creation  deletion  and listing.
1	application requirements
　the goal of the homeviews middleware is to provide abstractions that reduce the complexity of building distributed personal information management applications  by decreasing the set of features that applications must implement. table 1 shows an open list of application features  partitioned into those provided by homeviews and those that must or may be implemented by applications built on homeviews. we use our experience with viewgallery and viewfs to describe how applications can implement each feature.
　first  an application must construct its own applicationlevel abstractions defined on top of homeviews' view abstraction. for example  viewgallery exposes a dynamic album abstraction  and viewfs offers a dynamic directory abstraction. to implement their abstractions  applications must track and store the association between their abstractions and homeviews capabilities.
　second  applications must provide a user interface for manipulating their abstractions. viewgallery uses the unmodified gui from gallery 1 to display albums. for album creation  it exposes a web form that hides homeviews' sql-based query language. the form also lets users select backgrounds and other attributes for their new albums. viewfs is simpler; it exposes a standard unix file system interface to its users. when a user executes ls on a directory  viewfs lists the files in the view associated with that directory. when a user executes mkdir  viewfs creates a directory from a query on top of one or more capabilities specified in the mkdir command.
　third  applications may wish to store applicationdependent metadata associated with their abstractions. for example  viewgallery needs to save styles  backgrounds  and other metadata for its albums. viewfs  which has fewer options  does not need to do that.
　fourth  applications can support sharing by helping users to pass capabilities to others. as previously noted  we use email to transmit capabilities from one user to another. viewgallery could easily provide an  email this album  function - similar to the numerous web sites that provide this function for urls. clicking on the function would open a web form for the user to enter the email of the recipient. the form might also allow the user to specify the rights to enable in the capability that would be mailed. while we have not yet implemented this feature  it would be straightforward to provide.
　on the receiving side  applications must present an interface for users to inject capabilities received via email into the application. viewgallery exposes a form interface for this purpose. viewfs uses a simple mkdir command that creates a dynamic directory atop a remote capability.
　finally  as seen in section 1  homeviews provides a mechanism for revoking capabilities. however  remembering capabilities that have been given out is an application-level task. to help users choose the right capability to revoke  an application could track the association between a shared capability and the recipients. this would be simplified if the application supported an  email this capability  function.
home-applicationsfeatureviewsview-view-galleryfsview operations  create  drop xquery executionxdistributionxcapability generationxcapability revocationxapp-level abstractions  r xx graphical  user interfaces  r xxmetadata for app-level abstractions  o xtransmit capabilities  o track capabilities  o help users annotate files  o table 1: application features and where they are implemented. applications provide additional features  some of them are required  r  and others are optional  o .
　previously  we have assumed that files are either annotated  e.g.  bob's photos all have the location set  or that content-based search is performed. these annotations or attributes are entirely application-dependent and are not interpreted by homeviews. some applications may want to help users annotate their files so they can build richer queries.
　in summary  applications built on top of homeviews must focus primarily on high-level abstractions  user interfaces  and application-specific metadata issues. homeviews handles view creation  protection  and distribution.
1	building viewgallery
　we briefly describe our experience implementing viewgallery  since it is the more complex of our two applications. porting gallery v.1 to homeviews was a simple process. one developer spent roughly seven work days on the port: one day to review the source code; two days to remove functions related to user account access validation  integrity checks for album modifications outside of gallery  etc.; and the remaining four days to implement the features mentioned in the previous section. overall  we modified only 1 out of 1 files  added or modified 1 lines of code  and removed 1. the result of this straightforward port  from gallery to viewgallery on top of homeviews  was to change a centralized application into a distributed  peer-topeer application supporting album sharing  dynamic views  and integration of local and remote views.
1.	evaluation
　this section uses results from microbenchmarks to characterize distributed query performance in homeviews. our goal is to determine:  1  the impact of various system components on overall performance  and  1  whether homeviews is sufficiently fast to organize and share data in practice.
　we prototyped homeviews on linux using the opensource beagle  desktop search engine. we implemented view creation  catalog lookups  and both capability-based query evaluation algorithms  recursive evaluation and evaluation based on view rewrite .
　we ran all experiments on a collection of five dell pcs running fedora core 1 and beagle 1.1. at the high end were 1ghz pentium-1s with 1gb of memory. from our

figure 1: query execution-time breakdown for simple queries on local and remote views and for different result sizes. the local query processing time  beagle query time  forms the bulk of total query execution even for remote views.
measurements  we believe that the hardware differences in our environment had no significant impact on our results.
　for our tests  we synthetically generated a file database of 1 music files. we chose music files because their id1 tag attributes enable rich queries that are supported by beagle. we controlled the query result size by appropriately setting the id1 tags of different files. for example  to experiment with a query of size 1  we created 1 files with the album tag  album1  and a view that selected them.
　we examine both simple and complex queries. simple queries are one level deep; that is  they involve a single view  itself defined directly over a base view. complex queries involve views whose definitions include multiple other views composed in various ways.
1	evaluation of simple queries
　simple queries allow us to identify and reason about the impact of different components of our system on total query execution times. to evaluate simple queries  we measure the time to execute such queries both from the local machine and remotely. remote queries use a capability on one machine to access a view defined on another. we experiment with a 1 mbps local-area network  lan  and a slower 1 mbps  1 ms-delay network  characteristic of home-like broadband connections . our queries return file names  i.e.  we evaluate queries of the form select filename from cap. in our experiments  we also vary the query result size.
　figure 1 breaks down query execution time into components for simple queries on local and remote views. each value is the average over 1 trials. for local and lan configurations  most of the query execution time is due to beagle. capability validation time and other homeviews overhead  query parsing  view definition lookup in local catalog  and caching of local query results  are negligible  although the homeviews overhead increases slowly with result size.
　as the result size increases  the network transmission time becomes noticeable over slow connections. table 1 shows query execution times for larger-size query results. query execution is fast for medium-size results  both for local and remote views  under two seconds for 1 filenames . transmission delays increase evaluation time on slow networks when the result size is large. however  techniques such as
result sizetime  ms  # filenames beaglelocal evallanbroadband11111111table 1: local and remote evaluation of simple queries with large-size results. times are averages of 1 trials. as the result size increases  result transmission over broadband becomes the bottleneck.
result sizetime  ms spotlightlocal evallanbroadband11111111table 1: expected query execution times if spotlight were used instead of beagle. local  lan  and broadband evaluation times are computed from table 1 by replacing beagle query time with spotlight query time. in the simple-query benchmarks  requests are serial and the query engine time does not overlap with other homeviews components  which makes this a good approximation of homeviews based on spotlight.
streaming the results can be employed to reduce the userperceived response latency.
　since beagle represents a major component of query execution time  we ran some basic tests to compare it to spotlight  available on mac os x . we used out-of-the-box commands to access each tool: beagle-query for beagle and mdfind for spotlight. we used attribute-based queries in both cases. while spotlight has similar performance to beagle for queries with small results  up to 1 files   it scales much better for large result sizes  e.g.  for results containing 1 filenames mdfind is about 1 times faster than beagle-query .
　table 1 shows the expected local and remote homeviews query execution time if we replaced beagle with spotlight. after the substitution  total query execution times remain below 1 seconds even for 1-filename results evaluated over broadband. even with a fast local query engine such as spotlight  the other homeviews components  query parsing  capability validation  etc.  remain below 1% of the total local query execution time.
　thus  both local and remote query execution is fast for small result sizes. for large result sizes  query execution times are dominated by the query engine for lans or network latency for broadbands. however  with a fast query engine such as spotlight  even queries with many results over broadband can achieve good performance.
1	evaluation of complex queries
　in our system  views can be composed and distributed seamlessly. we now analyze the performance of more complex queries. views can be composed and distributed in two ways:  1  either by applying a selection on top of another  remote  view  in which case the depth of the view is said to grow   or  1  by applying union  set difference  or intersection on top of other  remote  views  in which case the breadth may also grow . figure 1 gives an intuition of the two dimensions in which views expand in our system. to create a view of a given depth  we initially define a view on top of the base view of a node  depth 1 . a capability to

figure 1: depth and breadth of views. dashed lines are machine boundaries; solid lines denote composition  via selection  union  etc. .
result sizeview depth # filenames 111111111111view breadth # filenames 11111111111table 1: recursive evaluation of complex queries on a
lan. reported times are in ms and are averages over 1 trials. view composition has little effect on recursive evaluation over fast networks.
that view is then given to another node that creates a new view defined on the remote one  the resulting view has depth 1   and so on until we reach the desired depth. similarly  to create views of increasing breadth  a node creates views defined as unions over increasingly many remote views.
　table 1 shows the results of recursive query evaluation over deep or broad views on a lan. because transmission costs are small  increases in execution time mainly show homeviews' overhead. as shown in the table  increasing the depth from one to five nodes leads to an increase in query execution time of 1% on average for the recursive evaluation and a 1-file result. for a 1-file result the same increase is only 1%. similarly  a 1-level increase in view breadth results in a 1% execution time increase when each query returns 1 file names. when each query returns 1 filenames  so 1 filenames are gathered at the root   the penalty of the 1-level breadth increase is only 1%.
　we see that as query result size increases  the overhead due to the large depth or breadth becomes small compared to the total cost  which is dominated by beagle . the increase for broad views is larger than that for deep views  because more file names are gathered at the root node in the former case. for small query results  the increase is proportionally higher primarily because all query execution times are already short. hence  homeviews scales well with the depth and breadth of views distributed over a fast network. figure 1 shows the increase in query evaluation time as the depth of a view increases over a network with limited bandwidth  1mbps  1ms delay . the results show both the recursive and query rewrite techniques. the recursive evaluation of large-size queries is now greatly affected by depth  because large network transfers occur from hop to hop back on the recursive path  e.g.  when the depth increases from one to five nodes  query execution time increases by 1% for a query returning 1 filenames .
in contrast  the performance of the query rewrite tech-

figure 1: query rewrite versus recursive query evaluation for deep views distributed over broadband. for small results recursive evaluation has very good performance; for deep views and large results  the query rewrite technique outperforms recursive evaluation.
nique is approximately constant for views deeper than two. indeed  the bulk of transfers  the results  occur only over one hop  from the base node to the 'root' node . hence  for queries with large-size results on deep views  rewrite is much more efficient than recursive evaluation. for a 1-filename query result and a depth of five  the benefit of applying the query rewrite technique is 1%. for small-size results  1 filenames   on the other hand  recursive evaluation is faster than query rewrite even for deep views: results are small and comparable in transmission time to view definitions.
　thus  on slow networks  recursive evaluation works well for small results and small view depths  while query rewrite improves performance for large results and deep views. for the most general case  in which queries are tree-shaped  both deep and wide   query execution time would be dominated by the deepest branch of the tree.
1	scalability
　so far  we have shown how our prototype performs when queries come one by one  for different complex query structures. we now show how the prototype scales as the number of incoming queries grows.
　when homeviews performs a distributed query  some nodes execute local queries  while others simply forward requests and results between peers. because local query execution is much more expensive than forwarding operations  see section 1   we only benchmark the scalability of a homeviews instance when all incoming query requests involve a local query.
　we used a closed-loop benchmark to measure the throughput of the system. after issuing a large number of concurrent requests  1   we generate a new request whenever an old request is completed. figure 1 shows the throughput for simple queries involving local search  for different result sizes. for small result sets  the system can support up to 1 concurrent requests. for increasing result sizes homeviews' throughput degrades as fast as beagle's own throughput  see the beagle component in figure 1 .
　using more efficient query engines would perhaps improve the system's throughput. overall  for our targeted mediumscale environment of hundreds of friends who share photos 

figure 1: homeviews throughput for different query result sizes.
blogs  videos  or other media over broadband  we do not expect that queries on each node will have high frequency. homeviews  possibly based on spotlight  should thus easily support the expected workload  even on popular nodes.
1	discussion
　our microbenchmarks show the parameters that characterize our system's performance and enable us to derive the scalability of the system in real deployments. our results demonstrate that our prototype is sufficiently fast to be practical in medium-scale environments. for local queries with large-size results  beagle dominates query execution times. using a faster local query engine  such as spotlight  could significantly improve performance and scalability. at the same time  the query engine would still account for the majority of the execution time. for queries executed remotely over slow networks  transmission latency adds significantly to the time. on fast networks  the depth and breadth of views have little influence on recursive query evaluation times. on slow networks  a simple rewrite of views in terms of base views yields good query execution performance even when result sizes are large.
　caching is known to increase a system's performance  availability  and scalability. in homeviews  applications can cache results from queries according to their own freshness policy to avoid running queries at small time intervals. also  file contents can be cached; this allows the system to reduce network traffic by transferring only new files or updates to existing files. an in-depth study of the effects of caching and replication on system performance is beyond the scope of our current study.
1.	related work
　in recent years  tools such as winfs   mac os x spotlight   and google desktop  have emerged  enabling users to create database-style views over their data. personal information management systems  e.g.   1  1   have begun to explore new techniques for organizing and searching personal information. in particular  the haystack  project enables users to define  view prescriptions  that determine the objects and relationships that an application displays on the screen. our work builds on the same idea of using views to organize personal data  but our goal is to facilitate the sharing and composition of these views in a p1p environment.
　peer-to-peer systems have become popular for sharing digital information  1  1 . the main goal of these systems is for all participants to share all their public data with all others. these systems thus focus on powerful and efficient search and retrieval techniques  e.g.   1  1  1  . in contrast  homeviews focuses on selective sharing of different data items with different users. homeviews is also geared toward a medium-scale system rather than the millions of users common in peer-to-peer file-sharing systems.
　operating systems and databases enable access control  and thus selective sharing  by providing mechanisms that associate privileges with users  1  1  1  1  1 .
　significant work focuses on the flexibility  correctness  and efficiency of these mechanisms  e.g.   1  1    making them well-suited for many application domains. from the perspective of sharing personal information  however  these techniques suffer from the same administrative burden: someone must create and manage user accounts. homeviews avoids this overhead by decoupling access rights from user identities. federated digital identities  1  1  1  have been proposed to allow registered users of an administrative domain to access resources from another administrative domain without requiring registration with the later. federated identities assume a contract or prior coordination between the participating administrative domains. homeviews has no such requirement.
　another selective sharing technique is to encrypt data with multiple keys and distribute different keys to different users . this approach is suitable only for static data sets that can be encrypted once and published. more dynamic sharing is possible  if users run secure operating environments. homeviews enables dynamic sharing without this restriction.
　the capability protection model has been previously applied to operating systems  1  1   languages   and architectures  1  1 . our sparse capabilities are related to previous password capability systems  1  1  1 . homeviews integrates concepts and mechanisms from capability systems into database views in a distributed peer-to-peer system.
1.	conclusion
　this paper described homeviews  a new peer-topeer middleware system that simplifies the construction of distributed  personal-information-sharing applications. homeviews facilitates ad hoc  peer-to-peer sharing of data between unmanaged home computers. key to homeviews is the integration of a dynamic view-based query system with capability-based protection in a peer-to-peer environment. with homeviews  applications can easily create views  compose views  and seamlessly integrate local and remote views. sharing and protection are accomplished without centralized management  global accounts  user authentication  or coordination of any kind.
　we prototyped homeviews in a linux environment using the beagle search engine for keyword queries. our implementation and design show that capabilities are readily supported by a query language such as sql  which enables integrated view definition and sharing. we implemented two applications on top of homeviews  a simple file-sharing application and a port of the gallery photo-sharing application. our experience with gallery in particular shows the ease of supporting protected peer data sharing on top of homeviews. finally  our measurements demonstrate the negligible cost of our protection mechanism and the practicality of our approach for medium-scale environments.
1.	acknowledgements
　we would like to thank phil bernstein  tanya bragin  alon halevy  nodira khoussainova  sam madden  alexander moshchuk  charles reis  and dan suciu for their useful feedback on early versions of this paper.
　this work was supported by national science foundation grants nsf-1  nsf-1  nsf-1  and nsf-1  by an alfred p. sloan foundation fellowship  by the wissner-slivka chair  and by the torode family endowed career development professorship.
